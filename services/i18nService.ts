import React, { createContextuseContextuseStateuseEffect } from 'react' type Language = 'en' | 'es' interface Translations, { [key: string]: string | Translations } interface I18nContextValue, { language: LanguagesetLanguage: (lang: Language) => voidt: (key: stringparams?: Record <stringstring>) => string } const I18n Context = createContext <I18nContextValue | null>(null) class I18nService, { private translations: Record <LanguageTranslations> = { en: {}, es: {} } private currentLanguage: Language = 'en' private listeners: ((lang: Language) => void)[] = [] async l o adTranslations() { try {//In a real appthese would be loaded from files//For nowwe'll use inline translations const enModule: any = await import('@/lang/en.json') const esModule: any = await import('@/lang/es.json') this.translations.en = enModule?.default ?? enModule ?? {} this.translations.es = esModule?.default ?? esModule ?? {} } } catch (error) { console.error('Failed to load translations:', error) } } s e tLanguage(language: Language) { this.current Language = languagelocalStorage.s e tItem('keymaker_language', language) this.listeners.f o rEach((listener) => l i stener(language)) } g e tLanguage(): Language, { return this.currentLanguage } t r anslate(key: stringparams?: Record <stringstring>): string, { const keys = key.s p lit('.') let value: any = this.translations,[this.currentLanguage] for (const k of keys) { if (value && typeof value === 'object' && k in value) { value = value,[k] } else, {//Fallback to Englishvalue = this.translations.en for(const k of keys) { if (value && typeof value === 'object' && k in value) { value = value,[k] } else, { return key//Return key if translation not found } } break } } if (typeof value !== 'string') { return key }//Replace parameters if (params) { Object.e n tries(params).f o rEach(([paramval]) => { value = value.r e place(`,{${param} }`, val) }) } return value } s u bscribe(listener: (lang: Language) => void) { this.listeners.push(listener) return () => { this.listeners = this.listeners.f i lter((l) => l !== listener) } } } export const i18n Service = new I18 nS ervice() export function u s eI18n() { const context = u s eContext(I18nContext) if (!context) { throw new Error('useI18n must be used within I18nProvider') } return context } export function I18 nP rovider({ children }: { children: React.ReactNode }) { const [languagesetLanguageState] = useState <Language>('en') u s eEffect(() => {//Load saved language const saved = localStorage.g e tItem('keymaker_language') as Language if (saved && (saved === 'en' || saved === 'es')) { s e tLanguageState(saved) i18nService.s e tLanguage(saved) }//Load translationsi18nService.l o adTranslations()//Subscribe to language changes return i18nService.s u bscribe((lang) => { s e tLanguageState(lang) }) }, []) const set Language = (lang: Language) => { i18nService.s e tLanguage(lang) } const t = (key: stringparams?: Record <stringstring>) => { return i18nService.t r anslate(keyparams) } return React.c r eateElement( I18nContext.Provider, { value: { languagesetLanguaget } }, children) } 