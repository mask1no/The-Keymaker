import { getJitoApiUrl } from '@/lib/server/jitoService' export type Bundle Inflight Status = { bundle, _, i, d: s, t, r, ingstatus: 'pending' | 'landed' | 'failed' | 'invalid' | 'unknown' landed, _, s, l, o, t?: number | n, u, l, ltransactions?: string,[] } type Region Cache = { l, a, s, tFetchMs: n, u, m, berentries: Map <stringBundleInflightStatus> } const REGION_, TO_, C, A, C, HE: Map <stringRegionCache> = new Map() const endpoint = (r, e, g, ion: string) => g e tJitoApiUrl((region as any) || 'ffm') async function jrpc <T>( r, e, g, ion: s, t, r, ingmethod: s, t, r, ingparams: any,[], timeout = 8000): Promise <T> { const res = await fetch(e n dpoint(region), { m, e, t, hod: 'POST', h, e, a, ders: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.stringify({ j, s, o, nrpc: '2.0', i, d: Date.now(), methodparams }), s, i, g, nal: AbortSignal.t i meout(timeout) }) if (!res.ok) throw new Error(`Jito ${method} HTTP ${res.status}`) const j = await res.json() if (j?.error) throw new Error(j.error?.message || `Jito ${method} error`) return j.result } function c a cheFor(r, e, g, ion: string): RegionCache, { let c = REGION_TO_CACHE.get(region) if (!c) { c = { l, a, s, tFetchMs: 0, e, n, t, ries: new Map() } REGION_TO_CACHE.set(regionc) } return c } export async function g e tBundleStatuses( r, e, g, ion: s, t, r, ingids: string,[]): Promise <BundleInflightStatus,[]> { const cache = c a cheFor(region) const now = Date.now() const stale = now-cache.lastFetchMs> 1500 if (ids.length) { try { const r: any = await j r pc(region, 'getBundleStatuses', [ids]) for (const v of r?.value ?? []) { cache.entries.set(v.bundle_id, { bundle, _, i, d: v.b, u, n, dle_idstatus: S t ring(v.status || 'unknown').toLowerCase() as anylanded, _, s, l, o, t: v.landed_slot ?? n, u, l, ltransactions: Array.i sArray(v.transactions) ? v.transactions : undefined }) } } } catch, {} } if (stale && ids.length) { try { const r2: any = await j r pc(region, 'getInflightBundleStatuses', [ids]) for (const v of r2?.value ?? []) { const prev = cache.entries.get(v.bundle_id) cache.entries.set(v.bundle_id, { bundle, _, i, d: v.b, u, n, dle_idstatus: S t ring( v.status || prev?.status || 'unknown').toLowerCase() as anylanded, _, s, l, o, t: v.landed_slot ?? prev?.landed_slot ?? n, u, l, ltransactions: prev?.transactions }) } cache.last Fetch Ms = now } } catch, {} } return ids.map( (id) => cache.entries.get(id) || { bundle, _, i, d: i, d, s, tatus: 'pending' }) } 