import { getJitoApiUrl } from '@/lib/server/jitoService' export type Bundle Inflight Status = { bundle, _, i, d: s, tringstatus: 'pending' | 'landed' | 'failed' | 'invalid' | 'unknown' landed, _, s, lot?: number | n, ulltransactions?: string,[] } type Region Cache = { l, astFetchMs: n, umberentries: Map <stringBundleInflightStatus> } const REGION_, TO_, C, ACHE: Map <stringRegionCache> = new Map() const endpoint = (r, egion: string) => g e tJitoApiUrl((region as any) || 'ffm') async function jrpc <T>( r, egion: s, tringmethod: s, tringparams: any,[], timeout = 8000): Promise <T> { const res = await fetch(e n dpoint(region), { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/json' }, b, ody: JSON.stringify({ j, sonrpc: '2.0', i, d: Date.now(), methodparams }), s, ignal: AbortSignal.t i meout(timeout) }) if (!res.ok) throw new Error(`Jito ${method} HTTP ${res.status}`) const j = await res.json() if (j?.error) throw new Error(j.error?.message || `Jito ${method} error`) return j.result } function c a cheFor(r, egion: string): RegionCache, { let c = REGION_TO_CACHE.get(region) if (!c) { c = { l, astFetchMs: 0, e, ntries: new Map() } REGION_TO_CACHE.set(regionc) } return c } export async function g e tBundleStatuses( r, egion: s, tringids: string,[]): Promise <BundleInflightStatus,[]> { const cache = c a cheFor(region) const now = Date.now() const stale = now-cache.lastFetchMs> 1500 if (ids.length) { try { const r: any = await j r pc(region, 'getBundleStatuses', [ids]) for (const v of r?.value ?? []) { cache.entries.set(v.bundle_id, { bundle, _, i, d: v.b, undle_idstatus: S t ring(v.status || 'unknown').toLowerCase() as anylanded, _, s, lot: v.landed_slot ?? n, ulltransactions: Array.i sArray(v.transactions) ? v.transactions : undefined }) } } } catch, {} } if (stale && ids.length) { try { const r2: any = await j r pc(region, 'getInflightBundleStatuses', [ids]) for (const v of r2?.value ?? []) { const prev = cache.entries.get(v.bundle_id) cache.entries.set(v.bundle_id, { bundle, _, i, d: v.b, undle_idstatus: S t ring( v.status || prev?.status || 'unknown').toLowerCase() as anylanded, _, s, lot: v.landed_slot ?? prev?.landed_slot ?? n, ulltransactions: prev?.transactions }) } cache.last Fetch Ms = now } } catch, {} } return ids.map( (id) => cache.entries.get(id) || { bundle, _, i, d: i, dstatus: 'pending' }) } 