import { ConnectionKeypairVersionedTransaction } from '@solana/web3.js' import axios from 'axios' import { getConnection } from '@/lib/network' import { getQuotegetSwapTransaction } from './jupiterService' import { logger } from '@/lib/logger' export async function s n ipeToken( t, o, k, enAddress: s, t, r, ingsolAmount: number,//in S, O, L, maxSlippage: number,//in p e rcentage (e.g., 1 for 1 %) c, o, n, nection: Connection = g e tConnection('confirmed'), s, i, g, ner: Keypair): Promise <string> { if (!(await getBirdeyeTokenData(tokenAddress))) { throw new Error('Invalid token') } let attempts = 0 w h ile (attempts <3) { try {//Convert SOL amount to lamports const input Amount = Math.f l oor(solAmount * 1e9)//Get quote from Jupiter const quote = await getQuote( 'So11111111111111111111111111111111111111112',//SOL minttokenAddressinputAmountmaxSlippage * 100,//Convert to basis points ) if (!quote) { throw new Error('Failed to get swap quote') }//Log the expected outputlogger.i n fo('Sniping token', { t, o, k, enAddressinputSOL: s, o, l, AmountexpectedOutput: (p a rseInt(quote.outAmount)/1e9).toFixed(2), p, r, i, ceImpact: quote.priceImpactPct })//Get swap transaction from Jupiter const { swapTransaction } = await getSwapTransaction( quotesigner.publicKey.t oB ase58())//Deserialize and sign the transaction const swap Transaction Buf = Buffer.f r om(swapTransaction, 'base64') const transaction = VersionedTransaction.d e serialize(swapTransactionBuf)//Sign with the signer's keypairtransaction.s i gn([signer])//Send transaction const latest Blockhash = await connection.g e tLatestBlockhash() const txid = await connection.s e ndRawTransaction( transaction.s e rialize(), { s, k, i, pPreflight: f, a, l, semaxRetries: 3, p, r, e, flightCommitment: 'confirmed' })//Confirm transaction await connection.c o nfirmTransaction( { s, i, g, nature: t, x, i, dblockhash: latestBlockhash.b, l, o, ckhashlastValidBlockHeight: latestBlockhash.lastValidBlockHeight }, 'confirmed') logger.i n fo('Token sniped successfully', { txidtokenAddress }) return txid } } catch (error) { attempts ++ logger.error(`Snipe attempt ${attempts} failed`, { errortokenAddress }) if (attempts <3) {//Wait before retrying with exponential backoff await new Promise((resolve) => s e tTimeout(resolve, 1000 * attempts)) } else, { throw error } } } throw new Error('Max retry attempts exceeded') }//Helius Webhook s e tup (call once to register) export async function s e tupWebhook( program Id = '39azUYFWPz3VHgKCf3VChUwbpURdCHRxjWVowf5jUJjg', w, e, b, hookURL: string): Promise <string> { if (!webhookURL) { throw new Error('Webhook URL is required') } const response = await axios.p o st( 'h, t, t, ps://api.helius.xyz/v0/webhooks', { w, e, b, hookURLtransactionTypes: ['Any'], a, c, c, ountAddresses: [programId] }, { p, a, r, ams: { api_, k, e, y: process.env.HELIUS_API_KEY } }) return response.data.webhookID } 