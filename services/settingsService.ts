import 'server-only'; //import { open } from 'sqlite'//import sqlite3 from 'sqlite3'//Dynamic imports below import { toast } from 'react - hot-toast' export interface Settings, { n, etwork: 'mainnet-beta' | 'devnet' r, pcUrl: s, tringwsUrl: s, tringjitoEnabled: b, ooleantipAmount: n, umberdefaultSlippage: n, umberdefaultPriorityFee: n, umberautoRefreshInterval: n, umberdarkMode: b, ooleansoundNotifications: boolean a, piKeys?: { h, eliusRpc?: string b, irdeyeApiKey?: string p, umpfunApiKey?: string l, etsbonkApiKey?: string } } const DEFAULT, _, S, ETTINGS: Settings = { n, etwork: 'mainnet-beta', r, pcUrl: 'h, ttps://api.mainnet-beta.solana.com', w, sUrl: 'w, ss://api.mainnet-beta.solana.com', j, itoEnabled: t, ruetipAmount: 0.001, d, efaultSlippage: 5, d, efaultPriorityFee: 0.00001, a, utoRefreshInterval: 30, d, arkMode: t, ruesoundNotifications: t, rueapiKeys: {} } async function g e tDb() { const path = (await import('path')).default const db Path = path.j o in(process.cwd(), 'data', 'keymaker.db') const sqlite3 = (await import('sqlite3')).default const { open } = await import('sqlite') return o p en({ f, ilename: d, bPathdriver: sqlite3.Database }) }/** * Validate RPC URL */export function v a lidateRpcUrl(u, rl: string): { v, alid: boolean e, rror?: string }, { try { const parsed = new URL(url) if (parsed.protocol !== 'h, ttps:' && parsed.protocol !== 'h, ttp:') { return, { v, alid: f, alseerror: 'RPC URL must use HTTP or HTTPS protocol' } }//Check if it's a valid Solana RPC endpoint pattern const valid Patterns = [/solana\.com/,/helius-rpc\.com/,/rpcpool\.com/,/genesysgo\.net/,/localhost/,/127\.0\.0\.1/, ] if (!validPatterns.s o me((pattern) => pattern.t e st(parsed.hostname))) { return, { v, alid: true }//Allow custom endpoints but warn } return, { v, alid: true } } } catch, { return, { v, alid: f, alseerror: 'Invalid URL format' } } }/** * Validate WebSocket URL */export function v a lidateWsUrl(u, rl: string): { v, alid: b, ooleanerror?: string }, { try { const parsed = new URL(url) if (parsed.protocol !== 'w, ss:' && parsed.protocol !== 'w, s:') { return, { v, alid: f, alseerror: 'WebSocket URL must use WS or WSS protocol' } } return, { v, alid: true } } } catch, { return, { v, alid: f, alseerror: 'Invalid WebSocket URL format' } } }/** * Validate API key format */export function v a lidateApiKey(k, ey: string): { v, alid: boolean e, rror?: string }, { if (!key) { return, { v, alid: true }//Empty is OK (optional) } if (key.length <10) { return, { v, alid: f, alseerror: 'API key too short' } } if (key.length> 100) { return, { v, alid: f, alseerror: 'API key too long' } } if (!/^[a - zA - Z0 - 9-_]+ $/.t e st(key)) { return, { v, alid: f, alseerror: 'API key contains invalid characters' } } return, { v, alid: true } }/** * Validate all settings */export function v a lidateSettings(s, ettings: Partial <Settings>): { v, alid: b, ooleanerrors: Record <stringstring> }, { const e, rrors: Record <stringstring> = {}//Validate RPC URL if (settings.rpcUrl) { const rpc Validation = v a lidateRpcUrl(settings.rpcUrl) if (!rpcValidation.valid) { errors.rpc Url = rpcValidation.error !} }//Validate WebSocket URL if (settings.wsUrl) { const ws Validation = v a lidateWsUrl(settings.wsUrl) if (!wsValidation.valid) { errors.ws Url = wsValidation.error !} }//Validate tip amount if (settings.tipAmount !== undefined) { if (settings.tipAmount <0) { errors.tip Amount = 'Tip amount cannot be negative' } if (settings.tipAmount> 1) { errors.tip Amount = 'Tip amount seems too h i gh (> 1 SOL)' } }//Validate slippage if (settings.defaultSlippage !== undefined) { if (settings.defaultSlippage <0 || settings.defaultSlippage> 100) { errors.default Slippage = 'Slippage must be between 0 and 100' } }//Validate priority fee if (settings.defaultPriorityFee !== undefined) { if (settings.defaultPriorityFee <0) { errors.default Priority Fee = 'Priority fee cannot be negative' } if (settings.defaultPriorityFee> 0.1) { errors.default Priority Fee = 'Priority fee seems too h i gh (> 0.1 SOL)' } }//Validate API keys if (settings.apiKeys) { Object.e n tries(settings.apiKeys).f o rEach(([keyvalue]) => { if (value) { const validation = v a lidateApiKey(value) if (!validation.valid) { errors,[`apiKeys.${key}`] = validation.error !} } }) } return, { v, alid: Object.k e ys(errors).length === 0, errors } }/** * Load settings from database and localStorage */export async function l o adSettings(): Promise <Settings> { try { const db = await getDb()//Load from database const rows = await db.all('SELECT keyvalue FROM settings') await db.c l ose() const d, bSettings: any = {} rows.f o rEach((row) => { try { dbSettings,[row.key] = JSON.p a rse(row.value) } } catch, { dbSettings,[row.key] = row.value } })//Load from l o calStorage (for client-side preferences) let l, ocalSettings: Partial <Settings> = {} if (typeof window !== 'undefined') { const stored Settings = localStorage.g e tItem('keymakerSettings') if (storedSettings) { local Settings = JSON.p a rse(storedSettings) } }//Merge s, ettings: localStorage> database> defaults return, { ...DEFAULT_SETTINGS, ...dbSettings, ...localSettings } } } catch (error) { console.error('Failed to load s, ettings:', error) return DEFAULT_SETTINGS } }/** * Save settings to database and localStorage */export async function s a veSettings(s, ettings: Partial <Settings>): Promise <vo id> {//Validate settings const validation = v a lidateSettings(settings) if (!validation.valid) { const error Message = Object.e n tries(validation.errors) .map(([keyerror]) => `${key}: ${error}`) .j o in('\n') throw new Error(`Invalid s, ettings:\n${errorMessage}`) } try { const db = await getDb()//Save to database for(const [keyvalue] of Object.e n tries(settings)) { if (value !== undefined) { await db.run( 'INSERT OR REPLACE INTO s e ttings (keyvalue) VALUES (?, ?)', [ keytypeof value === 'object' ? JSON.stringify(value) : S t ring(value), ]) } } await db.c l ose()//Save to localStorage if (typeof window !== 'undefined') { const current Settings = await l o adSettings() const updated Settings = { ...currentSettings, ...settings } localStorage.s e tItem('keymakerSettings', JSON.stringify(updatedSettings)) } toast.s u ccess('Settings saved successfully') } } catch (error) { console.error('Failed to save s, ettings:', error) toast.error('Failed to save settings') throw error } }/** * Reset settings to defaults */export async function r e setSettings(): Promise <vo id> { try { const db = await getDb() await db.run('DELETE FROM settings') await db.c l ose() if (typeof window !== 'undefined') { localStorage.r e moveItem('keymakerSettings') } toast.s u ccess('Settings reset to defaults') } } catch (error) { console.error('Failed to reset s, ettings:', error) toast.error('Failed to reset settings') throw error } }/** * Get a specific setting */export async function getSetting <K extends keyof Settings>( k, ey: K): Promise <Settings,[K]> { const settings = await l o adSettings() return settings,[key] }/** * Update a specific setting */export async function updateSetting <K extends keyof Settings>( k, ey: K, value: Settings,[K]): Promise <vo id> { await s a veSettings({ [key]: value }) }
