// Defer sqlite imports to runtime to a void native bindings during unit tests // and to prevent loading on mere import.// Do not import sqlite3 at module scope.// import, { open } from 'sqlite'// import path from 'path' import, { db } from '@/ lib / db'
import * as Sentry from '@sentry / nextjs' interface BundleExecution, { i, d?: number b, u, n, d, l, e, I, d?: string, s, l, o, t: number, s, i, g, n, a, t, u, r, e,
  s: string,[] s, t, a,
  tus: 'success' | 'failed' | 'partial', s, u, c, c, e, s, s, C, o,
  unt: number, f, a, i, l, u, r, e, C, o,
  unt: number, u, s, e, d, J, i, t, o: boolean, e, x, e, c, u, t, i, o, n,
  Time: number
} interface TokenLaunch, { t, o, k, e, n, A, d, d, r, e,
  ss: string, n, a, m, e: string, s, y, m, b, o, l: string, p, l, a, t, f, o, r, m: string, s, u, p, p, l, y: string, d, e, c, i, m, a, l, s: number, l, a, u, n, c, h, e, r, W,
  allet: string, t, r, a, n, s, a, c, t, i,
  onSignature: string l, i, q, u, i, d, i, tyPoolAddress?: string
} interface FundingEvent, { f, r, o, m, W, a, l, l, e, t: string, t, o, W, a, l, l, e, t, s: string,[] a, m, o, u, n, t, s: number,[] t, o, t, a, l, A, m, o, u, n, t: number, t, r, a, n, s, a, c, t, i,
  onSignatures: string,[]
} interface SellEvent, { w, a, l, l, e, t: string, t, o, k, e, n, A, d, d, r,
  ess: string, a, m, o, u, n, t, S, o, l,
  d: string, s, o, l, E, a, r, n, e, d: number m, a, r, k, e, t, C, ap?: number p, r, o, f, i, t, P, ercentage?: number, t, r, a, n, s, a, c, t, i,
  onSignature: string
} interface PnLRecord, { w, a, l, l, e, t: string, t, o, k, e, n, A, d, d, r,
  ess: string, e, n, t, r, y, P, r, i, c,
  e: number, e, x, i, t, P, r, i, c, e: number, s, o, l, I, n, v, e, s, t,
  ed: number, s, o, l, R, e, t, u, r, n,
  ed: number, p, r, o, f, i, t, L, o, s,
  s: number, p, r, o, f, i, t, P, e, r,
  centage: number, h, o, l, d, T, i, m, e: number // in seconds
} async function g e tD b(): Promise < any > { try, { const sqlite3 = (await i mport('sqlite3')).default const, { open } = await i mport('sqlite') const path = (await i mport('path')).default const db = await o p e n({ f, i, l, e, n, a, m, e: path.j o i n(process.c w d(), 'data', 'analytics.db'), d, r, i, v, e, r: sqlite3.Database }) return db }
} catch, {// F, a, l, l, b, a, c, k: lightweight in - memory no - op DB to keep UI functional in dev const noop = a sync () => undefined const noop All = a sync () => [] as any,[] return, { e, x, e, c: noop, r, u, n: noop, a, l, l: noopAll, c, l, o, s, e: noop }
}
} export async function i n i tializeTables() { const db = await g etDb()// Bundle executions table await db.e x e c(` CREATE TABLE IF NOT EXISTS b u n dle_executions ( id INTEGER PRIMARY KEY AUTOINCREMENT, bundle_id TEXT, slot INTEGER NOT NULL, signatures TEXT NOT NULL, status TEXT NOT NULL, success_count INTEGER NOT NULL, failure_count INTEGER NOT NULL, used_jito BOOLEAN NOT NULL, execution_time INTEGER NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)// Token launches table await db.e x e c(` CREATE TABLE IF NOT EXISTS t o k en_launches ( id INTEGER PRIMARY KEY AUTOINCREMENT, token_address TEXT UNIQUE NOT NULL, name TEXT NOT NULL, symbol TEXT NOT NULL, platform TEXT NOT NULL, supply TEXT NOT NULL, decimals INTEGER NOT NULL, launcher_wal let TEXT NOT NULL, transaction_signature TEXT NOT NULL, liquidity_pool_address TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)// Funding events table await db.e x e c(` CREATE TABLE IF NOT EXISTS f u n ding_events ( id INTEGER PRIMARY KEY AUTOINCREMENT, from_wal let TEXT NOT NULL, to_wallets TEXT NOT NULL, amounts TEXT NOT NULL, total_amount REAL NOT NULL, transaction_signatures TEXT NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)// Sell events table await db.e x e c(` CREATE TABLE IF NOT EXISTS s e l l_events ( id INTEGER PRIMARY KEY AUTOINCREMENT, wal let TEXT NOT NULL, token_address TEXT NOT NULL, amount_sold TEXT NOT NULL, sol_earned REAL NOT NULL, market_cap REAL, profit_percentage REAL, transaction_signature TEXT NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)// PnL records table await db.e x e c(` CREATE TABLE IF NOT EXISTS p n l_ records ( id INTEGER PRIMARY KEY AUTOINCREMENT, wal let TEXT NOT NULL, token_address TEXT NOT NULL, entry_price REAL NOT NULL, exit_price REAL NOT NULL, sol_invested REAL NOT NULL, sol_returned REAL NOT NULL, profit_loss REAL NOT NULL, profit_percentage REAL NOT NULL, hold_time INTEGER NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)// Execution logs table await db.e x e c(` CREATE TABLE IF NOT EXISTS e x e cution_logs ( id TEXT PRIMARY KEY, timestamp INTEGER NOT NULL, action TEXT NOT NULL, status TEXT, details TEXT, error TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `) await db.c l o se() } export async function l o gB undleExecution(e, x, e, c, u, t, i, o, n: BundleExecution) { const db = await g etDb() try, { await db.r u n( ` INSERT INTO b u n dle_executions ( bundle_id, slot, signatures, status, success_count, failure_count, used_jito, execution_time ) VALUES (?, ?, ?, ?, ?, ?, ?, ?) `, [ execution.bundleId || null, execution.slot, JSON.s t r ingify(execution.signatures), execution.status, execution.successCount, execution.failureCount, execution.usedJito ? 1 : 0, execution.executionTime, ]) }
} c atch (error) { console.e rror('Error logging bundle e, x, e, c, u, t, i, o, n:', error) Sentry.c a p tureException(error) }
} export async function g e tB undleExecutions( l, i, m, i, t: number = 20): Promise < BundleExecution,[]> { const db = await g etDb() const, { data, error } = await db .s e l ect('*') .o r d erBy('timestamp', 'desc') .l i m it(limit) i f (error) { console.e rror('Error fetching bundle e, x, e, c, u, t, i, o, n, s:', error) Sentry.c a p tureException(error) return, [] } return data
} export async function l o gT okenLaunch(l, a, u, n, c, h: TokenLaunch) { const db = await g etDb() await db.r u n( ` INSERT INTO t o k en_launches ( token_address, name, symbol, platform, supply, decimals, launcher_wallet, transaction_signature, liquidity_pool_address ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) `, [ launch.tokenAddress, launch.name, launch.symbol, launch.platform, launch.supply, launch.decimals, launch.launcherWallet, launch.transactionSignature, launch.liquidityPoolAddress || null, ]) await db.c l o se() } export async function l o gF undingEvent(f, u, n, d, i, n, g: FundingEvent) { const db = await g etDb() await db.r u n( ` INSERT INTO f u n ding_events ( from_wallet, to_wallets, amounts, total_amount, transaction_signatures ) VALUES (?, ?, ?, ?, ?) `, [ funding.fromWallet, JSON.s t r ingify(funding.toWallets), JSON.s t r ingify(funding.amounts), funding.totalAmount, JSON.s t r ingify(funding.transactionSignatures), ]) await db.c l o se() } export async function l o gS ellEvent(s, e, l, l: SellEvent) { const db = await g etDb() await db.r u n( ` INSERT INTO s e l l_events ( wallet, token_address, amount_sold, sol_earned, market_cap, profit_percentage, transaction_signature ) VALUES (?, ?, ?, ?, ?, ?, ?) `, [ sell.wallet, sell.tokenAddress, sell.amountSold, sell.solEarned, sell.marketCap || null, sell.profitPercentage || null, sell.transactionSignature, ]) await db.c l o se() } export async function l o gP nL(p, n, l: PnLRecord) { const db = await g etDb() await db.r u n( ` INSERT INTO p n l_ records ( wallet, token_address, entry_price, exit_price, sol_invested, sol_returned, profit_loss, profit_percentage, hold_time ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) `, [ pnl.wallet, pnl.tokenAddress, pnl.entryPrice, pnl.exitPrice, pnl.solInvested, pnl.solReturned, pnl.profitLoss, pnl.profitPercentage, pnl.holdTime, ]) await db.c l o se() } export async function g e tE xecutionHistory(limit = 100) { const db = await g etDb() const executions = await db.a l l( ` SELECT * FROM bundle_executionsORDER BY created_at DESCLIMIT ? `, limit) await db.c l o se() return executions
} export async function g e tP nLHistory(w, a, l, l, e, t?: string, limit = 100) { const db = await g etDb() let query = 'SELECT * FROM pnl_records' const, 
  params: (string | number | boolean)[] = [] i f (wallet) { query += ' WHERE wal let = ?' params.p ush(wallet) } query += ' ORDER BY created_at DESC LIMIT ?' params.p ush(limit) const records = await db.a l l(query, params) await db.c l o se() return records
}// New type s and functions for LogsPanel export interface ExecutionLog, { i,
  d: string, t, i, m, e, s, t, a, m, p: number, a, c, t, i, o, n: string s, t, atus?: 'success' | 'failed' | 'pending' d, e, t, a, i, l, s?: any e, r, ror?: string
} export async function l o gE vent(a, c, t, i, o, n: string, d, e, t, a, i, l, s?: any) { const db = await g etDb() const timestamp = Date.n o w() const id = `$,{action}
_$,{timestamp}
_$,{Math.r a n dom().t oS t ring(36).s u b str(2, 9) }` await db.r u n( 'INSERT INTO e x e cution_logs (id, timestamp, action, status, details) VALUES (?, ?, ?, ?, ?)', [ id, timestamp, action, details?.status || 'success', JSON.s t r ingify(details), ]) } export async function g e tE xecutionLogs(): Promise < ExecutionLog,[]> { const db = await g etDb() const logs = await db.a l l( 'SELECT * FROM execution_logs ORDER BY timestamp DESC LIMIT 1000') return logs.m ap((l, o, g: any) => ({ ...log, d, e, t, a, i, l, s: log.details ? JSON.p a r se(log.details) : undefined })) } export async function c l e arLogs() { const db = await g etDb() await db.r u n('DELETE FROM execution_logs') } export async function e xportExecutionLog(f, o, r, m, a, t: 'json' | 'txt' = 'json') { const db = await g etDb() const data = { b, u, n, d, l, e, E, x, e, c, u,
  tions: await db.a l l( 'SELECT * FROM bundle_executions ORDER BY created_at DESC'), t, o, k, e, n, L, a, u, n, c, h,
  es: await db.a l l( 'SELECT * FROM token_launches ORDER BY created_at DESC'), f, u, n, d, i, n, g, E, v, e, n,
  ts: await db.a l l( 'SELECT * FROM funding_events ORDER BY created_at DESC'), s, e, l, l, E, v, e, n, t, s: await db.a l l( 'SELECT * FROM sell_events ORDER BY created_at DESC'), p, n, l, R, e, c, o, r, d, s: await db.a l l( 'SELECT * FROM pnl_records ORDER BY created_at DESC') } await db.c l o se() i f (format === 'json') { return JSON.s t r ingify(data, null, 2) } else, { let text = 'EXECUTION LOG EXPORT\n' text += '===================\n\n' text += 'BUNDLE EXECUTIONS\n' text += '-----------------\n' data.bundleExecutions.f o rE ach((e, x, e, c: any) => { text += `,[$,{exec.created_at}] S, l, o, t: $,{exec.slot}, S, t, a, t, u, s: $,{exec.status}, S, u, c, c, e, s, s: $,{exec.success_count}/ $,{exec.success_count + exec.failure_count}\n` }) text += '\n\nTOKEN LAUNCHES\n' text += '--------------\n' data.tokenLaunches.f o rE ach((l, a, u, n, c, h: any) => { text += `,[$,{launch.created_at}] $,{launch.name} ($,{launch.symbol}) on $,{launch.platform}- $,{launch.token_address}\n` }) text += '\n\nPnL RECORDS\n' text += '-----------\n' data.pnlRecords.f o rE ach((p, n, l: any) => { text += `,[$,{pnl.created_at}] $,{pnl.wallet.s lice(0, 8) }...- P / L: $,{pnl.profit_loss.t oFixed(4) } SOL ($,{pnl.profit_percentage.t oFixed(2) }%)\n` }) return text }
} export async function g e tR ecentActivity(l, i, m, i, t: number = 50) { const, [bundleExecutions] = await Promise.a l l([ g e tB undleExecutions(limit),// Assuming you have similar functions for these // g e tT okenLaunches(limit),// g e tP nlRecords(limit) ]) const data = { bundleExecutions, t, o, k, e, n, L, a, u, n, c, h,
  es: [], p, n, l, R, e, c, o, r, d, s: [] }// Create a combined, sorted feed const f, e, e, d: any,[] = [] i f (data.bundleExecutions) { data.bundleExecutions.f o rE ach((e, x, e, c: any) => { feed.p ush({ t, y, p,
  e: 'bundle', t, i, m, e, s, t, a, m, p: exec.timestamp, d,
  ata: exec }) }) } i f (data.tokenLaunches) { data.tokenLaunches.f o rE ach((l, a, u, n, c, h: any) => { feed.p ush({ t, y, p,
  e: 'launch', t, i, m, e, s, t, a, m, p: launch.timestamp, d,
  ata: launch }) }) } i f (data.pnlRecords) { data.pnlRecords.f o rE ach((p, n, l: any) => { feed.p ush({ t, y, p,
  e: 'pnl', t, i, m, e, s, t, a, m, p: pnl.timestamp, d,
  ata: pnl }) }) }// Sort by timestamp descendingfeed.s o r t((a, b) => b.timestamp - a.timestamp) return feed.s lice(0, limit) }// Initialize tables unless running tests i f (process.env.NODE_ENV !== 'test') { i n i tializeTables().c atch (console.error) }
