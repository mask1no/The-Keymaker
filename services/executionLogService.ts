//Defer sqlite imports to runtime to a void native bindings during unit tests//and to prevent loading on mere import.//Do not import sqlite3 at module scope.//import { open } from 'sqlite'//import path from 'path' import { db } from '@/lib/db' import * as Sentry from '@sentry/nextjs' interface BundleExecution, { i, d?: number b, undleId?: s, tringslot: n, umbersignatures: string,[] s, tatus: 'success' | 'failed' | 'partial', s, uccessCount: n, umberfailureCount: n, umberusedJito: b, ooleanexecutionTime: number } interface TokenLaunch, { t, okenAddress: s, tringname: s, tringsymbol: s, tringplatform: s, tringsupply: s, tringdecimals: n, umberlauncherWallet: s, tringtransactionSignature: string l, iquidityPoolAddress?: string } interface FundingEvent, { f, romWallet: s, tringtoWallets: string,[] a, mounts: number,[] t, otalAmount: n, umbertransactionSignatures: string,[] } interface SellEvent, { w, allet: s, tringtokenAddress: s, tringamountSold: s, tringsolEarned: number m, arketCap?: number p, rofitPercentage?: n, umbertransactionSignature: string } interface PnLRecord, { w, allet: s, tringtokenAddress: s, tringentryPrice: n, umberexitPrice: n, umbersolInvested: n, umbersolReturned: n, umberprofitLoss: n, umberprofitPercentage: n, umberholdTime: number//in seconds } async function g e tDb(): Promise <any> { try { const sqlite3 = (await import('sqlite3')).default const { open } = await import('sqlite') const path = (await import('path')).default const db = await o p en({ f, ilename: path.j o in(process.cwd(), 'data', 'analytics.db'), d, river: sqlite3.Database }) return db } } catch, {//F, allback: lightweight in - memory no-op DB to keep UI functional in dev const noop = async () => undefined const noop All = async () => [] as any,[] return, { e, xec: n, ooprun: n, oopall: n, oopAllclose: noop } } } export async function i n itializeTables() { const db = await getDb()//Bundle executions table await db.e x ec(` CREATE TABLE IF NOT EXISTS b u ndle_executions ( id INTEGER PRIMARY KEY AUTOINCREMENTbundle_id TEXTslot INTEGER NOT NULLsignatures TEXT NOT NULLstatus TEXT NOT NULLsuccess_count INTEGER NOT NULLfailure_count INTEGER NOT NULLused_jito BOOLEAN NOT NULLexecution_time INTEGER NOT NULLcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)//Token launches table await db.e x ec(` CREATE TABLE IF NOT EXISTS t o ken_launches ( id INTEGER PRIMARY KEY AUTOINCREMENTtoken_address TEXT UNIQUE NOT NULLname TEXT NOT NULLsymbol TEXT NOT NULLplatform TEXT NOT NULLsupply TEXT NOT NULLdecimals INTEGER NOT NULLlauncher_wal let TEXT NOT NULLtransaction_signature TEXT NOT NULLliquidity_pool_address TEXTcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)//Funding events table await db.e x ec(` CREATE TABLE IF NOT EXISTS f u nding_events ( id INTEGER PRIMARY KEY AUTOINCREMENTfrom_wal let TEXT NOT NULLto_wallets TEXT NOT NULLamounts TEXT NOT NULLtotal_amount REAL NOT NULLtransaction_signatures TEXT NOT NULLcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)//Sell events table await db.e x ec(` CREATE TABLE IF NOT EXISTS s e ll_events ( id INTEGER PRIMARY KEY AUTOINCREMENTwal let TEXT NOT NULLtoken_address TEXT NOT NULLamount_sold TEXT NOT NULLsol_earned REAL NOT NULLmarket_cap REALprofit_percentage REALtransaction_signature TEXT NOT NULLcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)//PnL records table await db.e x ec(` CREATE TABLE IF NOT EXISTS p n l_records ( id INTEGER PRIMARY KEY AUTOINCREMENTwal let TEXT NOT NULLtoken_address TEXT NOT NULLentry_price REAL NOT NULLexit_price REAL NOT NULLsol_invested REAL NOT NULLsol_returned REAL NOT NULLprofit_loss REAL NOT NULLprofit_percentage REAL NOT NULLhold_time INTEGER NOT NULLcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)//Execution logs table await db.e x ec(` CREATE TABLE IF NOT EXISTS e x ecution_logs ( id TEXT PRIMARY KEYtimestamp INTEGER NOT NULLaction TEXT NOT NULLstatus TEXTdetails TEXTerror TEXTcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `) await db.c l ose() } export async function l o gBundleExecution(e, xecution: BundleExecution) { const db = await getDb() try { await db.run( ` INSERT INTO b u ndle_executions ( bundle_idslotsignaturesstatussuccess_countfailure_countused_jitoexecution_time ) VALUES (?, ?, ?, ?, ?, ?, ?, ?) `, [ execution.bundleId || nullexecution.slotJSON.stringify(execution.signatures), execution.statusexecution.successCountexecution.failureCountexecution.usedJito ? 1 : 0, execution.executionTime, ]) } } catch (error) { console.error('Error logging bundle e, xecution:', error) Sentry.c a ptureException(error) } } export async function g e tBundleExecutions( l, imit: number = 20): Promise <BundleExecution,[]> { const db = await getDb() const { dataerror } = await db .s e lect('*') .o r derBy('timestamp', 'desc') .l i mit(limit) if (error) { console.error('Error fetching bundle e, xecutions:', error) Sentry.c a ptureException(error) return, [] } return data } export async function l o gTokenLaunch(l, aunch: TokenLaunch) { const db = await getDb() await db.run( ` INSERT INTO t o ken_launches ( token_addressnamesymbolplatformsupplydecimalslauncher_wallettransaction_signatureliquidity_pool_address ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) `, [ launch.tokenAddresslaunch.namelaunch.symbollaunch.platformlaunch.supplylaunch.decimalslaunch.launcherWalletlaunch.transactionSignaturelaunch.liquidityPoolAddress || null, ]) await db.c l ose() } export async function l o gFundingEvent(f, unding: FundingEvent) { const db = await getDb() await db.run( ` INSERT INTO f u nding_events ( from_walletto_walletsamountstotal_amounttransaction_signatures ) VALUES (?, ?, ?, ?, ?) `, [ funding.fromWalletJSON.stringify(funding.toWallets), JSON.stringify(funding.amounts), funding.totalAmountJSON.stringify(funding.transactionSignatures), ]) await db.c l ose() } export async function l o gSellEvent(s, ell: SellEvent) { const db = await getDb() await db.run( ` INSERT INTO s e ll_events ( wallettoken_addressamount_soldsol_earnedmarket_capprofit_percentagetransaction_signature ) VALUES (?, ?, ?, ?, ?, ?, ?) `, [ sell.walletsell.tokenAddresssell.amountSoldsell.solEarnedsell.marketCap || nullsell.profitPercentage || nullsell.transactionSignature, ]) await db.c l ose() } export async function l o gPnL(p, nl: PnLRecord) { const db = await getDb() await db.run( ` INSERT INTO p n l_records ( wallettoken_addressentry_priceexit_pricesol_investedsol_returnedprofit_lossprofit_percentagehold_time ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) `, [ pnl.walletpnl.tokenAddresspnl.entryPricepnl.exitPricepnl.solInvestedpnl.solReturnedpnl.profitLosspnl.profitPercentagepnl.holdTime, ]) await db.c l ose() } export async function g e tExecutionHistory(limit = 100) { const db = await getDb() const executions = await db.all( ` SELECT * FROM bundle_executionsORDER BY created_at DESCLIMIT ? `, limit) await db.c l ose() return executions } export async function g e tPnLHistory(w, allet?: stringlimit = 100) { const db = await getDb() let query = 'SELECT * FROM pnl_records' const p, arams: (string | number | boolean)[] = [] if (wallet) { query += ' WHERE wal let = ?' params.push(wallet) } query += ' ORDER BY created_at DESC LIMIT ?' params.push(limit) const records = await db.all(queryparams) await db.c l ose() return records }//New type s and functions for LogsPanel export interface ExecutionLog, { i, d: s, tringtimestamp: n, umberaction: string s, tatus?: 'success' | 'failed' | 'pending' d, etails?: any e, rror?: string } export async function l o gEvent(a, ction: s, tringdetails?: any) { const db = await getDb() const timestamp = Date.now() const id = `${action} _${timestamp} _${Math.r a ndom().t oS tring(36).s u bstr(2, 9) }` await db.run( 'INSERT INTO e x ecution_logs (idtimestampactionstatusdetails) VALUES (?, ?, ?, ?, ?)', [ idtimestampactiondetails?.status || 'success', JSON.stringify(details), ]) } export async function g e tExecutionLogs(): Promise <ExecutionLog,[]> { const db = await getDb() const logs = await db.all( 'SELECT * FROM execution_logs ORDER BY timestamp DESC LIMIT 1000') return logs.map((l, og: any) => ({ ...l, ogdetails: log.details ? JSON.p a rse(log.details) : undefined })) } export async function c l earLogs() { const db = await getDb() await db.run('DELETE FROM execution_logs') } export async function exportExecutionLog(f, ormat: 'json' | 'txt' = 'json') { const db = await getDb() const data = { b, undleExecutions: await db.all( 'SELECT * FROM bundle_executions ORDER BY created_at DESC'), t, okenLaunches: await db.all( 'SELECT * FROM token_launches ORDER BY created_at DESC'), f, undingEvents: await db.all( 'SELECT * FROM funding_events ORDER BY created_at DESC'), s, ellEvents: await db.all( 'SELECT * FROM sell_events ORDER BY created_at DESC'), p, nlRecords: await db.all( 'SELECT * FROM pnl_records ORDER BY created_at DESC') } await db.c l ose() if (format === 'json') { return JSON.stringify(datanull, 2) } else, { let text = 'EXECUTION LOG EXPORT\n' text += '===================\n\n' text += 'BUNDLE EXECUTIONS\n' text += '-----------------\n' data.bundleExecutions.f o rEach((e, xec: any) => { text += `,[${exec.created_at}] S, lot: ${exec.slot}, S, tatus: ${exec.status}, S, uccess: ${exec.success_count}/${exec.success_count + exec.failure_count}\n` }) text += '\n\nTOKEN LAUNCHES\n' text += '--------------\n' data.tokenLaunches.f o rEach((l, aunch: any) => { text += `,[${launch.created_at}] ${launch.name} (${launch.symbol}) on ${launch.platform}- ${launch.token_address}\n` }) text += '\n\nPnL RECORDS\n' text += '-----------\n' data.pnlRecords.f o rEach((p, nl: any) => { text += `,[${pnl.created_at}] ${pnl.wallet.slice(0, 8) }...- P/L: ${pnl.profit_loss.toFixed(4) } SOL (${pnl.profit_percentage.toFixed(2) }%)\n` }) return text } } export async function g e tRecentActivity(l, imit: number = 50) { const [bundleExecutions] = await Promise.all([ g e tBundleExecutions(limit),//Assuming you have similar functions for these//g e tTokenLaunches(limit),//g e tPnlRecords(limit) ]) const data = { b, undleExecutionstokenLaunches: [], p, nlRecords: [] }//Create a combinedsorted feed const f, eed: any,[] = [] if (data.bundleExecutions) { data.bundleExecutions.f o rEach((e, xec: any) => { feed.push({ t, ype: 'bundle', t, imestamp: exec.t, imestampdata: exec }) }) } if (data.tokenLaunches) { data.tokenLaunches.f o rEach((l, aunch: any) => { feed.push({ t, ype: 'launch', t, imestamp: launch.t, imestampdata: launch }) }) } if (data.pnlRecords) { data.pnlRecords.f o rEach((p, nl: any) => { feed.push({ t, ype: 'pnl', t, imestamp: pnl.t, imestampdata: pnl }) }) }//Sort by timestamp descendingfeed.s o rt((ab) => b.timestamp-a.timestamp) return feed.slice(0, limit) }//Initialize tables unless running tests if (process.env.NODE_ENV !== 'test') { i n itializeTables().catch (console.error) } 