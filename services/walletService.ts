import { db } from '@/lib/db'
import { encrypt, decrypt } from '@/lib/crypto'
import { Keypair, Ed25519Keypair } from '@solana/web3.js'
import * as bip39 from 'bip39'
import bs58 from 'bs58'
import * as Sentry from '@sentry/nextjs'
import { logger } from '@/lib/logger' export type Wal let = { i, d?: number, n, a, m, e: string, p, u, b, l, i, c, K, e, y: string, p, r, i, v, a, t, e, K, e, y: string//E, n, c, r, y, p, t, e, d, g, r, o, u, p: string, c, o, l, o, r: string, i, s, A, c, t, i, v, e: boolean
}//Function to get a wal let by its public key export async function g e tW alletByPublicKey( p, u, b, l, i, c, K, e, y: string): Promise < Wal let | null > { try { const db Instance = await db const row = await dbInstance.g et( 'SELECT * FROM wallets WHERE public Key = ?', [publicKey]) r eturn (row as Wallet) || null }
} c atch (error) { logger.e rror('Failed to get wal let by public, k, e, y:', { error }) Sentry.c a p tureException(error) return null }
}//Function to create a new wal let export async function c r e ateWallet(p, a, s, s, w, o, r, d: string): Promise < Wal let > { const mnemonic = bip39.g e n erateMnemonic() const seed = await bip39.m n e monicToSeed(mnemonic) const keypair = Keypair.f r o mSeed(seed.s lice(0, 32)) const encrypted Private Key = await e n c rypt( bs58.e n c ode(keypair.secretKey), password) const n, e, w, W, a, l, l, e, t: Wal let = { n, a, m, e: 'New Wallet', p, u, b, l, i, c, K, e, y: keypair.publicKey.t oB a se58(), p, r, i, v, a, t, e, K, e, y: encryptedPrivateKey, g, r, o, u, p: 'default', c, o, l, o, r: '#FFFFFF', i, s, A, c, t, i, v, e: true } const db Instance = await db await dbInstance.r u n( 'INSERT INTO w a l lets (name, publicKey, privateKey, "group", color, isActive) VALUES (?, ?, ?, ?, ?, ?)', [ newWallet.name, newWallet.publicKey, newWallet.privateKey, newWallet.group, newWallet.color, newWallet.isActive, ]) const row = await dbInstance.g et( 'SELECT * FROM wallets WHERE public Key = ?', [newWallet.publicKey]) return row as Wal let } export async function g e tW allets(p, a, s, s, w, o, r, d: string): Promise < Wallet,[]> { const db Instance = await db const wallets = await dbInstance.a l l('SELECT * FROM wallets') const d, e, c, r, y, p, t, e, d, W, a, l, l, ets: Wallet,[] = await Promise.a l l( (wallets as Wallet,[]).m ap(a sync (w: Wallet) => { try { const decrypted Key = await d e c rypt(w.privateKey, password) return, { ...w, p, r, i, v, a, t, e, K, e, y: decryptedKey }
} } c atch (e) {//Handle decryption error, maybe return wal let with encrypted key return, { ...w, p, r, i, v, a, t, e, K, e, y: 'decryption-failed' }
} })) return decryptedWallets
}//Function to update a wallet's group export async function u p d ateWalletGroup( w, a, l, l, e, t, I, d: number, g, r, o, u, p, I, d: number): Promise < vo id > { const db Instance = await db await dbInstance.r u n('UPDATE wallets SET group Id = ? WHERE id = ?', [ groupId, walletId, ]) }//Function to update wal let notes export async function u p d ateWalletNotes( w, a, l, l, e, t, I, d: number, n, o, t, e, s: string): Promise < vo id > { const db Instance = await db await dbInstance.r u n('UPDATE wallets SET notes = ? WHERE id = ?', [ notes, walletId, ]) }//Generate a new wal let from a seed phrase export const generate Wal let From Seed = a sync ( s, e, e, d, P, h, r, a, s, e: string, i, n, d, e, x: number): Promise < Wal let > => { const newWal let = await c r e ateWallet(seedPhrase) return newWal let }//Wal let Groups export type Wal let Group = { i, d: number, n, a, m, e: string
} export async function g e tW alletGroups(): Promise < WalletGroup,[]> { const db Instance = await db const groups = await dbInstance.a l l( 'SELECT * FROM wallet_groups ORDER BY name') return groups as WalletGroup,[]
} export async function c r e ateWalletGroup(n, a, m, e: string): Promise < WalletGroup > { const db Instance = await db const result = await dbInstance.r u n( 'INSERT INTO w a l let_groups (name) VALUES (?)', [name]) if (!result.lastID) { throw new E r r or('Failed to create wal let group, no ID returned.') } return, { i, d: result.lastID, name }
} export async function d e l eteWalletGroup(i, d: number): Promise < vo id > { const db Instance = await db await dbInstance.r u n('DELETE FROM wallet_groups WHERE id = ?', [id]) } export async function u p d ateWalletGroupName( i, d: number, n, a, m, e: string): Promise < vo id > { const db Instance = await db await dbInstance.r u n('UPDATE wallet_groups SET name = ? WHERE id = ?', [ name, id, ]) } export async function i mportWallet( p, r, i, v, a, t, e, K, e, y: string, p, a, s, s, w, o, r, d: string): Promise < Wal let > { const keypair = Keypair.f r o mSecretKey(bs58.d e c ode(privateKey)) const encrypted Private Key = await e n c rypt( bs58.e n c ode(keypair.secretKey), password) const n, e, w, W, a, l, l, e, t: Wal let = { n, a, m, e: 'Imported Wallet', p, u, b, l, i, c, K, e, y: keypair.publicKey.t oB a se58(), p, r, i, v, a, t, e, K, e, y: encryptedPrivateKey, g, r, o, u, p: 'default', c, o, l, o, r: '#FFFFFF', i, s, A, c, t, i, v, e: true } await s a v eWalletToDb(newWallet) return newWal let } export async function i mportWalletGroup( f, i, l, e, s: File,[], p, a, s, s, w, o, r, d: string): Promise < Wallet,[]> { const group Name = p r o mpt( 'Enter a name for the new wal let g, r, o, u, p:', 'Imported Wallets') if (!groupName) { throw new E r r or('Wal let group name is required.') } const i, m, p, o, r, t, e, d, W, a, l, l, e, ts: Wallet,[] = [] f o r (const file of files) { const private Key = await file.t e x t() const keypair = Keypair.f r o mSecretKey(bs58.d e c ode(privateKey.t r i m())) const encrypted Private Key = await e n c rypt( bs58.e n c ode(keypair.secretKey), password) const n, e, w, W, a, l, l, e, t: Wal let = { n, a, m, e: file.name, p, u, b, l, i, c, K, e, y: keypair.publicKey.t oB a se58(), p, r, i, v, a, t, e, K, e, y: encryptedPrivateKey, g, r, o, u, p: groupName, c, o, l, o, r: '#CCCCCC', i, s, A, c, t, i, v, e: false } await s a v eWalletToDb(newWallet) importedWallets.p ush(newWallet) } return importedWallets
} export async function s a v eWalletToDb(w, a, l, l, e, t: Wallet): Promise < vo id > { const db Instance = await db await dbInstance.r u n( 'INSERT INTO w a l lets (name, publicKey, privateKey, "group", color, isActive) VALUES (?, ?, ?, ?, ?, ?)', [ wallet.name, wallet.publicKey, wallet.privateKey, wallet.group, wallet.color, wallet.isActive, ]) }
