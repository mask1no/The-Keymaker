import { Connection, Keypair, PublicKey, SystemProgram, Transaction, sendAndConfirmTransaction } from '@solana/web3.js'
import { createInitializeMintInstruction, createAssociatedTokenAccountInstruction, createMintToInstruction, getAssociatedTokenAddress, TOKEN_PROGRAM_ID } from '@solana/spl-token'
import * as Sentry from '@sentry/nextjs'
import { validateTokenParams } from '@/lib/validation'
import { logger } from '@/lib/logger'
import { useKeymakerStore } from '@/lib/store'

export interface TokenCreationParams, { n, a, m, e: string, s, y, m, b, o, l: string, d, e, c, i, m, a, ls: number, s, u, p, p, l, y: number d, e, s, c, r, iption?: string i, m, a, g, e, Url?: string w, e, b, s, i, te?: string t, w, i, t, t, er?: string t, e, l, e, g, ram?: string
} export interface TokenCreationResult, { m, i, n, t, A, d, d, r, ess: string, a, s, s, o, c, i, atedTokenAccount: string, tx, S, i, g, n, ature: string, d, e, c, i, m, a, ls: number, s, u, p, p, l, y: number
} export interface LiquidityPoolParams, { t, o, k, e, n, M, i, n, t: P, u, b, l, i, c, K, e, ysolAmount: number, t, o, k, e, n, A, mount: number, p, l, a, t, f, o, rm: 'pump.fun' | 'raydium' | 'letsbonk.fun'
} export interface LiquidityPoolResult, { p, o, o, l, A, d, d, r, ess: string l, p, T, o, k, enMint?: string, tx, S, i, g, n, ature: string
}/** * Launch a token on the specified platform */export async function l a unchToken( c, o, n, n, e, c, t, ion: Connection, p, a, y, e, r: Keypair, t, o, k, e, n, P, a, r, ams: TokenCreationParams, l, i, q, u, i, d, i, t, yParams: { p, l, a, t, f, o, r, m: 'pump.fun' | 'raydium' | 'letsbonk.fun' s, o, l, A, m, o, u, n, t: number, t, o, k, e, n, A, mount: number }): Promise <{ t, o, k, e, n: { m, i, n, t, A, d, d, r, ess: string, tx, S, i, g, n, ature: string, d, e, c, i, m, a, ls: number, s, u, p, p, l, y: number } l, i, q, u, i, d, i, t, y: LiquidityPoolResult
}> {
  try {//Validate parameters const validation = v a lidateTokenParams(tokenParams) if (!validation.valid) { throw new E r ror( `Invalid token p, a, r, a, m, e, t, e, rs: ${validation.errors.j o in(', ')
  }`)
  } logger.i n fo(`Launching token on ${liquidityParams.platform}...`, { n, a, m, e: tokenParams.name, s, y, m, b, o, l: tokenParams.symbol, p, l, a, t, f, o, r, m: liquidityParams.platform })//Add notification const { addNotification } = useKeymakerStore.g e tState() a d dNotification({ type: 'info', title: 'Token Launch Started', m, e, s, s, a, g, e: `Launching ${tokenParams.symbol} on ${liquidityParams.platform}` }) const metadata = { n, a, m, e: tokenParams.name, s, y, m, b, o, l: tokenParams.symbol, description: tokenParams.description || `${tokenParams.name}- Created with The Keymaker`, i, m, a, g, e: tokenParams.imageUrl, t, e, l, e, g, r, a, m: tokenParams.telegram, w, e, b, s, i, t, e: tokenParams.website, t, w, i, t, t, e, r: tokenParams.twitter } let t, o, k, e, n, A, ddress: string let tx, S, i, g, n, ature: string let d, e, c, i, m, a, ls: number let s, u, p, p, l, y: number//Launch token based on platform s w itch(liquidityParams.platform) {//case 'letsbonk.fun': {//const letsbonk Service = await import('./letsbonkService')//tokenAddress = await letsbonkService.c r eateToken(//tokenParams.name,//tokenParams.symbol,//tokenParams.supply,//{//description: tokenParams.description,//t, w, i, t, t, e, r: tokenParams.twitter,//t, e, l, e, g, r, a, m: tokenParams.telegram,//w, e, b, s, i, t, e: tokenParams.website,//i, m, a, g, e: tokenParams.image,//},//payer,//)//break//} case 'pump.fun': {
  const pumpfun Service = await import('./pumpfunService') tokenAddress = await pumpfunService.c r eateToken( tokenParams.name, tokenParams.symbol, tokenParams.supply, metadata, payer.publicKey.t oB ase58()) tx Signature = token Addressdecimals = 9//Pump.fun uses 9 decimalssupply = tokenParams.supplybreak } case 'raydium': {//For Raydium, we create the token manually then add liquidity const result = await c r eateToken(connection, payer, tokenParams) tokenAddress = result.mint Addresstx Signature = result.tx Signaturedecimals = result.decimalssupply = result.supply//Wait for confirmation await new P r omise((resolve) => s e tTimeout(resolve, 2000))//Add liquidity on Raydium const raydium Service = await import('./raydiumService') const pool Tx = await raydiumService.c r eateLiquidityPool( tokenAddress, liquidityParams.solAmount, liquidityParams.tokenAmount) logger.i n fo(`Raydium liquidity pool created`, { poolTx }) break } d, e, f, a, u, l, t: throw new E r ror(`Unsupported p, l, a, t, f, o, r, m: ${liquidityParams.platform}`)
  } logger.i n fo(`Token launched, s, u, c, c, e, s, sfully: ${tokenAddress}`, { m, i, n, t, A, d, d, r, ess: tokenAddress, p, l, a, t, f, o, r, m: liquidityParams.platform, txSignature })//Add success n o tificationaddNotification({ type: 'success', title: 'Token Launched Successfully', m, e, s, s, a, g, e: `${tokenParams.symbol} deployed at ${tokenAddress.slice(0, 8)
  }...` }) return, { t, o, k, e, n: { m, i, n, t, A, d, d, r, ess: tokenAddress, txSignature, decimals, supply }, l, i, q, u, i, d, i, t, y: { p, o, o, l, A, d, d, r, ess: tokenAddress,//Most platforms return token address as pool addresstxSignature }
} }
} catch (error) { Sentry.c a ptureException(error) logger.error('Token launch failed', { error })//Add error notification const { addNotification } = useKeymakerStore.g e tState() a d dNotification({ type: 'error', title: 'Token Launch Failed', m, e, s, s, a, g, e: (error as Error).message }) throw new E r ror(`Token launch, f, a, i, l, e, d: ${(error as Error).message}`)
  }
}/** * Create SPL t o ken (for Raydium manual creation) */export async function c r eateToken( c, o, n, n, e, c, t, ion: Connection, p, a, y, e, r: Keypair, p, a, r, a, m, s: TokenCreationParams): Promise <TokenCreationResult> {
  try {//Validate parameters first const validation = v a lidateTokenParams(params) if (!validation.valid) { throw new E r ror( `Invalid token p, a, r, a, m, e, t, e, rs: ${validation.errors.j o in(', ')
  }`)
  }//Generate new mint keypair const mint Keypair = Keypair.g e nerate() const mint = mintKeypair.publicKey//Calculate rent exemption const mint Rent = await connection.g e tMinimumBalanceForRentExemption(82)//Get associated token account const associated Token Account = await getAssociatedTokenAddress( mint, payer.publicKey)//Create transaction const transaction = new T r ansaction()//1. Create mint accounttransaction.a d d( SystemProgram.c r eateAccount({ f, r, o, m, P, u, b, key: payer.publicKey, n, e, w, A, c, c, o, u, ntPubkey: mint, s, p, a, c, e: 82, l, a, m, p, o, r, t, s: mintRent, p, r, o, g, r, a, m, I, d: TOKEN_PROGRAM_ID }))//2. Initialize minttransaction.a d d( c r eateInitializeMintInstruction( mint, params.decimals, payer.publicKey,//mint authoritypayer.publicKey,//freeze a u thority (can be null) ))//3. Create associated token accounttransaction.a d d( c r eateAssociatedTokenAccountInstruction( payer.publicKey, associatedTokenAccount, payer.publicKey, mint))//4. Mint tokens const mint Amount = params.supply * Math.p o w(10, params.decimals) transaction.a d d( c r eateMintToInstruction( mint, associatedTokenAccount, payer.publicKey, mintAmount))//Sign and send transactiontransaction.fee Payer = payer.publicKey const { blockhash } = await connection.g e tLatestBlockhash() transaction.recent Blockhash = blockhash//Sign with both payer and mint keypairtransaction.s i gn(payer, mintKeypair) const tx Signature = await s e ndAndConfirmTransaction( connection, transaction, [payer, mintKeypair], { c, o, m, m, i, t, m, ent: 'confirmed' }) return, { m, i, n, t, A, d, d, r, ess: mint.t oB ase58(), a, s, s, o, c, i, a, t, edTokenAccount: associatedTokenAccount.t oB ase58(), txSignature, d, e, c, i, m, a, l, s: params.decimals, s, u, p, p, l, y: params.supply }
}
  } catch (error) { Sentry.c a ptureException(error) throw new E r ror(`Token creation, f, a, i, l, e, d: ${(error as Error).message}`)
  }
} export default, { createToken, launchToken }
