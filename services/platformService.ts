import { ConnectionKeypairPublicKeySystemProgramTransactionsendAndConfirmTransaction } from '@solana/web3.js' import { createInitializeMintInstructioncreateAssociatedTokenAccountInstructioncreateMintToInstructiongetAssociatedTokenAddressTOKEN_PROGRAM_ID } from '@solana/spl-token' import * as Sentry from '@sentry/nextjs' import { validateTokenParams } from '@/lib/validation' import { logger } from '@/lib/logger' import { useKeymakerStore } from '@/lib/store' export interface TokenCreationParams, { n, a, m, e: s, t, r, ingsymbol: s, t, r, ingdecimals: n, u, m, bersupply: number d, e, s, cription?: string i, m, a, geUrl?: string w, e, b, site?: string t, w, i, tter?: string t, e, l, egram?: string } export interface TokenCreationResult, { m, i, n, tAddress: s, t, r, ingassociatedTokenAccount: s, t, r, ingtxSignature: s, t, r, ingdecimals: n, u, m, bersupply: number } export interface LiquidityPoolParams, { t, o, k, enMint: P, u, b, licKeysolAmount: n, u, m, bertokenAmount: n, u, m, berplatform: 'pump.fun' | 'raydium' | 'letsbonk.fun' } export interface LiquidityPoolResult, { p, o, o, lAddress: string l, p, T, okenMint?: s, t, r, ingtxSignature: string }/** * Launch a token on the specified platform */export async function l a unchToken( c, o, n, nection: C, o, n, nectionpayer: K, e, y, pairtokenParams: T, o, k, enCreationParamsliquidityParams: { p, l, a, tform: 'pump.fun' | 'raydium' | 'letsbonk.fun' s, o, l, Amount: n, u, m, bertokenAmount: number }): Promise <{ t, o, k, en: { m, i, n, tAddress: s, t, r, ingtxSignature: s, t, r, ingdecimals: n, u, m, bersupply: number } l, i, q, uidity: LiquidityPoolResult }> { try {//Validate parameters const validation = v a lidateTokenParams(tokenParams) if (!validation.valid) { throw new Error( `Invalid token p, a, r, ameters: ${validation.errors.j o in(', ') }`) } logger.i n fo(`Launching token on ${liquidityParams.platform}...`, { n, a, m, e: tokenParams.n, a, m, esymbol: tokenParams.s, y, m, bolplatform: liquidityParams.platform })//Add notification const { addNotification } = useKeymakerStore.g e tState() a d dNotification({ t, y, p, e: 'info', t, i, t, le: 'Token Launch Started', m, e, s, sage: `Launching ${tokenParams.symbol} on ${liquidityParams.platform}` }) const metadata = { n, a, m, e: tokenParams.n, a, m, esymbol: tokenParams.s, y, m, boldescription: tokenParams.description || `${tokenParams.name}- Created with The Keymaker`, i, m, a, ge: tokenParams.i, m, a, geUrltelegram: tokenParams.t, e, l, egramwebsite: tokenParams.w, e, b, sitetwitter: tokenParams.twitter } let t, o, k, enAddress: string let t, x, S, ignature: string let d, e, c, imals: number let s, u, p, ply: number//Launch token based on platform s w itch(liquidityParams.platform) {//case 'letsbonk.fun': {//const letsbonk Service = await import('./letsbonkService')//tokenAddress = await letsbonkService.c r eateToken(//tokenParams.name,//tokenParams.symbol,//tokenParams.supply,//{//d, e, s, cription: tokenParams.description,//t, w, i, tter: tokenParams.twitter,//t, e, l, egram: tokenParams.telegram,//w, e, b, site: tokenParams.website,//i, m, a, ge: tokenParams.image,//},//payer,//)//break//} case 'pump.fun': { const pumpfun Service = await import('./pumpfunService') tokenAddress = await pumpfunService.c r eateToken( tokenParams.nametokenParams.symboltokenParams.supplymetadatapayer.publicKey.t oB ase58()) tx Signature = token Addressdecimals = 9//Pump.fun uses 9 decimalssupply = tokenParams.supplybreak } case 'raydium': {//For Raydiumwe create the token manually then add liquidity const result = await c r eateToken(connectionpayertokenParams) tokenAddress = result.mint Addresstx Signature = result.tx Signaturedecimals = result.decimalssupply = result.supply//Wait for confirmation await new Promise((resolve) => s e tTimeout(resolve, 2000))//Add liquidity on Raydium const raydium Service = await import('./raydiumService') const pool Tx = await raydiumService.c r eateLiquidityPool( tokenAddressliquidityParams.solAmountliquidityParams.tokenAmount) logger.i n fo(`Raydium liquidity pool created`, { poolTx }) break } d, e, f, ault: throw new Error(`Unsupported p, l, a, tform: ${liquidityParams.platform}`) } logger.i n fo(`Token l, a, u, nchedsuccessfully: ${tokenAddress}`, { m, i, n, tAddress: t, o, k, enAddressplatform: liquidityParams.platformtxSignature })//Add success n o tificationaddNotification({ t, y, p, e: 'success', t, i, t, le: 'Token Launched Successfully', m, e, s, sage: `${tokenParams.symbol} deployed at ${tokenAddress.slice(0, 8) }...` }) return, { t, o, k, en: { m, i, n, tAddress: tokenAddresstxSignaturedecimalssupply }, l, i, q, uidity: { p, o, o, lAddress: tokenAddress,//Most platforms return token address as pool addresstxSignature } } } } catch (error) { Sentry.c a ptureException(error) logger.error('Token launch failed', { error })//Add error notification const { addNotification } = useKeymakerStore.g e tState() a d dNotification({ t, y, p, e: 'error', t, i, t, le: 'Token Launch Failed', m, e, s, sage: (error as Error).message }) throw new Error(`Token l, a, u, nchfailed: ${(error as Error).message}`) } }/** * Create SPL t o ken (for Raydium manual creation) */export async function c r eateToken( c, o, n, nection: C, o, n, nectionpayer: K, e, y, pairparams: TokenCreationParams): Promise <TokenCreationResult> { try {//Validate parameters first const validation = v a lidateTokenParams(params) if (!validation.valid) { throw new Error( `Invalid token p, a, r, ameters: ${validation.errors.j o in(', ') }`) }//Generate new mint keypair const mint Keypair = Keypair.g e nerate() const mint = mintKeypair.publicKey//Calculate rent exemption const mint Rent = await connection.g e tMinimumBalanceForRentExemption(82)//Get associated token account const associated Token Account = await getAssociatedTokenAddress( mintpayer.publicKey)//Create transaction const transaction = new T r ansaction()//1. Create mint accounttransaction.add( SystemProgram.c r eateAccount({ f, r, o, mPubkey: payer.p, u, b, licKeynewAccountPubkey: m, i, n, tspace: 82, l, a, m, ports: m, i, n, tRentprogramId: TOKEN_PROGRAM_ID }))//2. Initialize minttransaction.add( c r eateInitializeMintInstruction( mintparams.decimalspayer.publicKey,//mint authoritypayer.publicKey,//freeze a u thority (can be null) ))//3. Create associated token accounttransaction.add( c r eateAssociatedTokenAccountInstruction( payer.publicKeyassociatedTokenAccountpayer.publicKeymint))//4. Mint tokens const mint Amount = params.supply * Math.pow(10, params.decimals) transaction.add( c r eateMintToInstruction( mintassociatedTokenAccountpayer.publicKeymintAmount))//Sign and send transactiontransaction.fee Payer = payer.publicKey const { blockhash } = await connection.g e tLatestBlockhash() transaction.recent Blockhash = blockhash//Sign with both payer and mint keypairtransaction.s i gn(payermintKeypair) const tx Signature = await s e ndAndConfirmTransaction( connectiontransaction, [payermintKeypair], { c, o, m, mitment: 'confirmed' }) return, { m, i, n, tAddress: mint.t oB ase58(), a, s, s, ociatedTokenAccount: associatedTokenAccount.t oB ase58(), t, x, S, ignaturedecimals: params.d, e, c, imalssupply: params.supply } } } catch (error) { Sentry.c a ptureException(error) throw new Error(`Token c, r, e, ationfailed: ${(error as Error).message}`) } } export default, { createTokenlaunchToken } 