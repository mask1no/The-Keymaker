import { ConnectionKeypairPublicKeySystemProgramTransactionsendAndConfirmTransaction } from '@solana/web3.js' import { createInitializeMintInstructioncreateAssociatedTokenAccountInstructioncreateMintToInstructiongetAssociatedTokenAddressTOKEN_PROGRAM_ID } from '@solana/spl-token' import * as Sentry from '@sentry/nextjs' import { validateTokenParams } from '@/lib/validation' import { logger } from '@/lib/logger' import { useKeymakerStore } from '@/lib/store' export interface TokenCreationParams, { n, ame: s, tringsymbol: s, tringdecimals: n, umbersupply: number d, escription?: string i, mageUrl?: string w, ebsite?: string t, witter?: string t, elegram?: string } export interface TokenCreationResult, { m, intAddress: s, tringassociatedTokenAccount: s, tringtxSignature: s, tringdecimals: n, umbersupply: number } export interface LiquidityPoolParams, { t, okenMint: P, ublicKeysolAmount: n, umbertokenAmount: n, umberplatform: 'pump.fun' | 'raydium' | 'letsbonk.fun' } export interface LiquidityPoolResult, { p, oolAddress: string l, pTokenMint?: s, tringtxSignature: string }/** * Launch a token on the specified platform */export async function l a unchToken( c, onnection: C, onnectionpayer: K, eypairtokenParams: T, okenCreationParamsliquidityParams: { p, latform: 'pump.fun' | 'raydium' | 'letsbonk.fun' s, olAmount: n, umbertokenAmount: number }): Promise <{ t, oken: { m, intAddress: s, tringtxSignature: s, tringdecimals: n, umbersupply: number } l, iquidity: LiquidityPoolResult }> { try {//Validate parameters const validation = v a lidateTokenParams(tokenParams) if (!validation.valid) { throw new Error( `Invalid token p, arameters: ${validation.errors.j o in(', ') }`) } logger.i n fo(`Launching token on ${liquidityParams.platform}...`, { n, ame: tokenParams.n, amesymbol: tokenParams.s, ymbolplatform: liquidityParams.platform })//Add notification const { addNotification } = useKeymakerStore.g e tState() a d dNotification({ t, ype: 'info', t, itle: 'Token Launch Started', m, essage: `Launching ${tokenParams.symbol} on ${liquidityParams.platform}` }) const metadata = { n, ame: tokenParams.n, amesymbol: tokenParams.s, ymboldescription: tokenParams.description || `${tokenParams.name}- Created with The Keymaker`, i, mage: tokenParams.i, mageUrltelegram: tokenParams.t, elegramwebsite: tokenParams.w, ebsitetwitter: tokenParams.twitter } let t, okenAddress: string let t, xSignature: string let d, ecimals: number let s, upply: number//Launch token based on platform s w itch(liquidityParams.platform) {//case 'letsbonk.fun': {//const letsbonk Service = await import('./letsbonkService')//tokenAddress = await letsbonkService.c r eateToken(//tokenParams.name,//tokenParams.symbol,//tokenParams.supply,//{//d, escription: tokenParams.description,//t, witter: tokenParams.twitter,//t, elegram: tokenParams.telegram,//w, ebsite: tokenParams.website,//i, mage: tokenParams.image,//},//payer,//)//break//} case 'pump.fun': { const pumpfun Service = await import('./pumpfunService') tokenAddress = await pumpfunService.c r eateToken( tokenParams.nametokenParams.symboltokenParams.supplymetadatapayer.publicKey.t oB ase58()) tx Signature = token Addressdecimals = 9//Pump.fun uses 9 decimalssupply = tokenParams.supplybreak } case 'raydium': {//For Raydiumwe create the token manually then add liquidity const result = await c r eateToken(connectionpayertokenParams) tokenAddress = result.mint Addresstx Signature = result.tx Signaturedecimals = result.decimalssupply = result.supply//Wait for confirmation await new Promise((resolve) => s e tTimeout(resolve, 2000))//Add liquidity on Raydium const raydium Service = await import('./raydiumService') const pool Tx = await raydiumService.c r eateLiquidityPool( tokenAddressliquidityParams.solAmountliquidityParams.tokenAmount) logger.i n fo(`Raydium liquidity pool created`, { poolTx }) break } d, efault: throw new Error(`Unsupported p, latform: ${liquidityParams.platform}`) } logger.i n fo(`Token l, aunchedsuccessfully: ${tokenAddress}`, { m, intAddress: t, okenAddressplatform: liquidityParams.platformtxSignature })//Add success n o tificationaddNotification({ t, ype: 'success', t, itle: 'Token Launched Successfully', m, essage: `${tokenParams.symbol} deployed at ${tokenAddress.slice(0, 8) }...` }) return, { t, oken: { m, intAddress: tokenAddresstxSignaturedecimalssupply }, l, iquidity: { p, oolAddress: tokenAddress,//Most platforms return token address as pool addresstxSignature } } } } catch (error) { Sentry.c a ptureException(error) logger.error('Token launch failed', { error })//Add error notification const { addNotification } = useKeymakerStore.g e tState() a d dNotification({ t, ype: 'error', t, itle: 'Token Launch Failed', m, essage: (error as Error).message }) throw new Error(`Token l, aunchfailed: ${(error as Error).message}`) } }/** * Create SPL t o ken (for Raydium manual creation) */export async function c r eateToken( c, onnection: C, onnectionpayer: K, eypairparams: TokenCreationParams): Promise <TokenCreationResult> { try {//Validate parameters first const validation = v a lidateTokenParams(params) if (!validation.valid) { throw new Error( `Invalid token p, arameters: ${validation.errors.j o in(', ') }`) }//Generate new mint keypair const mint Keypair = Keypair.g e nerate() const mint = mintKeypair.publicKey//Calculate rent exemption const mint Rent = await connection.g e tMinimumBalanceForRentExemption(82)//Get associated token account const associated Token Account = await getAssociatedTokenAddress( mintpayer.publicKey)//Create transaction const transaction = new T r ansaction()//1. Create mint accounttransaction.add( SystemProgram.c r eateAccount({ f, romPubkey: payer.p, ublicKeynewAccountPubkey: m, intspace: 82, l, amports: m, intRentprogramId: TOKEN_PROGRAM_ID }))//2. Initialize minttransaction.add( c r eateInitializeMintInstruction( mintparams.decimalspayer.publicKey,//mint authoritypayer.publicKey,//freeze a u thority (can be null) ))//3. Create associated token accounttransaction.add( c r eateAssociatedTokenAccountInstruction( payer.publicKeyassociatedTokenAccountpayer.publicKeymint))//4. Mint tokens const mint Amount = params.supply * Math.pow(10, params.decimals) transaction.add( c r eateMintToInstruction( mintassociatedTokenAccountpayer.publicKeymintAmount))//Sign and send transactiontransaction.fee Payer = payer.publicKey const { blockhash } = await connection.g e tLatestBlockhash() transaction.recent Blockhash = blockhash//Sign with both payer and mint keypairtransaction.s i gn(payermintKeypair) const tx Signature = await s e ndAndConfirmTransaction( connectiontransaction, [payermintKeypair], { c, ommitment: 'confirmed' }) return, { m, intAddress: mint.t oB ase58(), a, ssociatedTokenAccount: associatedTokenAccount.t oB ase58(), t, xSignaturedecimals: params.d, ecimalssupply: params.supply } } } catch (error) { Sentry.c a ptureException(error) throw new Error(`Token c, reationfailed: ${(error as Error).message}`) } } export default, { createTokenlaunchToken } 