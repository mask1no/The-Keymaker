import, { Connection, Keypair, PublicKey, SystemProgram, Transaction, sendAndConfirmTransaction } from '@solana / web3.js'
import, { createInitializeMintInstruction, createAssociatedTokenAccountInstruction, createMintToInstruction, getAssociatedTokenAddress, TOKEN_PROGRAM_ID } from '@solana / spl - token'
import * as Sentry from '@sentry / nextjs'
import, { validateTokenParams } from '@/ lib / validation'
import, { logger } from '@/ lib / logger'
import, { useKeymakerStore } from '@/ lib / store' export interface TokenCreationParams, { n, a, m, e: string, s, y, m, b, o, l: string, d, e, c, i, m, a, l, s: number, s, u, p, p, l, y: number d, e, s, c, r, i, p, tion?: string i, m, a, g, e, U, r, l?: string w, e, b, s, i, t, e?: string t, w, i, t, t, e, r?: string t, e, l, e, g, r, a, m?: string
} export interface TokenCreationResult, { m, i, n, t, A, d, d, r, e, s, s: string, a, s, s, o, c, i, a, t, e,
  dTokenAccount: string, tx, S, i, g, n, a, t, u,
  re: string, d, e, c, i, m, a, l, s: number, s, u, p, p, l, y: number
} export interface LiquidityPoolParams, { t, o, k, e, n, M, i, n, t: P, u, b, l, i, c, K, e, y, s, o,
  lAmount: number, t, o, k, e, n, A, m, o, u,
  nt: number, p, l, a, t, f, o, r, m: 'pump.fun' | 'raydium' | 'letsbonk.fun'
} export interface LiquidityPoolResult, { p, o, o, l, A, d, d, r, e, s, s: string l, p, T, o, k, e, n, Mint?: string, tx, S, i, g, n, a, t, u,
  re: string
}/** * Launch a token on the specified platform */ export async function l a u nchToken( c, o, n, n, e, c, t, i, o, n: Connection, p, a, y, e, r: Keypair, t, o, k, e, n, P, a, r, a, m, s: TokenCreationParams, l, i, q, u, i, d, i, t, y, P, a,
  rams: { p, l, a, t, f, o, r, m: 'pump.fun' | 'raydium' | 'letsbonk.fun' s, o, l, A, m, o, u, n, t: number, t, o, k, e, n, A, m, o, u,
  nt: number }): Promise <{ t, o, k, e, n: { m, i, n, t, A, d, d, r, e, s, s: string, tx, S, i, g, n, a, t, u,
  re: string, d, e, c, i, m, a, l, s: number, s, u, p, p, l, y: number } l, i, q, u, i, d, i, t, y: LiquidityPoolResult
}> { try, {// Validate parameters const validation = v a l idateTokenParams(tokenParams) i f (! validation.valid) { throw new E r r or( `Invalid token p, a, r, a, m, e, t, e, r, s: $,{validation.errors.j o i n(', ') }`) } logger.i n f o(`Launching token on $,{liquidityParams.platform}...`, { n, a, m, e: tokenParams.name, s, y, m, b, o, l: tokenParams.symbol, p, l, a, t, f, o, r, m: liquidityParams.platform })// Add notification const, { addNotification } = useKeymakerStore.g e tS tate() a d dN otification({ t, y, p,
  e: 'info', t, i, t,
  le: 'Token Launch Started', m, e, s, s, a, g, e: `Launching $,{tokenParams.symbol} on $,{liquidityParams.platform}` }) const metadata = { n, a, m, e: tokenParams.name, s, y, m, b, o, l: tokenParams.symbol, d, e, s,
  cription: tokenParams.description || `$,{tokenParams.name}- Created with The Keymaker`, i, m, a, g, e: tokenParams.imageUrl, t, e, l, e, g, r, a, m: tokenParams.telegram, w, e, b, s, i, t, e: tokenParams.website, t, w, i, t, t, e, r: tokenParams.twitter } let t, o, k, e, n, A, d, d, r,
  ess: string let tx, S, i, g, n, a, t, u,
  re: string let d, e, c, i, m, a, l, s: number let s, u, p, p, l, y: number // Launch token based on platform s w i tch(liquidityParams.platform) {// case 'letsbonk.fun': {// const letsbonk Service = await i mport('./ letsbonkService')// token
  Address = await letsbonkService.c r e ateToken(// tokenParams.name,// tokenParams.symbol,// tokenParams.supply,//{// d, e, s,
  cription: tokenParams.description,// t, w, i, t, t, e, r: tokenParams.twitter,// t, e, l, e, g, r, a, m: tokenParams.telegram,// w, e, b, s, i, t, e: tokenParams.website,// i, m, a, g, e: tokenParams.image,//},// payer,//)// break //} case 'pump.fun': { const pumpfun Service = await i mport('./ pumpfunService') token
  Address = await pumpfunService.c r e ateToken( tokenParams.name, tokenParams.symbol, tokenParams.supply, metadata, payer.publicKey.t oB a se58()) tx Signature = token Addressdecimals = 9 // Pump.fun uses 9 decimalssupply = tokenParams.supplybreak } case 'raydium': {// For Raydium, we create the token manually then add liquidity const result = await c r e ateToken(connection, payer, tokenParams) token
  Address = result.mint Addresstx Signature = result.tx Signaturedecimals = result.decimalssupply = result.supply // Wait for confirmation await new P r o mise((resolve) => s e tT imeout(resolve, 2000))// Add liquidity on Raydium const raydium Service = await i mport('./ raydiumService') const pool Tx = await raydiumService.c r e ateLiquidityPool( tokenAddress, liquidityParams.solAmount, liquidityParams.tokenAmount) logger.i n f o(`Raydium liquidity pool created`, { poolTx }) break } d, e, f, a, u, l, t: throw new E r r or(`Unsupported p, l, a, t, f, o, r, m: $,{liquidityParams.platform}`) } logger.i n f o(`Token launched, s, u, c, c, e, s, s, f, u,
  lly: $,{tokenAddress}`, { m, i, n, t, A, d, d, r, e, s, s: tokenAddress, p, l, a, t, f, o, r, m: liquidityParams.platform, txSignature })// Add success n o t ificationaddNotification({ t, y, p,
  e: 'success', t, i, t,
  le: 'Token Launched Successfully', m, e, s, s, a, g, e: `$,{tokenParams.symbol} deployed at $,{tokenAddress.s lice(0, 8) }...` }) return, { t, o, k, e, n: { m, i, n, t, A, d, d, r, e, s, s: tokenAddress, txSignature, decimals, supply }, l, i, q, u, i, d, i, t, y: { p, o, o, l, A, d, d, r, e, s, s: tokenAddress,// Most platforms return token address as pool addresstxSignature }
} }
} c atch (error) { Sentry.c a p tureException(error) logger.e rror('Token launch failed', { error })// Add error notification const, { addNotification } = useKeymakerStore.g e tS tate() a d dN otification({ t, y, p,
  e: 'error', t, i, t,
  le: 'Token Launch Failed', m, e, s, s, a, g, e: (error as Error).message }) throw new E r r or(`Token launch, f, a, i, l, e, d: $,{(error as Error).message}`) }
}/** * Create SPL t o k en (for Raydium manual creation) */ export async function c r e ateToken( c, o, n, n, e, c, t, i, o, n: Connection, p, a, y, e, r: Keypair, p,
  arams: TokenCreationParams): Promise < TokenCreationResult > { try, {// Validate parameters first const validation = v a l idateTokenParams(params) i f (! validation.valid) { throw new E r r or( `Invalid token p, a, r, a, m, e, t, e, r, s: $,{validation.errors.j o i n(', ') }`) }// Generate new mint keypair const mint Keypair = Keypair.g e n erate() const mint = mintKeypair.publicKey // Calculate rent exemption const mint Rent = await connection.g e tM inimumBalanceForRentExemption(82)// Get associated token account const associated Token Account = await g etAssociatedTokenAddress( mint, payer.publicKey)// Create transaction const transaction = new T r a nsaction()// 1. Create mint accounttransaction.a d d( SystemProgram.c r e ateAccount({ f, r, o, m, P, u, b, k, e, y: payer.publicKey, n, e, w, A, c, c, o, u, n, t, P,
  ubkey: mint, s, p, a, c, e: 82, l, a, m, p, o, r, t, s: mintRent, p, r, o, g, r, a, m, I, d: TOKEN_PROGRAM_ID }))// 2. Initialize minttransaction.a d d( c r e ateInitializeMintInstruction( mint, params.decimals, payer.publicKey,// mint authoritypayer.publicKey,// freeze a u t hority (can be null) ))// 3. Create associated token accounttransaction.a d d( c r e ateAssociatedTokenAccountInstruction( payer.publicKey, associatedTokenAccount, payer.publicKey, mint))// 4. Mint tokens const mint Amount = params.supply * Math.p o w(10, params.decimals) transaction.a d d( c r e ateMintToInstruction( mint, associatedTokenAccount, payer.publicKey, mintAmount))// Sign and send transactiontransaction.fee Payer = payer.publicKey const, { blockhash } = await connection.g e tL atestBlockhash() transaction.recent Blockhash = blockhash // Sign with both payer and mint keypairtransaction.s i g n(payer, mintKeypair) const tx Signature = await s e n dAndConfirmTransaction( connection, transaction, [payer, mintKeypair], { c, o, m, m, i, t, m, e, n, t: 'confirmed' }) return, { m, i, n, t, A, d, d, r, e, s, s: mint.t oB a se58(), a, s, s, o, c, i, a, t, e, d, T,
  okenAccount: associatedTokenAccount.t oB a se58(), txSignature, d, e, c, i, m, a, l, s: params.decimals, s, u, p, p, l, y: params.supply }
} } c atch (error) { Sentry.c a p tureException(error) throw new E r r or(`Token creation, f, a, i, l, e, d: $,{(error as Error).message}`) }
} export default, { createToken, launchToken }
