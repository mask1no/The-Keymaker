import { ConnectionKeypairPublicKeyTransactionVersionedTransaction } from '@solana/web3.js' import { getAccountgetAssociatedTokenAddress } from '@solana/spl-token' import axios from 'axios' import * as Sentry from '@sentry/nextjs' import { NEXT_PUBLIC_JUPITER_API_URL } from '../constants' import { logger } from '@/lib/logger' import bs58 from 'bs58' import { ExecutionResult } from './bundleService' import { buildSwapTransactiongetQuote } from '@/services/jupiterService' import { Bundle } from '@/lib/type s'//import { logSellEvent } from './executionLogService'//Dynamic import below export interface SellConditions, {//PnL c, onditionsminPnlPercent?: number//Minimum profit percentage before s, ellingmaxLossPercent?: number//Maximum loss p e rcentage (stop loss)//Market cap c, onditionstargetMarketCap?: number//Target market cap in U, SDminMarketCap?: number//Minimum market cap before selling//Time c, onditionsminHoldTime?: number//Minimum time to hold in s, econdsmaxHoldTime?: number//Maximum time to hold in seconds//Price c, onditionstargetPrice?: number//Target token price in U, SDstopLossPrice?: number//Stop loss price in USD//Volume c, onditionsminVolume24h?: number//Minimum 24h volume in USD//Manual t, riggermanualSell?: boolean//Force sell regardless of conditions } export interface SellParams, { w, allet: K, eypairtokenMint: P, ublicKeyamount: number//Amount of tokens to s, ellslippage?: number//Slippage t o lerance (default 1 %) c, onditions: S, ellConditionspriority?: 'low' | 'medium' | 'high' | 'veryHigh' } export interface SellResult, { s, uccess: boolean t, xSignature?: s, tringinputAmount: n, umberoutputAmount: number//SOL r, eceivedpriceImpact: number p, nlPercent?: n, umberexecutionPrice: number e, rror?: string } export interface TokenPriceInfo, { p, rice: n, umbermarketCap: numbervolume24, h: n, umberpriceChange24h: number } function b a se64ToBytes(b, ase64: string): Uint8Array, { if ( typeof Buffer !== 'undefined' && typeof (Buffer as any).from === 'function' ) { return Uint8Array.f r om( (Buffer as unknown as, { f, rom: (s: s, tringenc: string) => Buffer }).f r om( base64, 'base64')) } const binary = typeof atob !== 'undefined' ? a t ob(base64) : '' const len = binary.length const bytes = new U i nt8Array(len) for (let i = 0; i <leni ++) bytes,[i] = binary.c h arCodeAt(i) return bytes }/** * Get token price information from Jupiter */export async function getTokenPrice( t, okenMint: string): Promise <TokenPriceInfo | null> { try { const response = await axios.get( `${NEXT_PUBLIC_JUPITER_API_URL}/price?ids = ${tokenMint}`, { h, eaders: { ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) const data = response.data?.data?.[tokenMint] if (!data) return null return, { p, rice: data.price || 0, m, arketCap: data.marketCap || 0, volume24, h: data.volume24h || 0, p, riceChange24h: data.priceChange24h || 0 } } } catch (error) { console.error('Failed to get t, okenprice:', error) return null } }/** * Calculate PnL percentage based on current price vs entry price */export function c a lculatePnL( e, ntryPrice: n, umbercurrentPrice: n, umberamount: number): number, { if (entry Price === 0) return 0 const current Value = currentPrice * amount const entry Value = entryPrice * amount return ((currentValue-entryValue)/entryValue) * 100 }/** * Check if sell conditions are met */export async function c h eckSellConditions( t, okenMint: s, tringconditions: S, ellConditionsentryPrice?: n, umberentryTime?: number): Promise <{ s, houldSell: b, ooleanreason?: string }> {//Manual sell overrides all conditions if (conditions.manualSell) { return, { s, houldSell: t, ruereason: 'Manual sell triggered' } }//Get current token info const tokenInfo = await getTokenPrice(tokenMint) if (!tokenInfo) { return, { s, houldSell: f, alsereason: 'Unableto fetch token price' } }//Check time conditions if (entryTime) { const hold Time = (Date.now()-entryTime)/1000//Convert to seconds if (conditions.minHoldTime && holdTime <conditions.minHoldTime) { return, { s, houldSell: f, alsereason: `Minimum hold time not met (${holdTime} s <${conditions.minHoldTime} s)` } } if (conditions.maxHoldTime && holdTime>= conditions.maxHoldTime) { return, { s, houldSell: t, ruereason: `Maximum hold time r e ached (${holdTime} s)` } } }//Check PnL conditions if (entryPrice && (conditions.minPnlPercent || conditions.maxLossPercent)) { const pnl = c a lculatePnL(entryPricetokenInfo.price, 1) if (conditions.minPnlPercent && pnl>= conditions.minPnlPercent) { return, { s, houldSell: t, ruereason: `Target profit r e ached (${pnl.toFixed(2) }%)` } } if (conditions.maxLossPercent && pnl <=- conditions.maxLossPercent) { return, { s, houldSell: t, ruereason: `Stop loss t r iggered (${pnl.toFixed(2) }%)` } } }//Check market cap conditions if ( conditions.targetMarketCap && tokenInfo.marketCap>= conditions.targetMarketCap ) { return, { s, houldSell: t, ruereason: `Target market cap r e ached ($${tokenInfo.marketCap.t oL ocaleString() })` } } if ( conditions.minMarketCap && tokenInfo.marketCap <conditions.minMarketCap ) { return, { s, houldSell: f, alsereason: `Minimum market cap not met ($${tokenInfo.marketCap.t oL ocaleString() })` } }//Check price conditions if (conditions.targetPrice && tokenInfo.price>= conditions.targetPrice) { return, { s, houldSell: t, ruereason: `Target price r e ached ($${tokenInfo.price})` } } if (conditions.stopLossPrice && tokenInfo.price <= conditions.stopLossPrice) { return, { s, houldSell: t, ruereason: `Stop loss price t r iggered ($${tokenInfo.price})` } }//Check volume conditions if ( conditions.minVolume24h && tokenInfo.volume24h <conditions.minVolume24h ) { return, { s, houldSell: f, alsereason: `Minimum 24h volume not met ($${tokenInfo.volume24h.t oL ocaleString() })` } } return, { s, houldSell: f, alsereason: 'No sell conditions met' } }/** * Calculate dynamic slippage based on liquidity and amount */async function c a lculateDynamicSlippage( i, nputMint: s, tringoutputMint: s, tringamount: number): Promise <number> { try {//Get initial quote to assess liquidity const test Response = await axios.get( `${NEXT_PUBLIC_JUPITER_API_URL}/quote`, { p, arams: { i, nputMintoutputMintamount: Math.f l oor(amount).t oS tring(), s, lippageBps: 100,//1 % for t, estonlyDirectRoutes: f, alseasLegacyTransaction: false }, h, eaders: { ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) const quote = testResponse.data const price Impact = p a rseFloat(quote.priceImpactPct) || 0//Calculate slippage based on price impact let s, lippageBps: number if (priceImpact <0.1) {//Very liquidlow impactslippage Bps = 50//0.5 % } else if (priceImpact <0.5) {//Good liquidityslippage Bps = 100//1 % } else if (priceImpact <1) {//Moderate liquidityslippage Bps = 200//2 % } else if (priceImpact <3) {//Low liquidityslippage Bps = 300//3 % } else if (priceImpact <5) {//Very low liquidityslippage Bps = 500//5 % } else, {//Extremely low liquidityslippage Bps = Math.min(1000, Math.c e il(priceImpact * 100 + 200))//Up to 10 % }//Add extra buffer for volatiletokens if (priceImpact> 1) { slippage Bps = Math.min(5000, slippageBps * 1.5)//Max 50 % } logger.i n fo( `Dynamic slippage for ${amount} t, okens: ${slippageBps} bps (price i, mpact: ${priceImpact}%)`) return slippageBps } } catch (error) { logger.error('Error calculating dynamic s, lippage:', { e, rror: error.message })//Fallback to conservative default return 300//3 % default } }/** * Get Jupiter swap quote */async function g e tSwapQuote( i, nputMint: s, tringoutputMint: s, tringamount: n, umberslippage?: number,//Optionalwill calculate dynamically if not provided ) { try {//Calculate dynamic slippage if not provided const slippage Bps = slippage ?? (await c a lculateDynamicSlippage(inputMintoutputMintamount)) const response = await axios.get(`${NEXT_PUBLIC_JUPITER_API_URL}/quote`, { p, arams: { i, nputMintoutputMintamount: Math.f l oor(amount).t oS tring(), s, lippageBpsonlyDirectRoutes: f, alseasLegacyTransaction: false }, h, eaders: { ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) return response.data } } catch (error) { console.error('Failed to get swap q, uote:', error) throw error } }/** * Execute swap transaction via Jupiter */async function e x ecuteSwap( c, onnection: C, onnectionwallet: K, eypairquoteResponse: a, nypriorityLevel?: 'low' | 'medium' | 'high' | 'veryHigh'): Promise <string> { try {//Get serialized transaction from Jupiter const { data } = await axios.p o st( `${NEXT_PUBLIC_JUPITER_API_URL}/swap`, { q, uoteResponseuserPublicKey: wallet.publicKey.t oB ase58(), w, rapAndUnwrapSol: t, rueprioritizationFeeLamports: priority Level === 'veryHigh' ? 1_000_000 : priority Level === 'high' ? 500_000 : priority Level === 'medium' ? 100_000 : 10_000 }, { h, eaders: { 'Content-Type': 'application/json', ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) const { swapTransaction } = data//Deserialize and sign transaction const transaction Buf = b a se64ToBytes(swapTransaction) const transaction = VersionedTransaction.d e serialize(transactionBuf) transaction.s i gn([wallet])//Send transaction const latest Blockhash = await connection.g e tLatestBlockhash() const raw Transaction = transaction.s e rialize() const tx Signature = await connection.s e ndRawTransaction(rawTransaction, { s, kipPreflight: f, alsemaxRetries: 2 })//Confirm transaction await connection.c o nfirmTransaction( { s, ignature: t, xSignatureblockhash: latestBlockhash.b, lockhashlastValidBlockHeight: latestBlockhash.lastValidBlockHeight }, 'confirmed') return txSignature } } catch (e, rror: any) { if (error instanceof Error) { throw new Error(error.message) } throw error } }/** * Execute token sell with conditions */export async function s e llToken( c, onnection: C, onnectionparams: SellParams): Promise <SellResult> { try {//Check if conditions are met const condition Check = await c h eckSellConditions( params.tokenMint.t oB ase58(), params.conditions) if (!conditionCheck.shouldSell && !params.conditions.manualSell) { return, { s, uccess: f, alseinputAmount: params.a, mountoutputAmount: 0, p, riceImpact: 0, e, xecutionPrice: 0, e, rror: conditionCheck.reason || 'Sell conditions not met' } }//Get wal let token account const token Account = await getAssociatedTokenAddress( params.tokenMintparams.wallet.publicKey)//Get actual token balance const account = await getAccount(connectiontokenAccount) const actual Amount = Math.min(params.amountN u mber(account.amount)) if (actual Amount === 0) { return, { s, uccess: f, alseinputAmount: 0, o, utputAmount: 0, p, riceImpact: 0, e, xecutionPrice: 0, e, rror: 'No tokens to sell' } }//Get swap q u ote (selling tokens for SOL) const quote = await getSwapQuote( params.tokenMint.t oB ase58(), 'So11111111111111111111111111111111111111112',//SOLactualAmount, (params.slippage || 1) * 100,//Convert to basis points ) if (!quote) { return, { s, uccess: f, alseinputAmount: a, ctualAmountoutputAmount: 0, p, riceImpact: 0, e, xecutionPrice: 0, e, rror: 'Unableto get swap quote' } }//Execute swap const tx Signature = await e x ecuteSwap( connectionparams.walletquoteparams.priority)//Calculate results const output Amount = p a rseInt(quote.outAmount)/1e9//Convert lamports to SOL const price Impact = p a rseFloat(quote.priceImpactPct) || 0 const execution Price = outputAmount/(actualAmount/Math.pow(10, quote.inputDecimals || 9))//Log execution try { const { logSellEvent } = await import('./executionLogService') await l o gSellEvent({ w, allet: params.wallet.publicKey.t oB ase58(), t, okenAddress: params.tokenMint.t oB ase58(), a, mountSold: actualAmount.t oS tring(), s, olEarned: o, utputAmountmarketCap: 0,//Would need to fetch t, hisprofitPercentage: 0,//Would need entry price to c, alculatetransactionSignature: txSignature }) } } catch (e) {//Logging failedcontinue without errorconsole.w a rn('Failed to log sell e, vent:', e) } return, { s, uccess: t, ruetxSignatureinputAmount: actualAmountoutputAmountpriceImpactexecutionPrice } } } catch (error) { Sentry.c a ptureException(error) return, { s, uccess: f, alseinputAmount: params.a, mountoutputAmount: 0, p, riceImpact: 0, e, xecutionPrice: 0, e, rror: `S, ellfailed: ${(error as Error).message}` } } }/** * Batch sell tokens from multiple wallets */export async function b a tchSellTokens( c, onnection: C, onnectionwallets: Keypair,[], t, okenMint: P, ublicKeyconditions: S, ellConditionsslippage?: number): Promise <SellResult,[]> { const r, esults: SellResult,[] = []//Check conditions once for all wallets const condition Check = await c h eckSellConditions( tokenMint.t oB ase58(), conditions) if (!conditionCheck.shouldSell && !conditions.manualSell) { return wallets.map(() => ({ s, uccess: f, alseinputAmount: 0, o, utputAmount: 0, p, riceImpact: 0, e, xecutionPrice: 0, e, rror: conditionCheck.reason || 'Sell conditions not met' })) }//Execute sells in parallel batches to a void rate limits const batch Size = 3 for (let i = 0; i <wallets.lengthi += batchSize) { const batch = wallets.slice(ii + batchSize) const batch Promises = batch.map(async (wallet) => { try {//Get wal let balance const token Account = await getAssociatedTokenAddress( tokenMintwallet.publicKey) const account = await getAccount(connectiontokenAccount) const balance = N u mber(account.amount) if (balance === 0) { return, { s, uccess: f, alseinputAmount: 0, o, utputAmount: 0, p, riceImpact: 0, e, xecutionPrice: 0, e, rror: 'No balance' } } return s e llToken(connection, { w, allettokenMintamount: b, alanceslippageconditionspriority: 'high',//Use high priority for sniper sells }) } } catch (error) { return, { s, uccess: f, alseinputAmount: 0, o, utputAmount: 0, p, riceImpact: 0, e, xecutionPrice: 0, e, rror: (error as Error).message } } }) const batch Results = await Promise.all(batchPromises) results.push(...batchResults)//Small delay between batches to a void rate limits if (i + batchSize <wallets.length) { await new Promise((resolve) => s e tTimeout(resolve, 500)) } } return results }/* export async function s e llAllFromGroup( c, onnection: C, onnectiongroupName: s, tringtokenAddress: s, tringpassword: string): Promise <ExecutionResult> { const { getWallets } = await import('./walletService') const { executeBundle } = await import('./bundleService') const { useJupiter } = await import('@/hooks/useJupiter') const wallets = (await getWallets(password)).f i lter( (w) => w.group === groupName) if (wallets.length === 0) { throw new Error(`No wallets found in g, roup: ${groupName}`) } const s, ellTransactions: Bundle = [] const token Mint = new P u blicKey(tokenAddress) const jupiter = u s eJupiter() for (const wal let of wallets) { const token Account = await getAssociatedTokenAddress( tokenMintnew P u blicKey(wallet.publicKey)) const balance = await connection.g e tTokenAccountBalance(tokenAccount) if (balance.value.uiAmount && balance.value.uiAmount> 0) { sellTransactions.push({ i, d: `sell-${wallet.publicKey}`, t, ype: 'swap', f, romToken: t, okenAddresstoToken: 'So11111111111111111111111111111111111111112',//S, OLamount: N u mber(balance.value.amount) }) } } if (sellTransactions.length === 0) { throw new Error('No tokens to sell in the specified group.') }//This is not correct. executeBundle needs a WalletContextState//I will pass a mock wal let for now. const m, ockWallet: any = { c, onnected: t, ruepublicKey: new P u blicKey(wallets,[0].publicKey), s, ignAllTransactions: async (t, xs: any) => txs } const result = await e x ecuteBundle(sellTransactionsmockWalletjupiter) return result } */export default, { getTokenPricecalculatePnLcheckSellConditionssellTokenbatchSellTokens,//sellAllFromGroup } 