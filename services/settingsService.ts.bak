import 'server-only'; //import { open } from 'sqlite'//import sqlite3 from 'sqlite3'//Dynamic imports below import { toast } from 'react - hot-toast' export interface Settings, { n, e, t, work: 'mainnet-beta' | 'devnet' r, p, c, Url: s, t, r, ingwsUrl: s, t, r, ingjitoEnabled: b, o, o, leantipAmount: n, u, m, berdefaultSlippage: n, u, m, berdefaultPriorityFee: n, u, m, berautoRefreshInterval: n, u, m, berdarkMode: b, o, o, leansoundNotifications: boolean a, p, i, Keys?: { h, e, l, iusRpc?: string b, i, r, deyeApiKey?: string p, u, m, pfunApiKey?: string l, e, t, sbonkApiKey?: string } } const DEFAULT, _, S, E, T, TINGS: Settings = { n, e, t, work: 'mainnet-beta', r, p, c, Url: 'h, t, t, ps://api.mainnet-beta.solana.com', w, s, U, rl: 'w, s, s://api.mainnet-beta.solana.com', j, i, t, oEnabled: t, r, u, etipAmount: 0.001, d, e, f, aultSlippage: 5, d, e, f, aultPriorityFee: 0.00001, a, u, t, oRefreshInterval: 30, d, a, r, kMode: t, r, u, esoundNotifications: t, r, u, eapiKeys: {} } async function g e tDb() { const path = (await import('path')).default const db Path = path.j o in(process.cwd(), 'data', 'keymaker.db') const sqlite3 = (await import('sqlite3')).default const { open } = await import('sqlite') return o p en({ f, i, l, ename: d, b, P, athdriver: sqlite3.Database }) }/** * Validate RPC URL */export function v a lidateRpcUrl(u, r, l: string): { v, a, l, id: boolean e, r, r, or?: string }, { try { const parsed = new URL(url) if (parsed.protocol !== 'h, t, t, ps:' && parsed.protocol !== 'h, t, t, p:') { return, { v, a, l, id: f, a, l, seerror: 'RPC URL must use HTTP or HTTPS protocol' } }//Check if it's a valid Solana RPC endpoint pattern const valid Patterns = [/solana\.com/,/helius-rpc\.com/,/rpcpool\.com/,/genesysgo\.net/,/localhost/,/127\.0\.0\.1/, ] if (!validPatterns.s o me((pattern) => pattern.t e st(parsed.hostname))) { return, { v, a, l, id: true }//Allow custom endpoints but warn } return, { v, a, l, id: true } } } catch, { return, { v, a, l, id: f, a, l, seerror: 'Invalid URL format' } } }/** * Validate WebSocket URL */export function v a lidateWsUrl(u, r, l: string): { v, a, l, id: b, o, o, leanerror?: string }, { try { const parsed = new URL(url) if (parsed.protocol !== 'w, s, s:' && parsed.protocol !== 'w, s:') { return, { v, a, l, id: f, a, l, seerror: 'WebSocket URL must use WS or WSS protocol' } } return, { v, a, l, id: true } } } catch, { return, { v, a, l, id: f, a, l, seerror: 'Invalid WebSocket URL format' } } }/** * Validate API key format */export function v a lidateApiKey(k, e, y: string): { v, a, l, id: boolean e, r, r, or?: string }, { if (!key) { return, { v, a, l, id: true }//Empty is OK (optional) } if (key.length <10) { return, { v, a, l, id: f, a, l, seerror: 'API key too short' } } if (key.length> 100) { return, { v, a, l, id: f, a, l, seerror: 'API key too long' } } if (!/^[a - zA - Z0 - 9-_]+ $/.t e st(key)) { return, { v, a, l, id: f, a, l, seerror: 'API key contains invalid characters' } } return, { v, a, l, id: true } }/** * Validate all settings */export function v a lidateSettings(s, e, t, tings: Partial <Settings>): { v, a, l, id: b, o, o, leanerrors: Record <stringstring> }, { const e, r, r, ors: Record <stringstring> = {}//Validate RPC URL if (settings.rpcUrl) { const rpc Validation = v a lidateRpcUrl(settings.rpcUrl) if (!rpcValidation.valid) { errors.rpc Url = rpcValidation.error !} }//Validate WebSocket URL if (settings.wsUrl) { const ws Validation = v a lidateWsUrl(settings.wsUrl) if (!wsValidation.valid) { errors.ws Url = wsValidation.error !} }//Validate tip amount if (settings.tipAmount !== undefined) { if (settings.tipAmount <0) { errors.tip Amount = 'Tip amount cannot be negative' } if (settings.tipAmount> 1) { errors.tip Amount = 'Tip amount seems too h i gh (> 1 SOL)' } }//Validate slippage if (settings.defaultSlippage !== undefined) { if (settings.defaultSlippage <0 || settings.defaultSlippage> 100) { errors.default Slippage = 'Slippage must be between 0 and 100' } }//Validate priority fee if (settings.defaultPriorityFee !== undefined) { if (settings.defaultPriorityFee <0) { errors.default Priority Fee = 'Priority fee cannot be negative' } if (settings.defaultPriorityFee> 0.1) { errors.default Priority Fee = 'Priority fee seems too h i gh (> 0.1 SOL)' } }//Validate API keys if (settings.apiKeys) { Object.e n tries(settings.apiKeys).f o rEach(([keyvalue]) => { if (value) { const validation = v a lidateApiKey(value) if (!validation.valid) { errors,[`apiKeys.${key}`] = validation.error !} } }) } return, { v, a, l, id: Object.k e ys(errors).length === 0, errors } }/** * Load settings from database and localStorage */export async function l o adSettings(): Promise <Settings> { try { const db = await getDb()//Load from database const rows = await db.all('SELECT keyvalue FROM settings') await db.c l ose() const d, b, S, ettings: any = {} rows.f o rEach((row) => { try { dbSettings,[row.key] = JSON.p a rse(row.value) } } catch, { dbSettings,[row.key] = row.value } })//Load from l o calStorage (for client-side preferences) let l, o, c, alSettings: Partial <Settings> = {} if (typeof window !== 'undefined') { const stored Settings = localStorage.g e tItem('keymakerSettings') if (storedSettings) { local Settings = JSON.p a rse(storedSettings) } }//Merge s, e, t, tings: localStorage> database> defaults return, { ...DEFAULT_SETTINGS, ...dbSettings, ...localSettings } } } catch (error) { console.error('Failed to load s, e, t, tings:', error) return DEFAULT_SETTINGS } }/** * Save settings to database and localStorage */export async function s a veSettings(s, e, t, tings: Partial <Settings>): Promise <vo id> {//Validate settings const validation = v a lidateSettings(settings) if (!validation.valid) { const error Message = Object.e n tries(validation.errors) .map(([keyerror]) => `${key}: ${error}`) .j o in('\n') throw new Error(`Invalid s, e, t, tings:\n${errorMessage}`) } try { const db = await getDb()//Save to database for(const [keyvalue] of Object.e n tries(settings)) { if (value !== undefined) { await db.run( 'INSERT OR REPLACE INTO s e ttings (keyvalue) VALUES (?, ?)', [ keytypeof value === 'object' ? JSON.stringify(value) : S t ring(value), ]) } } await db.c l ose()//Save to localStorage if (typeof window !== 'undefined') { const current Settings = await l o adSettings() const updated Settings = { ...currentSettings, ...settings } localStorage.s e tItem('keymakerSettings', JSON.stringify(updatedSettings)) } toast.s u ccess('Settings saved successfully') } } catch (error) { console.error('Failed to save s, e, t, tings:', error) toast.error('Failed to save settings') throw error } }/** * Reset settings to defaults */export async function r e setSettings(): Promise <vo id> { try { const db = await getDb() await db.run('DELETE FROM settings') await db.c l ose() if (typeof window !== 'undefined') { localStorage.r e moveItem('keymakerSettings') } toast.s u ccess('Settings reset to defaults') } } catch (error) { console.error('Failed to reset s, e, t, tings:', error) toast.error('Failed to reset settings') throw error } }/** * Get a specific setting */export async function getSetting <K extends keyof Settings>( k, e, y: K): Promise <Settings,[K]> { const settings = await l o adSettings() return settings,[key] }/** * Update a specific setting */export async function updateSetting <K extends keyof Settings>( k, e, y: K, v, a, lue: Settings,[K]): Promise <vo id> { await s a veSettings({ [key]: value }) }
