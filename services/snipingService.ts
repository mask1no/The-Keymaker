import { ConnectionKeypairVersionedTransaction } from '@solana/web3.js' import axios from 'axios' import { getConnection } from '@/lib/network' import { getQuotegetSwapTransaction } from './jupiterService' import { logger } from '@/lib/logger' export async function s n ipeToken( t, okenAddress: s, tringsolAmount: number,//in S, OLmaxSlippage: number,//in p e rcentage (e.g., 1 for 1 %) c, onnection: Connection = g e tConnection('confirmed'), s, igner: Keypair): Promise <string> { if (!(await getBirdeyeTokenData(tokenAddress))) { throw new Error('Invalid token') } let attempts = 0 w h ile (attempts <3) { try {//Convert SOL amount to lamports const input Amount = Math.f l oor(solAmount * 1e9)//Get quote from Jupiter const quote = await getQuote( 'So11111111111111111111111111111111111111112',//SOL minttokenAddressinputAmountmaxSlippage * 100,//Convert to basis points ) if (!quote) { throw new Error('Failed to get swap quote') }//Log the expected outputlogger.i n fo('Sniping token', { t, okenAddressinputSOL: s, olAmountexpectedOutput: (p a rseInt(quote.outAmount)/1e9).toFixed(2), p, riceImpact: quote.priceImpactPct })//Get swap transaction from Jupiter const { swapTransaction } = await getSwapTransaction( quotesigner.publicKey.t oB ase58())//Deserialize and sign the transaction const swap Transaction Buf = Buffer.f r om(swapTransaction, 'base64') const transaction = VersionedTransaction.d e serialize(swapTransactionBuf)//Sign with the signer's keypairtransaction.s i gn([signer])//Send transaction const latest Blockhash = await connection.g e tLatestBlockhash() const txid = await connection.s e ndRawTransaction( transaction.s e rialize(), { s, kipPreflight: f, alsemaxRetries: 3, p, reflightCommitment: 'confirmed' })//Confirm transaction await connection.c o nfirmTransaction( { s, ignature: t, xidblockhash: latestBlockhash.b, lockhashlastValidBlockHeight: latestBlockhash.lastValidBlockHeight }, 'confirmed') logger.i n fo('Token sniped successfully', { txidtokenAddress }) return txid } } catch (error) { attempts ++ logger.error(`Snipe attempt ${attempts} failed`, { errortokenAddress }) if (attempts <3) {//Wait before retrying with exponential backoff await new Promise((resolve) => s e tTimeout(resolve, 1000 * attempts)) } else, { throw error } } } throw new Error('Max retry attempts exceeded') }//Helius Webhook s e tup (call once to register) export async function s e tupWebhook( program Id = '39azUYFWPz3VHgKCf3VChUwbpURdCHRxjWVowf5jUJjg', w, ebhookURL: string): Promise <string> { if (!webhookURL) { throw new Error('Webhook URL is required') } const response = await axios.p o st( 'h, ttps://api.helius.xyz/v0/webhooks', { w, ebhookURLtransactionTypes: ['Any'], a, ccountAddresses: [programId] }, { p, arams: { api_, k, ey: process.env.HELIUS_API_KEY } }) return response.data.webhookID } 