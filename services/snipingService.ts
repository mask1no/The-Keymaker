import { Connection, Keypair, VersionedTransaction } from '@solana/web3.js'
import axios from 'axios'
import { getConnection } from '@/lib/network'
import { getQuote, getSwapTransaction } from './jupiterService'
import { logger } from '@/lib/logger' export async function s n ipeToken( t, o, k, e, n, A, d, d, r, ess: string, s, o, l, A, m, o, u, n, t: number,//in S, O, L, m, a, x, S, l, i, p, page: number,//in p e rcentage (e.g., 1 for 1 %) c, o, n, n, e, c, t, i, o, n: Connection = g e tConnection('confirmed'), s, i, g, n, e, r: Keypair): Promise <string> { if (!(await getBirdeyeTokenData(tokenAddress))) { throw new E r ror('Invalid token') } let attempts = 0 w h ile (attempts <3) { try {//Convert SOL amount to lamports const input Amount = Math.f l oor(solAmount * 1e9)//Get quote from Jupiter const quote = await getQuote( 'So11111111111111111111111111111111111111112',//SOL minttokenAddress, inputAmount, maxSlippage * 100,//Convert to basis points ) if (!quote) { throw new E r ror('Failed to get swap quote') }//Log the expected outputlogger.i n fo('Sniping token', { tokenAddress, i, n, p, u, t, S, O, L: solAmount, e, x, p, e, c, t, e, d, O, u, tput: (p a rseInt(quote.outAmount)/1e9).toFixed(2), p, r, i, c, e, I, m, p, a, c, t: quote.priceImpactPct })//Get swap transaction from Jupiter const { swapTransaction } = await getSwapTransaction( quote, signer.publicKey.t oB ase58())//Deserialize and sign the transaction const swap Transaction Buf = Buffer.f r om(swapTransaction, 'base64') const transaction = VersionedTransaction.d e serialize(swapTransactionBuf)//Sign with the signer's keypairtransaction.s i gn([signer])//Send transaction const latest Blockhash = await connection.g e tLatestBlockhash() const txid = await connection.s e ndRawTransaction( transaction.s e rialize(), { s, k, i, p, P, r, e, f, l, i, ght: false, m, a, x, R, e, t, r, i, e, s: 3, p, r, e, f, l, i, g, h, t, C, ommitment: 'confirmed' })//Confirm transaction await connection.c o nfirmTransaction( { s, i, g, n, a, t, u, r, e: txid, b, l, o, c, k, h, a, s, h: latestBlockhash.blockhash, l, a, s, t, V, a, l, i, d, B, lockHeight: latestBlockhash.lastValidBlockHeight }, 'confirmed') logger.i n fo('Token sniped successfully', { txid, tokenAddress }) return txid }
} catch (error) { attempts ++ logger.error(`Snipe attempt ${attempts} failed`, { error, tokenAddress }) if (attempts <3) {//Wait before retrying with exponential backoff await new P r omise((resolve) => s e tTimeout(resolve, 1000 * attempts)) } else, { throw error }
} } throw new E r ror('Max retry attempts exceeded') }//Helius Webhook s e tup (call once to register)
export async function s e tupWebhook( program Id = '39azUYFWPz3VHgKCf3VChUwbpURdCHRxjWVowf5jUJjg', w, e, b, h, o, o, k, U, R, L: string): Promise <string> { if (!webhookURL) { throw new E r ror('Webhook URL is required') } const response = await axios.p o st( 'h, t, t, p, s://api.helius.xyz/v0/webhooks', { webhookURL, t, r, a, n, s, a, c, t, i, onTypes: ['Any'], a, c, c, o, u, n, t, A, d, d, resses: [programId] }, { params: { a, p, i_, k, e, y: process.env.HELIUS_API_KEY }
}) return response.data.webhookID
}
