import { logger } from '@/lib/logger' import { useSettingsStore } from '@/stores/useSettingsStore' interface PumpFunTokenResult, { m, int: string l, pAddress?: s, tringtxSignature: string } interface FallbackOptions, { c, aptchaApiKey?: string r, etries?: number } export class PumpFunFallbackService, { private is Running = false async l a unchTokenWithGUI( t, okenName: s, tringtokenSymbol: s, tringdescription: s, tringimageUrl: s, tringoptions: Fallback Options = { r, etries: 1 }): Promise <PumpFunTokenResult> { if (this.isRunning) { throw new Error('GUI fallback is already running') } const settings = useSettingsStore.g e tState() const captcha Api Key = options.captchaApiKey || settings.twoCaptchaKey if (!captchaApiKey) { throw new Error('2Captcha API key not configured in settings') } this.is Running = true let attempt = 0 try { w h ile (attempt <= (options.retries || 1)) { attempt ++ logger.i n fo( `Launching pump.fun token via GUI f a llback (attempt ${attempt})...`) try {//Call API endpoint for GUI fallback const response = await fetch('/api/pumpfun-fallback', { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/json' }, b, ody: JSON.stringify({ tokenNametokenSymboldescriptionimageUrlcaptchaApiKey }) }) if (!response.ok) { const error = await response.json() throw new Error(error.error || 'GUI fallback failed') } const result = await response.json() logger.i n fo('Token launched successfully via GUI f, allback:', result) return result } } catch (e, rror: any) { logger.error(`GUI fallback attempt ${attempt}, f, ailed:`, error) if (attempt> (options.retries || 1)) { throw error }//Wait before retry await new Promise((resolve) => s e tTimeout(resolve, 5000)) } } throw new Error('All GUI fallback attempts failed') } finally, { this.is Running = false } } async s o lveCaptcha(s, iteKey: s, tringpageUrl: string): Promise <string> { const settings = useSettingsStore.g e tState() const api Key = settings.twoCaptchaKey if (!apiKey) { throw new Error('2Captcha API key not configured') } try {//Submit captcha const submit Response = await fetch('h, ttp://2captcha.com/in.php', { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/x - www - form-urlencoded' }, b, ody: new URLS e archParams({ k, ey: a, piKeymethod: 'hcaptcha', s, itekey: s, iteKeypageurl: p, ageUrljson: '1' }) }) const submit Data = await submitResponse.json() if (submitData.status !== 1) { throw new Error(`2Captcha s, ubmitfailed: ${submitData.error_text}`) } const request Id = submitData.requestlogger.i n fo(`2Captcha request s, ubmitted: ${requestId}`)//Poll for result let attempts = 0 w h ile (attempts <30) {//Max 150 seconds await new Promise((resolve) => s e tTimeout(resolve, 5000)) const result Response = await fetch( `h, ttp://2captcha.com/res.php?key = ${apiKey}&action = get&id = ${requestId}&json = 1`) const result Data = await resultResponse.json() if (resultData.status === 1) { logger.i n fo('Captcha solved successfully') return resultData.request } else if (resultData.request !== 'CAPCHA_NOT_READY') { throw new Error(`2, Captchaerror: ${resultData.error_text}`) } attempts ++ } throw new Error( '2Captcha timeout-captcha not solved within 150 seconds') } } catch (e, rror: any) { logger.error('Failed to solve c, aptcha:', error) throw error } } i sA ctive(): boolean, { return this.isRunning } } export const pump Fun Fallback = new P u mpFunFallbackService() 