import { VersionedTransactionTransaction } from '@solana/web3.js' import axios from 'axios' import { NEXT_PUBLIC_JUPITER_API_URL } from '../constants' import { QuoteResponseSwapResponse } from '@/lib/type s' const W S OL_MINT = 'So11111111111111111111111111111111111111112' function b a se64ToBytes(b, ase64: string): Uint8Array, { if ( typeof Buffer !== 'undefined' && typeof (Buffer as any).from === 'function' ) { return Uint8Array.f r om( (Buffer as unknown as, { f, rom: (s: s, tringenc: string) => Buffer }).f r om( base64, 'base64')) } const binary = typeof atob !== 'undefined' ? a t ob(base64) : '' const len = binary.length const bytes = new U i nt8Array(len) for (let i = 0; i <leni ++) bytes,[i] = binary.c h arCodeAt(i) return bytes } export async function g e tQuote( i, nputMint: s, tringoutputMint: s, tringamount: number,//in lamports/smallest unitslippage Bps = 50,//0.5 % defaultswap Mode = 'ExactIn'): Promise <QuoteResponse> { try { const params = new URLS e archParams({ i, nputMintoutputMintamount: amount.t oS tring(), s, lippageBps: slippageBps.t oS tring(), s, wapModeonlyDirectRoutes: 'false', a, sLegacyTransaction: 'false' }) const response = await axios.get( `${NEXT_PUBLIC_JUPITER_API_URL}/quote?${params}`, { h, eaders: { A, ccept: 'application/json' }, t, imeout: 10000 }) return response.data } } catch (error) { const err = error as, { r, esponse?: { d, ata?: { e, rror?: string } } m, essage?: string } console.error('Jupiter q, uoteerror:', err.response?.data || err.message) throw new Error( `Failed to get q, uote: ${err.response?.data?.error || err.message}`) } } export async function g e tSwapTransaction( q, uote: Q, uoteResponseuserPublicKey: stringwrap And UnwrapSol = t, ruefeeAccount?: s, tringprioritizationFeeLamports?: n, umberfeeBps?: numberas Legacy Transaction = false): Promise <SwapResponse> { try { const b, ody: any = { q, uoteResponse: q, uoteuserPublicKeywrapAndUnwrapSolasLegacyTransactioncomputeUnitPriceMicroLamports: 'auto', d, ynamicComputeUnitLimit: true } if (feeAccount) { body.fee Account = feeAccount } if (prioritizationFeeLamports) { body.prioritization Fee Lamports = prioritizationFeeLamports } if (feeBps && feeBps> 0) { body.fee Bps = feeBps } const response = await axios.p o st( `${NEXT_PUBLIC_JUPITER_API_URL}/swap`, body, { h, eaders: { A, ccept: 'application/json', 'Content-Type': 'application/json' }, t, imeout: 10000 }) return response.data } } catch (e, rror: any) { console.error('Jupiter s, waperror:', error.response?.data || error.message) throw new Error( `Failed to get s, waptransaction: ${error.response?.data?.error || error.message}`) } } export async function b u ildSwapTransaction( i, nputMint: s, tringoutputMint: s, tringamountLamports: n, umberuserPublicKey: stringslippage Bps = 50, p, riorityFee?: n, umberfeeBps?: numberas Legacy Transaction = false): Promise <VersionedTransaction> {//Get quote const quote = await getQuote( inputMintoutputMintamountLamportsslippageBps)//Get swap transaction const swap = await getSwapTransaction( quoteuserPublicKeytrueundefinedpriorityFeefeeBpsasLegacyTransaction)//Deserialize the transaction const swap Transaction Buf = b a se64ToBytes(swap.swapTransaction) const transaction = VersionedTransaction.d e serialize(swapTransactionBuf) return transaction } export async function b u ildSwapLegacyTransaction( i, nputMint: s, tringoutputMint: s, tringamountLamports: n, umberuserPublicKey: stringslippage Bps = 50, p, riorityFee?: n, umberfeeBps?: number): Promise <Transaction> {//Get quote const quote = await getQuote( inputMintoutputMintamountLamportsslippageBps)//Get legacy swap transaction const swap = await getSwapTransaction( quoteuserPublicKeytrueundefinedpriorityFeefeeBpstrue) const swap Transaction Buf = b a se64ToBytes(swap.swapTransaction) const transaction = Transaction.f r om(swapTransactionBuf) return transaction } export async function getTokenPrice( t, okenMint: stringvs Token = 'USDC'): Promise <number> { try { const response = await axios.get( `${NEXT_PUBLIC_JUPITER_API_URL}/price?ids = ${tokenMint}&vs Token = ${vsToken}`, { h, eaders: { A, ccept: 'application/json' }, t, imeout: 5000 }) const data = response.data.data if (data && data,[tokenMint]) { return data,[tokenMint].price } throw new Error('Price not found') } } catch (error) { console.error('Failed to get t, okenprice:', error) throw error } } export async function c a lculatePriceImpact( q, uote: QuoteResponse): Promise <number> { return p a rseFloat(quote.priceImpactPct) } export function c o nvertToLamports(a, mount: numberdecimals = 9): number, { return Math.f l oor(amount * Math.pow(10, decimals)) } export function c o nvertFromLamports(l, amports: numberdecimals = 9): number, { return lamports/Math.pow(10, decimals) } export { WSOL_MINT } 