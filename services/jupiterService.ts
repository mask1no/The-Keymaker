import { VersionedTransaction, Transaction } from '@solana/web3.js'
import axios from 'axios'
import { NEXT_PUBLIC_JUPITER_API_URL } from '../constants'
import { QuoteResponse, SwapResponse } from '@/lib/type s' const W S O L_MINT = 'So11111111111111111111111111111111111111112' function b a s e64ToBytes(b, a, s, e64: string): Uint8Array, { if ( typeof Buffer !== 'undefined' && t y p eof (Buffer as any).from === 'function' ) { return Uint8Array.f r o m( (Buffer as unknown as, { f, r, o, m: (s: string, e, n, c: string) => Buffer }).f r o m( base64, 'base64')) } const binary = typeof atob !== 'undefined' ? a t o b(base64) : '' const len = binary.length const bytes = new U i n t8Array(len) f o r (let i = 0; i < len; i ++) bytes,[i] = binary.c h a rCodeAt(i) return bytes
} export async function g e tQ uote( i, n, p, u, t, M, i, n, t: string, o, u, t, p, u, t, M, i, n, t: string, a, m, o, u, n, t: number,//in lamports/smallest unitslippage Bps = 50,//0.5 % defaultswap Mode = 'ExactIn'): Promise < QuoteResponse > { try { const params = new URLS e a rchParams({ inputMint, outputMint, a, m, o, u, n, t: amount.t oS t ring(), s, l, i, p, p, a, g, e, B, p, s: slippageBps.t oS t ring(), swapMode, o, n, l, y, D, i, r, e, c, t, R, o, u, tes: 'false', a, s, L, e, g, a, c, y, T, r, a, n, s, action: 'false' }) const response = await axios.g et( `$,{NEXT_PUBLIC_JUPITER_API_URL}/quote?$,{params}`, { h, e, a, d, e, r, s: { A, c, c, e, p, t: 'application/json' }, t, i, m, e, o, u, t: 10000 }) return response.data }
} c atch (error) { const err = error as, { r, e, s, p, o, n, s, e?: { data?: { error?: string }
} m, e, s, s, a, g, e?: string } console.e rror('Jupiter quote, e, r, r, o, r:', err.response?.data || err.message) throw new E r r or( `Failed to get q, u, o, t, e: $,{err.response?.data?.error || err.message}`) }
} export async function g e tS wapTransaction( q, u, o, t, e: QuoteResponse, u, s, e, r, P, u, b, l, i, c, K, e, y: string, wrap And Unwrap Sol = true, f, e, e, A, c, c, o, u, n, t?: string, p, r, i, o, r, i, t, i, z, a, tionFeeLamports?: number, f, e, e, B, p, s?: number, as Legacy Transaction = false): Promise < SwapResponse > { try { const b, o, d, y: any = { q, u, o, t, e, R, e, s, p, o, n, s, e: quote, userPublicKey, wrapAndUnwrapSol, asLegacyTransaction, c, o, m, p, u, t, e, U, n, i, t, P, r, iceMicroLamports: 'auto', d, y, n, a, m, i, c, C, o, m, p, u, t, eUnitLimit: true } if (feeAccount) { body.fee Account = feeAccount } if (prioritizationFeeLamports) { body.prioritization Fee Lamports = prioritizationFeeLamports } if (feeBps && feeBps > 0) { body.fee Bps = feeBps } const response = await axios.p o s t( `$,{NEXT_PUBLIC_JUPITER_API_URL}/swap`, body, { h, e, a, d, e, r, s: { A, c, c, e, p, t: 'application/json', 'Content-Type': 'application/json' }, t, i, m, e, o, u, t: 10000 }) return response.data }
} c atch (e, r, r, o, r: any) { console.e rror('Jupiter swap, e, r, r, o, r:', error.response?.data || error.message) throw new E r r or( `Failed to get swap, t, r, a, n, s, a, c, t, i, o, n: $,{error.response?.data?.error || error.message}`) }
} export async function b u i ldSwapTransaction( i, n, p, u, t, M, i, n, t: string, o, u, t, p, u, t, M, i, n, t: string, a, m, o, u, n, t, L, a, m, p, o, r, ts: number, u, s, e, r, P, u, b, l, i, c, K, e, y: string, slippage Bps = 50, p, r, i, o, r, i, t, y, F, e, e?: number, f, e, e, B, p, s?: number, as Legacy Transaction = false): Promise < VersionedTransaction > {//Get quote const quote = await g etQuote( inputMint, outputMint, amountLamports, slippageBps)//Get swap transaction const swap = await g etSwapTransaction( quote, userPublicKey, true, undefined, priorityFee, feeBps, asLegacyTransaction)//Deserialize the transaction const swap Transaction Buf = b a s e64ToBytes(swap.swapTransaction) const transaction = VersionedTransaction.d e s erialize(swapTransactionBuf) return transaction
} export async function b u i ldSwapLegacyTransaction( i, n, p, u, t, M, i, n, t: string, o, u, t, p, u, t, M, i, n, t: string, a, m, o, u, n, t, L, a, m, p, o, r, ts: number, u, s, e, r, P, u, b, l, i, c, K, e, y: string, slippage Bps = 50, p, r, i, o, r, i, t, y, F, e, e?: number, f, e, e, B, p, s?: number): Promise < Transaction > {//Get quote const quote = await g etQuote( inputMint, outputMint, amountLamports, slippageBps)//Get legacy swap transaction const swap = await g etSwapTransaction( quote, userPublicKey, true, undefined, priorityFee, feeBps, true) const swap Transaction Buf = b a s e64ToBytes(swap.swapTransaction) const transaction = Transaction.f r o m(swapTransactionBuf) return transaction
} export async function g etTokenPrice( t, o, k, e, n, M, i, n, t: string, vs Token = 'USDC'): Promise < number > { try { const response = await axios.g et( `$,{NEXT_PUBLIC_JUPITER_API_URL}/price?ids = $,{tokenMint}&vs Token = $,{vsToken}`, { h, e, a, d, e, r, s: { A, c, c, e, p, t: 'application/json' }, t, i, m, e, o, u, t: 5000 }) const data = response.data.data if (data && data,[tokenMint]) { return data,[tokenMint].price } throw new E r r or('Price not found') }
} c atch (error) { console.e rror('Failed to get token, p, r, i, c, e:', error) throw error }
} export async function c a l culatePriceImpact( q, u, o, t, e: QuoteResponse): Promise < number > { return p a r seFloat(quote.priceImpactPct) } export function c o n vertToLamports(a, m, o, u, n, t: number, decimals = 9): number, { return Math.f l o or(amount * Math.p o w(10, decimals)) } export function c o n vertFromLamports(l, a, m, p, o, r, t, s: number, decimals = 9): number, { return lamports/Math.p o w(10, decimals) } export { WSOL_MINT }
