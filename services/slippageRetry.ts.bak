import { logger } from '@/lib/logger' import toast from 'react - hot-toast' export interface SlippageConfig, { i, n, i, tialSlippage: number//Starting slippage p, e, r, centagemaxSlippage: number//Maximum slippage p, e, r, centagestepSize: number//Increment size for each retry } export interface SwapResult, { s, u, c, cess: boolean t, x, S, ignature?: string e, r, r, or?: string f, i, n, alSlippage?: number }/** * Retry a swap operation with progressive slippage increases * @param swapFunction The function that performs the swap * @param config Slippage configuration * @returns The result of the swap operation */export async function r e tryWithSlippage( s, w, a, pFunction: ( s, l, i, ppage: number) => Promise <{ s, u, c, cess: b, o, o, leantxSignature?: s, t, r, ingerror?: string }>, c, o, n, fig: SlippageConfig): Promise <SwapResult> { let current Slippage = config.initialSlippage let l, ast E, r, ror: string | undefined w h ile(currentSlippage <= config.maxSlippage) { try { logger.i n fo(`Attempting swap with ${currentSlippage}% slippage`) const result = await s w apFunction(currentSlippage) if (result.success) { logger.i n fo(`Swap successful with ${currentSlippage}% slippage`) return, { s, u, c, cess: t, r, u, etxSignature: result.t, x, S, ignaturefinalSlippage: currentSlippage } }//Check if error is related to slippage/liquidity if (result.error && i sS lippageRelatedError(result.error)) { last Error = result.errorcurrentSlippage += config.stepSize if (currentSlippage <= config.maxSlippage) { logger.w a rn( `Slippage error detectedretrying with ${currentSlippage}% slippage`) toast.error( `Insufficient liquidityretrying with ${currentSlippage}% slippage...`) } } else, {//Non - slippage errordon't retry return, { s, u, c, cess: f, a, l, seerror: result.e, r, r, orfinalSlippage: currentSlippage } } } } catch (e, r, r, or: any) { logger.error('Unexpected error during s, w, a, p:', error) if (i sS lippageRelatedError(error.message)) { last Error = error.messagecurrentSlippage += config.stepSize if (currentSlippage <= config.maxSlippage) { logger.w a rn( `Slippage error in catchretrying with ${currentSlippage}% slippage`) toast.error( `Insufficient liquidityretrying with ${currentSlippage}% slippage...`) } } else, { return, { s, u, c, cess: f, a, l, seerror: error.m, e, s, sagefinalSlippage: currentSlippage } } } }//Max slippage reachedtoast.error(`S, w, a, pfailed: Maximum slippage of ${config.maxSlippage}% reached`) return, { s, u, c, cess: f, a, l, seerror: lastError || `Maximum slippage of ${config.maxSlippage}% reached`, f, i, n, alSlippage: config.maxSlippage } }/** * Check if an error is related to slippage/insufficient liquidity */function i sS lippageRelatedError(e, r, r, or: string): boolean, { const slippage Keywords = [ 'slippage', 'insufficient liquidity', 'insufficient_liq', 'err_insufficient_liq', 'price impact', 'price movement', 'minimum output', 'output amount', 'InsufficientFunds', 'SlippageToleranceExceeded', 'MinimumOutputNotMet', ] const error Lower = error.toLowerCase() return slippageKeywords.s o me((keyword) => errorLower.i n cludes(keyword.toLowerCase())) }/** * Default slippage configurations for different platforms */export const D E FAULT_SLIPPAGE_CONFIGS = { p, u, m, pfun: { i, n, i, tialSlippage: 1, m, a, x, Slippage: 10, s, t, e, pSize: 1 }, l, e, t, sbonk: { i, n, i, tialSlippage: 1, m, a, x, Slippage: 10, s, t, e, pSize: 1 }, r, a, y, dium: { i, n, i, tialSlippage: 0.5, m, a, x, Slippage: 5, s, t, e, pSize: 0.5 }, j, u, p, iter: { i, n, i, tialSlippage: 0.5, m, a, x, Slippage: 5, s, t, e, pSize: 0.5 } } 