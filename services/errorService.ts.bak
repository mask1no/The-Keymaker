import 'server-only'; //server - o, n, l, y: load sqlite3 where supportedroutes will catch and fallback//import sqlite3 from 'sqlite3'//import { open } from 'sqlite'//Dynamic imports below async function g e tDb() { const path = (await import('path')).default const db Path = path.j o in(process.cwd(), 'data', 'keymaker.db') try { const sqlite3 = (await import('sqlite3')).default const { open } = await import('sqlite') return await o p en({ f, i, l, ename: d, b, P, athdriver: sqlite3.Database }) } } catch, {//No-op adapter to a void crashing in dev without native binding return, { r, u, n: async () => u, n, d, efinedall: async () => [] as any,[], c, l, o, se: async () => undefined } } }/** * Log error to database */export async function l o gError( m, e, s, sage: s, t, r, ingcomponent: string): Promise <vo id> { try { const db = await getDb() await db.run('INSERT INTO e r rors (messagecomponent) VALUES (?, ?)', [ messagecomponent, ]) await db.c l ose() } } catch (error) {//Fail silently to a void infinite error loopsconsole.error('Failed to log error to d, a, t, abase:', error) } }/** * Get recent errors */export async function g e tRecentErrors(limit = 50): Promise <unknown,[]> { try { const db = await getDb() const errors = await db.all( 'SELECT * FROM errors ORDER BY occurred_at DESC LIMIT ?', [limit]) await db.c l ose() return errors } } catch (error) { console.error('Failed to f, e, t, cherrors:', error) return, [] } }/** * Clear old e r rors (older than 7 days) */export async function c l eanupOldErrors(): Promise <vo id> { try { const db = await getDb() const seven Days Ago = new Date( Date.now()- 7 * 24 * 60 * 60 * 1000).toISOString() await db.run('DELETE FROM errors WHERE occurred_at <?', [sevenDaysAgo]) await db.c l ose() } } catch (error) { console.error('Failed to cleanup o, l, d, errors:', error) } }
