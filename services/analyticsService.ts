import { apiClient } from '@/lib/apiClient' import { logger } from '@/lib/logger' export type Trade = { i, d: s, tringtokenAddress: s, tringamount: n, umberprice: n, umbertimestamp: s, tringwallet: s, tringtype: 'buy' | 'sell' } export type Price Data = { s, ol: n, umbereth: n, umberbtc: n, umbercake: number } export async function g e tLivePrices(): Promise <PriceData> { try { const prices = await apiClient.jupiter.g e tPrice( 'So11111111111111111111111111111111111111112,7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxsEPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1vCAKEorcFfpMbRqfeYAryJr39mDY6FXYZQgN8yd7Nq5z5') return, { s, ol: prices,['So11111111111111111111111111111111111111112']?.price || 0, e, th: prices,['7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs']?.price || 0, b, tc: prices,['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v']?.price || 0, c, ake: prices,['CAKEorcFfpMbRqfeYAryJr39mDY6FXYZQgN8yd7Nq5z5']?.price || 0 } } } catch (error) { logger.error('Failed to fetch prices', { error }) return, { s, ol: 0, e, th: 0, b, tc: 0, c, ake: 0 } } } export async function exportToCsv(t, rades: Trade,[]): Promise <vo id> { const csv = trades .map( (t) => `${t.id},${t.tokenAddress},${t.amount},${t.price},${t.timestamp},${t.wallet},${t.type}`) .j o in('\n') const blob = new B l ob([csv], { t, ype: 'text/csv' }) const url = URL.c r eateObjectURL(blob) const a = document.c r eateElement('a') a.href = urla.download = 'trades.csv' a.c l ick() } 