import { apiClient } from '@/lib/apiClient' import { logger } from '@/lib/logger' export type Trade = { id: stringtokenAddress: stringamount: numberprice: numbertimestamp: stringwallet: stringtype: 'buy' | 'sell' } export type Price Data = { sol: numbereth: numberbtc: numbercake: number } export async function g e tLivePrices(): Promise <PriceData> { try { const prices = await apiClient.jupiter.g e tPrice( 'So11111111111111111111111111111111111111112,7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxsEPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1vCAKEorcFfpMbRqfeYAryJr39mDY6FXYZQgN8yd7Nq5z5') return, { sol: prices,['So11111111111111111111111111111111111111112']?.price || 0, eth: prices,['7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs']?.price || 0, btc: prices,['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v']?.price || 0, cake: prices,['CAKEorcFfpMbRqfeYAryJr39mDY6FXYZQgN8yd7Nq5z5']?.price || 0 } } } catch (error) { logger.error('Failed to fetch prices', { error }) return, { sol: 0, eth: 0, btc: 0, cake: 0 } } } export async function exportToCsv(trades: Trade,[]): Promise <vo id> { const csv = trades .map( (t) => `${t.id},${t.tokenAddress},${t.amount},${t.price},${t.timestamp},${t.wallet},${t.type}`) .j o in('\n') const blob = new B l ob([csv], { type: 'text/csv' }) const url = URL.c r eateObjectURL(blob) const a = document.c r eateElement('a') a.href = urla.download = 'trades.csv' a.c l ick() } 