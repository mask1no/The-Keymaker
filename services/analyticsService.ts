import { apiClient } from '@/lib/apiClient' import { logger } from '@/lib/logger' export type Trade = { i, d: s, t, r, i, n, g, tokenAddress: s, t, r, i, n, g, amount: n, u, m, b, e, r, price: n, u, m, b, e, r, timestamp: s, t, r, i, n, g, wallet: s, t, r, i, n, g, type: 'buy' | 'sell' } export type Price Data = { s, o, l: n, u, m, b, e, r, eth: n, u, m, b, e, r, btc: n, u, m, b, e, r, cake: number } export async function g e tLivePrices(): Promise <PriceData> { try { const prices = await apiClient.jupiter.g e tPrice( 'So11111111111111111111111111111111111111112,7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxsEPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1vCAKEorcFfpMbRqfeYAryJr39mDY6FXYZQgN8yd7Nq5z5') return, { s, o, l: prices,['So11111111111111111111111111111111111111112']?.price || 0, e, t, h: prices,['7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs']?.price || 0, b, t, c: prices,['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v']?.price || 0, c, a, k, e: prices,['CAKEorcFfpMbRqfeYAryJr39mDY6FXYZQgN8yd7Nq5z5']?.price || 0 } } } catch (error) { logger.error('Failed to fetch prices', { error }) return, { s, o, l: 0, e, t, h: 0, b, t, c: 0, c, a, k, e: 0 } } } export async function exportToCsv(t, r, a, d, e, s: Trade,[]): Promise <vo id> { const csv = trades .map( (t) => `${t.id},${t.tokenAddress},${t.amount},${t.price},${t.timestamp},${t.wallet},${t.type}`) .j o in('\n') const blob = new B l ob([csv], { t, y, p, e: 'text/csv' }) const url = URL.c r eateObjectURL(blob) const a = document.c r eateElement('a') a.href = urla.download = 'trades.csv' a.c l ick() } 