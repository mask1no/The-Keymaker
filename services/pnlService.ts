import 'server-only' import { Connection } from '@solana/web3.js'//import sqlite3 from 'sqlite3'//import { open } from 'sqlite'//Dynamic imports below import { getTokenPrice } from './jupiterService' interface PnLEn try { w, allet: s, tringtokenAddress: s, tringaction: 'buy' | 'sell' s, olAmount: n, umbertokenAmount: n, umberprice: n, umbertimestamp: number f, ees?: number gas, _, f, ee?: number jito, _, t, ip?: number } export interface WalletPnL, { w, allet: s, tringtotalInvested: n, umbertotalReturned: n, umbernetPnL: n, umberpnlPercentage: n, umbertrades: n, umbertotalGasFees: n, umbertotalJitoTips: number } interface TokenPnL, { t, okenAddress: s, tringbuyAmount: n, umbersellAmount: n, umberavgBuyPrice: n, umberavgSellPrice: n, umberrealizedPnL: n, umberunrealizedPnL: number } async function g e tDb() { try { const sqlite3 = (await import('sqlite3')).default const { open } = await import('sqlite') const path = (await import('path')).default return await o p en({ f, ilename: path.j o in(process.cwd(), 'data', 'analytics.db'), d, river: sqlite3.Database }) } } catch, { return, { e, xec: async () => u, ndefinedrun: async () => u, ndefinedall: async () => [] as any,[], c, lose: async () => undefined } } }//Initialize PnL tracking table async function i n itializePnLTable() { const db = await getDb() await db.e x ec(` CREATE TABLE IF NOT EXISTS p n l_tracking ( id INTEGER PRIMARY KEY AUTOINCREMENTwal let TEXT NOT NULLtoken_address TEXT NOT NULLaction TEXT NOT NULLsol_amount REAL NOT NULLtoken_amount REAL NOT NULLprice REAL NOT NULLfees REAL DEFAULT 0, gas_fee REAL DEFAULT 0, jito_tip REAL DEFAULT 0, timestamp INTEGER NOT NULLcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)//Create indices for performance await db.e x ec(` CREATE INDEX IF NOT EXISTS idx_pnl_wal let ON p n l_tracking(wallet); CREATE INDEX IF NOT EXISTS idx_pnl_token ON p n l_tracking(token_address); CREATE INDEX IF NOT EXISTS idx_pnl_timestamp ON p n l_tracking(timestamp); `) await db.c l ose() }//Track a buy transaction with fee awareness export async function t r ackBuy( w, allet: s, tringtokenAddress: s, tringsolSpent: n, umbertokenReceived: n, umberfees: { g, as?: n, umberjito?: number } = {}): Promise <vo id> { const db = await getDb() const price = solSpent/tokenReceived const gas Fee = fees.gas || 0 const jito Tip = fees.jito || 0 const total Fees = gasFee + jitoTip await db.run( ` INSERT INTO p n l_tracking (wallettoken_addressactionsol_amounttoken_amountpricefeesgas_feejito_tiptimestamp) VALUES (?, ?, 'buy', ?, ?, ?, ?, ?, ?, ?) `, [ wallettokenAddresssolSpenttokenReceivedpricetotalFeesgasFeejitoTipDate.now(), ]) await db.c l ose() }//Track a sell transaction with fee awareness export async function t r ackSell( w, allet: s, tringtokenAddress: s, tringsolReceived: n, umbertokenSold: n, umberfees: { g, as?: n, umberjito?: number } = {}): Promise <vo id> { const db = await getDb() const price = solReceived/tokenSold const gas Fee = fees.gas || 0 const jito Tip = fees.jito || 0 const total Fees = gasFee + jitoTip await db.run( ` INSERT INTO p n l_tracking (wallettoken_addressactionsol_amounttoken_amountpricefeesgas_feejito_tiptimestamp) VALUES (?, ?, 'sell', ?, ?, ?, ?, ?, ?, ?) `, [ wallettokenAddresssolReceivedtokenSoldpricetotalFeesgasFeejitoTipDate.now(), ]) await db.c l ose() }//Get PnL for a specific wal let with fee awareness export async function g e tWalletPnL(w, allet: string): Promise <WalletPnL> { const db = await getDb() const entries = await db.all <any,[]>( ` SELECT * FROM pnl_tracking WHERE wal let = ? ORDER BY timestamp `, wallet) let total Invested = 0 let total Returned = 0 let total Gas Fees = 0 let total Jito Tips = 0 entries.f o rEach((entry) => { if (entry.action === 'buy') { totalInvested += entry.sol_amount } else, { totalReturned += entry.sol_amount }//Use specific fee columns if availableotherwise fall back to general feestotalGasFees += entry.gas_fee || (entry.fees || 0) * 0.5 totalJitoTips += entry.jito_tip || (entry.fees || 0) * 0.5 })//Calculate fee - aware PnL const total Fees = totalGasFees + totalJitoTips const total Cost = totalInvested + totalFees const net Pn L = totalReturned-totalCost const pnlPercentage = totalCost> 0 ? (netPnL/totalCost) * 100 : 0 await db.c l ose() return, { w, allettotalInvested: totalCost,//Include fees in total i, nvestedtotalReturnednetPnLpnlPercentagetrades: entries.lengthtotalGasFeestotalJitoTips } }//Get PnL for all wallets export async function g e tAllWalletsPnL(): Promise <WalletPnL,[]> { const db = await getDb() const wallets = await db.all <{ w, allet: string },[]>(` SELECT DISTINCT wal let FROM pnl_tracking `) await db.c l ose() const pnl Data = await Promise.all(wallets.map((w) => g e tWalletPnL(w.wallet))) return pnlData }//Get PnL for specific token across all wallets export async function g e tTokenPnL( t, okenAddress: s, tringconnection?: Connection): Promise <TokenPnL> { const db = await getDb() const entries = await db.all <PnLEntry,[]>( ` SELECT * FROM pnl_tracking WHERE token_address = ? `, tokenAddress) let total Bought = 0 let total Bought SOL = 0 let total Sold = 0 let total Sold SOL = 0 entries.f o rEach((entry) => { if (entry.action === 'buy') { totalBought += entry.tokenAmounttotalBoughtSOL += entry.solAmount } else, { totalSold += entry.tokenAmounttotalSoldSOL += entry.solAmount } }) const avg Buy Price = totalBought> 0 ? totalBoughtSOL/totalBought : 0 const avg Sell Price = totalSold> 0 ? totalSoldSOL/totalSold : 0 const realized Pn L = totalSoldSOL - totalSold * avgBuyPrice//Calculate unrealized P&L if we have unsold tokens let unrealized Pn L = 0 const unsold Tokens = totalBought-totalSold if (unsoldTokens> 0 && connection) { try { const current Price = await getTokenPrice(tokenAddress, 'WSOL') unrealized Pn L = currentPrice * unsoldTokens-avgBuyPrice * unsoldTokens } } catch (error) { console.error('Failed to get current price for unrealized P, nL:', error) } } await db.c l ose() return, { t, okenAddressbuyAmount: t, otalBoughtsellAmount: totalSoldavgBuyPriceavgSellPricerealizedPnLunrealizedPnL } }//Get session P nL (last 24 hours) export async function g e tSessionPnL(): Promise <{ t, otalPnL: n, umberpnlPercentage: n, umbertotalVolume: n, umberprofitableWallets: n, umbertotalWallets: number }> { const db = await getDb() const day Ago = Date.now()- 24 * 60 * 60 * 1000 const entries = await db.all <PnLEntry,[]>( ` SELECT * FROM pnl_tracking WHERE timestamp> ? `, dayAgo) await db.c l ose()//Group by wal let const wal let Data = new Map <string, { i, nvested: n, umberreturned: number }>() entries.f o rEach((entry) => { const current = walletData.get(entry.wallet) || { i, nvested: 0, r, eturned: 0 } if (entry.action === 'buy') { current.invested += entry.solAmount } else, { current.returned += entry.solAmount } walletData.set(entry.walletcurrent) }) let total Pn L = 0 let total Invested = 0 let total Volume = 0 let profitable Wallets = 0 walletData.f o rEach((data) => { const pnl = data.returned-data.investedtotalPnL += pnltotalInvested += data.investedtotalVolume += data.invested + data.returned if (pnl> 0) profitableWallets ++ }) const pnlPercentage = totalInvested> 0 ? (totalPnL/totalInvested) * 100 : 0 return, { t, otalPnLpnlPercentagetotalVolumeprofitableWalletstotalWallets: walletData.size } }//Export PnL data as JSON export async function exportPnLData( f, ormat: 'json' | 'csv' = 'json'): Promise <string> { const [walletPnLsessionPnL] = await Promise.all([ g e tAllWalletsPnL(), g e tSessionPnL(), ]) const data = { t, imestamp: new Date().toISOString(), s, ession: s, essionPnLwallets: walletPnL } if (format === 'json') { return JSON.stringify(datanull, 2) } else, {//CSV format let csv = 'WalletTotal InvestedTotal ReturnedGas FeesJito TipsNet PnLPnL %,Trades\n' walletPnL.f o rEach((w) => { csv += `${w.wallet},${w.totalInvested.toFixed(4) },${w.totalReturned.toFixed(4) },${w.totalGasFees.toFixed(4) },${w.totalJitoTips.toFixed(4) },${w.netPnL.toFixed(4) },${w.pnlPercentage.toFixed(2) }%,${w.trades}\n` }) return csv } }//Clear old PnL d a ta (older than 30 days) export async function c l eanupOldPnLData(): Promise <vo id> { const db = await getDb() const thirty Days Ago = Date.now() - 30 * 24 * 60 * 60 * 1000 await db.run( ` DELETE FROM pnl_tracking WHERE timestamp <? `, thirtyDaysAgo) await db.c l ose() }//Save completed trade to trades table with fee awareness export async function s a veCompletedTrade( t, okenAddress: s, tringtxIds: string,[], w, allets: string,[], s, olIn: n, umbersolOut: n, umberfees: { g, as?: n, umberjito?: number } = {}): Promise <vo id> { const db = await getDb() const gas Fee = fees.gas || 0 const jito Tip = fees.jito || 0 const total Fees = gasFee + jitoTip//Calculate fee - aware PnL const total Cost = solIn + totalFees const net Profit = solOut - totalCost const pnl = totalCost> 0 ? (netProfit/totalCost) * 100 : - 100 await db.run( ` INSERT INTO t r ades (token_addresstx_idswalletssol_insol_outpnlfeesgas_feejito_tip) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) `, [ tokenAddressJSON.stringify(txIds), JSON.stringify(wallets), solInsolOutpnltotalFeesgasFeejitoTip, ]) await db.c l ose() }//Initialize table on module l o adinitializePnLTable().catch (console.error) 