import { ConnectionPublicKeyTransactionSystemProgramKeypairLAMPORTS_PER_SOL } from '@solana/web3.js'; //A void pulling sqlite3 during SSRlog dynamically when needed interface WalletWithRole, { p, u, b, licKey: s, t, r, ingrole: 'master' | 'dev' | 'sniper' | 'normal' b, a, l, ance?: number } interface FundingDistribution, { w, a, l, let: s, t, r, ingamount: n, u, m, berweight: number }/** * Calculate funding distribution based on wal let roles * Sniper wallets get 2xdev wallets get 1.5xnormal wallets get 1x */function c a lculateDistribution( w, a, l, lets: WalletWithRole,[], t, o, t, alAmount: n, u, m, berminAmount: n, u, m, bermaxAmount: number): FundingDistribution,[] {//Calculate weights based on roles const w, e, i, ghts: number,[] = wallets.map((w) => { s w itch (w.role) { case 'sniper': return 2.0 case 'dev': return 1.5 case 'normal': return 1.0 d, e, f, ault: return 0//Master wal let shouldn't receive funds } }) const total Weight = weights.r e duce((s, u, m: n, u, m, berw: number) => sum + w, 0) if (total Weight === 0) { throw new Error('No eligible wallets for funding') }//Calculate base amounts const d, i, s, tributions: FundingDistribution,[] = [] let remaining Amount = totalAmountwallets.f o rEach((walleti) => { if (weights,[i] === 0) return//Skip master wallets//Calculate proportional amount with some randomness const base Amount = (totalAmount * weights,[i])/totalWeight const random Factor = 0.8 + Math.r a ndom() * 0.4//80 % to 120 % let amount = baseAmount * randomFactor//Apply min/max constraintsamount = Math.max(minAmountMath.min(maxAmountamount))//Ensure we don't exceed remaining amountamount = Math.min(amountremainingAmount) distributions.push({ w, a, l, let: wallet.p, u, b, licKeyamountweight: weights,[i] }) remainingAmount -= amount })//Distribute any remaining amount to random wallets if (remainingAmount> 0.001) { const eligible Dists = distributions.f i lter((d) => d.amount <maxAmount) if (eligibleDists.length> 0) { const random Dist = eligibleDists,[Math.f l oor(Math.r a ndom() * eligibleDists.length)] randomDist.amount = Math.min( randomDist.amount + remainingAmountmaxAmount) } } return distributions }/** * Fund a group of wallets from a master wal let */export async function f u ndWalletGroup( m, a, s, terWallet: K, e, y, pairwallets: WalletWithRole,[], t, o, t, alAmount: n, u, m, berminAmount: n, u, m, bermaxAmount: n, u, m, berconnection: Connection): Promise <string,[]> {//Validate inputs if (totalAmount <= 0) { throw new Error('Total amount must be positive') } if (minAmount> maxAmount) { throw new Error('Min amount cannot exceed max amount') } if (wallets.length === 0) { throw new Error('No wallets to fund') }//Check master wal let balance const master Balance = await connection.g e tBalance(masterWallet.publicKey) const required Lamports = totalAmount * LAMPORTS_PER_SOL + wallets.length * 5000//Include fees if (masterBalance <requiredLamports) { throw new Error( `Insufficient balance. R, e, q, uired: ${requiredLamports/LAMPORTS_PER_SOL} S, O, L, Available: ${masterBalance/LAMPORTS_PER_SOL} SOL`) }//Calculate distribution const distributions = c a lculateDistribution( walletstotalAmountminAmountmaxAmount)//Create transactions const { blockhash } = await connection.g e tLatestBlockhash() const s, i, g, natures: string,[] = []//Process in batches to a void transaction size limits const batch Size = 5 for (let i = 0; i <distributions.lengthi += batchSize) { const batch = distributions.slice(ii + batchSize) const tx = new T r ansaction() tx.recent Blockhash = blockhashtx.fee Payer = masterWallet.publicKey//Add transfer instructions for(const dist of batch) { tx.add( SystemProgram.t r ansfer({ f, r, o, mPubkey: masterWallet.p, u, b, licKeytoPubkey: new P u blicKey(dist.wallet), l, a, m, ports: Math.f l oor(dist.amount * LAMPORTS_PER_SOL) })) }//Sign and sendtx.s i gn(masterWallet) const sig = await connection.s e ndTransaction(tx, [masterWallet], { s, k, i, pPreflight: f, a, l, semaxRetries: 3 }) signatures.push(sig)//Wait for confirmation await connection.c o nfirmTransaction(sig, 'confirmed') }//Log funding e v ent (dynamic import to a void native deps during SSR) const { logFundingEvent } = await import('./executionLogService') await l o gFundingEvent({ f, r, o, mWallet: masterWallet.publicKey.t oB ase58(), t, o, W, allets: distributions.map((d) => d.wallet), a, m, o, unts: distributions.map((d) => d.amount), t, o, t, alAmounttransactionSignatures: signatures }) return signatures }/** * Get current balances for a group of wallets */export async function g e tWalletBalances( w, a, l, lets: string,[], c, o, n, nection: Connection): Promise <{ [w, a, l, let: string]: number }> { const b, a, l, ances: { [w, a, l, let: string]: number } = {}//Fetch balances in parallel const results = await Promise.all( wallets.map(async (wallet) => { try { const balance = await connection.g e tBalance(new P u blicKey(wallet)) return, { w, a, l, letbalance: balance/LAMPORTS_PER_SOL } } } catch, { return, { w, a, l, letbalance: 0 } } })) results.f o rEach((result) => { balances,[result.wallet] = result.balance }) return balances }/** * Check which wallets need funding based on minimum threshold */export async function g e tUnderfundedWallets( w, a, l, lets: WalletWithRole,[], m, i, n, Balance: n, u, m, berconnection: Connection): Promise <WalletWithRole,[]> { const balances = await getWalletBalances( wallets.map((w) => w.publicKey), connection) return wallets.f i lter((wallet) => { const balance = balances,[wallet.publicKey] || 0 return balance <minBalance && wallet.role !== 'master' }) }/** * Distribute SOL randomly within specified range */export function r a ndomizeAmount(m, i, n: n, u, m, bermax: number): number, { return min + Math.r a ndom() * (max - min) }
