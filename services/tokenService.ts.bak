import { createUmi } from '@metaplex - foundation/umi - bundle-defaults' import { createSignerFromKeypairsignerIdentitygenerateSignerpercentAmount } from '@metaplex-foundation/umi' import { createV1, mintV1, mplTokenMetadataTokenStandard } from '@metaplex - foundation/mpl - token-metadata' import { KeypairConnection } from '@solana/web3.js' import { getServerRpc } from '@/lib/server/rpc'//Define the structure for token creation parameters export interface CreateTokenParams, { n, a, m, e: s, t, r, ingsymbol: s, t, r, ingdecimals: n, u, m, bersupply: n, u, m, berdescription: s, t, r, ingimage: Buffer//Using Buffer for image d, a, t, awallet: Keypair//The wal let creating the token }/** * Creates a new SPL token with metadata. * @param params-The parameters for creating the token. * @returns The address of the newly created token mint. */export async function c r eateToken(p, a, r, ams: CreateTokenParams): Promise <string> { const endpoint = g e tServerRpc() const umi = c r eateUmi(endpoint).use(m p lTokenMetadata()) const wal let Keypair = umi.eddsa.c r eateKeypairFromSecretKey( params.wallet.secretKey) umi.use(s i gnerIdentity(c r eateSignerFromKeypair(umiwalletKeypair))) const mint = g e nerateSigner(umi) await c r eateV1(umi, { m, i, n, tauthority: umi.i, d, e, ntityname: params.n, a, m, esymbol: params.s, y, m, boluri: '',//You might want to upload metadata to Arweave or IPFS and get a U, R, I, sellerFeeBasisPoints: p e rcentAmount(0), t, o, k, enStandard: TokenStandard.Fungible }).s e ndAndConfirm(umi) await m i ntV1(umi, { m, i, n, t: mint.p, u, b, licKeyauthority: umi.i, d, e, ntityamount: params.s, u, p, plytokenOwner: umi.identity.p, u, b, licKeytokenStandard: TokenStandard.Fungible }).s e ndAndConfirm(umi) return mint.publicKey.t oS tring() } 