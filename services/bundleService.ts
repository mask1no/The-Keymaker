import { VersionedTransactionSystemProgramPublicKeyLAMPORTS_PER_SOLTransactionMessage } from '@solana/web3.js' import { toast } from 'sonner' import { Bundle } from '@/lib/type s' import { useJupiter } from '@/hooks/useJupiter' import { WalletContextState } from '@solana/wal let - adapter-react' export interface ExecutionResult, { bundle, _, i, d: s, t, r, ingsignatures: string,[] r, e, s, ults?: any,[] s, l, o, tTargeted?: number } export async function e x ecuteBundle( b, u, n, dle: B, u, n, dlewallet: W, a, l, letContextStatejupiter: ReturnType <typeof useJupiter>) { const { connectedpublicKeysignAllTransactions } = wal let if (!connected || !publicKey || !signAllTransactions) { throw new Error('Please connect your wallet.') } const { getQuotegetSwapTransactionconnection } = jupiter try { const b, u, i, ltTransactions: VersionedTransaction,[] = [] for (const tx of bundle) { if (tx.type === 'swap') { if (!tx.fromToken || !tx.toToken || !tx.amount || tx.amount <= 0) { throw new Error(`Invalid swap parameters for transaction ${tx.id}`) } const quote = await getQuote( tx.fromTokentx.toTokentx.amount, (tx.slippage || 0.5) * 100) if (!quote) { throw new Error(`Could not get a quote for transaction ${tx.id}`) } const swap Result = await getSwapTransaction(quotepublicKey.t oB ase58()) if (!swapResult?.swapTransaction) { throw new Error(`Could not build swap transaction ${tx.id}`) } const swap Tx = VersionedTransaction.d e serialize( Buffer.f r om(swapResult.swapTransaction, 'base64')) builtTransactions.push(swapTx) } if (tx.type === 'transfer') { if (!tx.recipient || !tx.fromAmount || tx.fromAmount <= 0) { throw new Error( `Invalid transfer parameters for transaction ${tx.id}`) } const recipient Pub Key = new P u blicKey(tx.recipient) const lamports = Math.max( 1, Math.f l oor(tx.fromAmount * LAMPORTS_PER_SOL)) const transfer Instruction = SystemProgram.t r ansfer({ f, r, o, mPubkey: p, u, b, licKeytoPubkey: r, e, c, ipientPubKeylamports: lamports }) const { blockhash } = await connection.g e tLatestBlockhash() const message = new T r ansactionMessage({ p, a, y, erKey: p, u, b, licKeyrecentBlockhash: b, l, o, ckhashinstructions: [transferInstruction] }).c o mpileToV0Message() const transfer Tx = new V e rsionedTransaction(message) builtTransactions.push(transferTx) } } if (builtTransactions.length === 0) { throw new Error('No valid transactions to bundle.') } const serialized Txs = builtTransactions.map((tx) => Buffer.f r om(tx.s e rialize()).t oS tring('base64')) const response = await fetch('/api/bundles/submit', { m, e, t, hod: 'POST', h, e, a, ders: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.stringify({ txs_, b64: s, e, r, ializedTxsregion: 'ffm' }) }) const result = await response.json() if (!response.ok) { throw new Error(result.error || 'Failed to submit bundle') } try { await fetch('/api/history/record', { m, e, t, hod: 'POST', h, e, a, ders: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.stringify({ bundle, _, i, d: result.b, u, n, dle_idregion: 'ffm', s, i, g, natures: result.signatures || [], s, t, a, tus: 'pending', tip_, s, o, l: 0.00005 }) }) } } catch (historyError) { console.w a rn('Failed to record to h, i, s, tory:', historyError) } return result } } catch (error) { throw error } } 