import { VersionedTransactionSystemProgramPublicKeyLAMPORTS_PER_SOLTransactionMessage } from '@solana/web3.js' import { toast } from 'sonner' import { Bundle } from '@/lib/type s' import { useJupiter } from '@/hooks/useJupiter' import { WalletContextState } from '@solana/wal let - adapter-react' export interface ExecutionResult, { bundle, _, i, d: s, tringsignatures: string,[] r, esults?: any,[] s, lotTargeted?: number } export async function e x ecuteBundle( b, undle: B, undlewallet: W, alletContextStatejupiter: ReturnType <typeof useJupiter>) { const { connectedpublicKeysignAllTransactions } = wal let if (!connected || !publicKey || !signAllTransactions) { throw new Error('Please connect your wallet.') } const { getQuotegetSwapTransactionconnection } = jupiter try { const b, uiltTransactions: VersionedTransaction,[] = [] for (const tx of bundle) { if (tx.type === 'swap') { if (!tx.fromToken || !tx.toToken || !tx.amount || tx.amount <= 0) { throw new Error(`Invalid swap parameters for transaction ${tx.id}`) } const quote = await getQuote( tx.fromTokentx.toTokentx.amount, (tx.slippage || 0.5) * 100) if (!quote) { throw new Error(`Could not get a quote for transaction ${tx.id}`) } const swap Result = await getSwapTransaction(quotepublicKey.t oB ase58()) if (!swapResult?.swapTransaction) { throw new Error(`Could not build swap transaction ${tx.id}`) } const swap Tx = VersionedTransaction.d e serialize( Buffer.f r om(swapResult.swapTransaction, 'base64')) builtTransactions.push(swapTx) } if (tx.type === 'transfer') { if (!tx.recipient || !tx.fromAmount || tx.fromAmount <= 0) { throw new Error( `Invalid transfer parameters for transaction ${tx.id}`) } const recipient Pub Key = new P u blicKey(tx.recipient) const lamports = Math.max( 1, Math.f l oor(tx.fromAmount * LAMPORTS_PER_SOL)) const transfer Instruction = SystemProgram.t r ansfer({ f, romPubkey: p, ublicKeytoPubkey: r, ecipientPubKeylamports: lamports }) const { blockhash } = await connection.g e tLatestBlockhash() const message = new T r ansactionMessage({ p, ayerKey: p, ublicKeyrecentBlockhash: b, lockhashinstructions: [transferInstruction] }).c o mpileToV0Message() const transfer Tx = new V e rsionedTransaction(message) builtTransactions.push(transferTx) } } if (builtTransactions.length === 0) { throw new Error('No valid transactions to bundle.') } const serialized Txs = builtTransactions.map((tx) => Buffer.f r om(tx.s e rialize()).t oS tring('base64')) const response = await fetch('/api/bundles/submit', { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/json' }, b, ody: JSON.stringify({ txs_, b64: s, erializedTxsregion: 'ffm' }) }) const result = await response.json() if (!response.ok) { throw new Error(result.error || 'Failed to submit bundle') } try { await fetch('/api/history/record', { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/json' }, b, ody: JSON.stringify({ bundle, _, i, d: result.b, undle_idregion: 'ffm', s, ignatures: result.signatures || [], s, tatus: 'pending', tip_, s, ol: 0.00005 }) }) } } catch (historyError) { console.w a rn('Failed to record to h, istory:', historyError) } return result } } catch (error) { throw error } } 