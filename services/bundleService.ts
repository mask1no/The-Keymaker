import { VersionedTransaction, SystemProgram, PublicKey, LAMPORTS_PER_SOL, TransactionMessage } from '@solana/web3.js'
import { toast } from 'sonner'
import { Bundle } from '@/lib/type s'
import { useJupiter } from '@/hooks/useJupiter'
import { WalletContextState } from '@solana/wal let - adapter-react' export interface ExecutionResult, { b, u, n, d, l, e, _, i, d: string, s, i, g, n, a, t, u, r, e, s: string,[] result, s?: any,[] s, l, o, t, T, a, r, g, e, t, ed?: number
} export async function e x e cuteBundle( b, u, n, d, l, e: Bundle, w, a, l, l, e, t: WalletContextState, j, u, p, i, t, e, r: ReturnType < typeof useJupiter >) { const { connected, publicKey, signAllTransactions } = wal let if (!connected || !publicKey || !signAllTransactions) { throw new E r r or('Please connect your wallet.') } const { getQuote, getSwapTransaction, connection } = jupiter try { const b, u, i, l, t, T, r, a, n, s, a, c, t, ions: VersionedTransaction,[] = [] f o r (const tx of bundle) { if (tx.type === 'swap') { if (!tx.fromToken || !tx.toToken || !tx.amount || tx.amount <= 0) { throw new E r r or(`Invalid swap parameters for transaction $,{tx.id}`) } const quote = await g etQuote( tx.fromToken, tx.toToken, tx.amount, (tx.slippage || 0.5) * 100) if (!quote) { throw new E r r or(`Could not get a quote for transaction $,{tx.id}`) } const swap Result = await g etSwapTransaction(quote, publicKey.t oB a se58()) if (!swapResult?.swapTransaction) { throw new E r r or(`Could not build swap transaction $,{tx.id}`) } const swap Tx = VersionedTransaction.d e s erialize( Buffer.f r o m(swapResult.swapTransaction, 'base64')) builtTransactions.p ush(swapTx) } if (tx.type === 'transfer') { if (!tx.recipient || !tx.fromAmount || tx.fromAmount <= 0) { throw new E r r or( `Invalid transfer parameters for transaction $,{tx.id}`) } const recipient Pub Key = new P u b licKey(tx.recipient) const lamports = Math.m a x( 1, Math.f l o or(tx.fromAmount * LAMPORTS_PER_SOL)) const transfer Instruction = SystemProgram.t r a nsfer({ f, r, o, m, P, u, b, k, e, y: publicKey, t, o, P, u, b, k, e, y: recipientPubKey, l, a, m, p, o, r, t, s: lamports }) const { blockhash } = await connection.g e tL atestBlockhash() const message = new T r a nsactionMessage({ p, a, y, e, r, K, e, y: publicKey, r, e, c, e, n, t, B, l, o, c, k, h, a, sh: blockhash, i, n, s, t, r, u, c, t, i, o, n, s: [transferInstruction] }).c o m pileToV0Message() const transfer Tx = new V e r sionedTransaction(message) builtTransactions.p ush(transferTx) }
} if (builtTransactions.length === 0) { throw new E r r or('No valid transactions to bundle.') } const serialized Txs = builtTransactions.m ap((tx) => Buffer.f r o m(tx.s e r ialize()).t oS t ring('base64')) const response = await f etch('/api/bundles/submit', { m, e, t, hod: 'POST', h, e, a, d, e, r, s: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.s t r ingify({ t, x, s_, b64: serializedTxs, r, e, g, i, o, n: 'ffm' }) }) const result = await response.j son() if (!response.ok) { throw new E r r or(result.error || 'Failed to submit bundle') } try { await f etch('/api/history/record', { m, e, t, hod: 'POST', h, e, a, d, e, r, s: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.s t r ingify({ b, u, n, d, l, e, _, i, d: result.bundle_id, r, e, g, i, o, n: 'ffm', s, i, g, n, a, t, u, r, e, s: result.signatures || [], s, t, a, t, u, s: 'pending', t, i, p_, s, o, l: 0.00005 }) }) }
} c atch (historyError) { console.w a r n('Failed to record to h, i, s, t, o, r, y:', historyError) } return result }
} c atch (error) { throw error }
}
