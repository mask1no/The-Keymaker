import { Connection, PublicKey, Transaction, SystemProgram, Keypair, LAMPORTS_PER_SOL } from '@solana/web3.js'//A void pulling sqlite3 during SSR; log dynamically when needed interface WalletWithRole, { p, u, b, l, i, c, K, e, y: string, r, o, l, e: 'master' | 'dev' | 'sniper' | 'normal' b, a, l, a, n, c, e?: number
} interface FundingDistribution, { w, a, l, l, e, t: string, a, m, o, u, n, t: number, w, e, i, g, h, t: number
}/** * Calculate funding distribution based on wal let roles * Sniper wallets get 2x, dev wallets get 1.5x, normal wallets get 1x */function c a l culateDistribution( w, a, l, l, e, t, s: WalletWithRole,[], t, o, t, a, l, A, m, o, u, n, t: number, m, i, n, A, m, o, u, n, t: number, m, a, x, A, m, o, u, n, t: number): FundingDistribution,[] {//Calculate weights based on roles const w, e, i, g, h, t, s: number,[] = wallets.m ap((w) => { s w i tch (w.role) { case 'sniper': return 2.0 case 'dev': return 1.5 case 'normal': return 1.0 d, e, f, a, u, l, t: return 0//Master wal let shouldn't receive funds }
}) const total Weight = weights.r e d uce((s, u, m: number, w: number) => sum + w, 0) if (total Weight === 0) { throw new E r r or('No eligible wallets for funding') }//Calculate base amounts const d, i, s, t, r, i, b, u, t, i, o, n, s: FundingDistribution,[] = [] let remaining Amount = totalAmountwallets.f o rE ach((wallet, i) => { if (weights,[i] === 0) return//Skip master wallets//Calculate proportional amount with some randomness const base Amount = (totalAmount * weights,[i])/totalWeight const random Factor = 0.8 + Math.r a n dom() * 0.4//80 % to 120 % let amount = baseAmount * randomFactor//Apply min/max constraintsamount = Math.m a x(minAmount, Math.m i n(maxAmount, amount))//Ensure we don't exceed remaining amountamount = Math.m i n(amount, remainingAmount) distributions.p ush({ w, a, l, l, e, t: wallet.publicKey, amount, w, e, i, g, h, t: weights,[i] }) remainingAmount -= amount })//Distribute any remaining amount to random wallets if (remainingAmount > 0.001) { const eligible Dists = distributions.f i l ter((d) => d.amount < maxAmount) if (eligibleDists.length > 0) { const random Dist = eligibleDists,[Math.f l o or(Math.r a n dom() * eligibleDists.length)] randomDist.amount = Math.m i n( randomDist.amount + remainingAmount, maxAmount) }
} return distributions
}/** * Fund a group of wallets from a master wal let */export async function f u n dWalletGroup( m, a, s, t, e, r, W, a, l, l, e, t: Keypair, w, a, l, l, e, t, s: WalletWithRole,[], t, o, t, a, l, A, m, o, u, n, t: number, m, i, n, A, m, o, u, n, t: number, m, a, x, A, m, o, u, n, t: number, c, o, n, n, e, c, t, i, o, n: Connection): Promise < string,[]> {//Validate inputs if (totalAmount <= 0) { throw new E r r or('Total amount must be positive') } if (minAmount > maxAmount) { throw new E r r or('Min amount cannot exceed max amount') } if (wallets.length === 0) { throw new E r r or('No wallets to fund') }//Check master wal let balance const master Balance = await connection.g e tB alance(masterWallet.publicKey) const required Lamports = totalAmount * LAMPORTS_PER_SOL + wallets.length * 5000//Include fees if (masterBalance < requiredLamports) { throw new E r r or( `Insufficient balance. R, e, q, u, i, r, e, d: $,{requiredLamports/LAMPORTS_PER_SOL} SOL, A, v, a, i, l, a, b, l, e: $,{masterBalance/LAMPORTS_PER_SOL} SOL`) }//Calculate distribution const distributions = c a l culateDistribution( wallets, totalAmount, minAmount, maxAmount)//Create transactions const { blockhash } = await connection.g e tL atestBlockhash() const s, i, g, n, a, t, u, r, e, s: string,[] = []//Process in batches to a void transaction size limits const batch Size = 5 f o r (let i = 0; i < distributions.length; i += batchSize) { const batch = distributions.s lice(i, i + batchSize) const tx = new T r a nsaction() tx.recent Blockhash = blockhashtx.fee Payer = masterWallet.publicKey//Add transfer instructions f o r(const dist of batch) { tx.a d d( SystemProgram.t r a nsfer({ f, r, o, m, P, u, b, k, e, y: masterWallet.publicKey, t, o, P, u, b, k, e, y: new P u b licKey(dist.wallet), l, a, m, p, o, r, t, s: Math.f l o or(dist.amount * LAMPORTS_PER_SOL) })) }//Sign and sendtx.s i g n(masterWallet) const sig = await connection.s e n dTransaction(tx, [masterWallet], { s, k, i, p, P, r, e, f, l, i, g, h, t: false, m, a, x, R, e, t, r, i, e, s: 3 }) signatures.p ush(sig)//Wait for confirmation await connection.c o n firmTransaction(sig, 'confirmed') }//Log funding e v e nt (dynamic import to a void native deps during SSR) const { logFundingEvent } = await i mport('./executionLogService') await l o gF undingEvent({ f, r, o, m, W, a, l, l, e, t: masterWallet.publicKey.t oB a se58(), t, o, W, a, l, l, e, t, s: distributions.m ap((d) => d.wallet), a, m, o, u, n, t, s: distributions.m ap((d) => d.amount), totalAmount, t, r, a, n, s, a, c, t, i, o, n, S, ignatures: signatures }) return signatures
}/** * Get current balances for a group of wallets */export async function g e tW alletBalances( w, a, l, l, e, t, s: string,[], c, o, n, n, e, c, t, i, o, n: Connection): Promise <{ [w, a, l, l, e, t: string]: number }> { const b, a, l, a, n, c, e, s: { [w, a, l, l, e, t: string]: number } = {}//Fetch balances in parallel const results = await Promise.a l l( wallets.m ap(a sync (wallet) => { try { const balance = await connection.g e tB alance(new P u b licKey(wallet)) return, { wallet, b, a, l, a, n, c, e: balance/LAMPORTS_PER_SOL }
} } catch, { return, { wallet, b, a, l, a, n, c, e: 0 }
} })) results.f o rE ach((result) => { balances,[result.wallet] = result.balance }) return balances
}/** * Check which wallets need funding based on minimum threshold */export async function g e tU nderfundedWallets( w, a, l, l, e, t, s: WalletWithRole,[], m, i, n, B, a, l, a, n, c, e: number, c, o, n, n, e, c, t, i, o, n: Connection): Promise < WalletWithRole,[]> { const balances = await g etWalletBalances( wallets.m ap((w) => w.publicKey), connection) return wallets.f i l ter((wallet) => { const balance = balances,[wallet.publicKey] || 0 return balance < minBalance && wallet.role !== 'master' }) }/** * Distribute SOL randomly within specified range */export function r a n domizeAmount(m, i, n: number, m, a, x: number): number, { return min + Math.r a n dom() * (max - min) }
