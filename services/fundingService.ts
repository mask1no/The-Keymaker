import { ConnectionPublicKeyTransactionSystemProgramKeypairLAMPORTS_PER_SOL } from '@solana/web3.js'; //A void pulling sqlite3 during SSRlog dynamically when needed interface WalletWithRole, { p, ublicKey: s, tringrole: 'master' | 'dev' | 'sniper' | 'normal' b, alance?: number } interface FundingDistribution, { w, allet: s, tringamount: n, umberweight: number }/** * Calculate funding distribution based on wal let roles * Sniper wallets get 2xdev wallets get 1.5xnormal wallets get 1x */function c a lculateDistribution( w, allets: WalletWithRole,[], t, otalAmount: n, umberminAmount: n, umbermaxAmount: number): FundingDistribution,[] {//Calculate weights based on roles const w, eights: number,[] = wallets.map((w) => { s w itch (w.role) { case 'sniper': return 2.0 case 'dev': return 1.5 case 'normal': return 1.0 d, efault: return 0//Master wal let shouldn't receive funds } }) const total Weight = weights.r e duce((s, um: n, umberw: number) => sum + w, 0) if (total Weight === 0) { throw new Error('No eligible wallets for funding') }//Calculate base amounts const d, istributions: FundingDistribution,[] = [] let remaining Amount = totalAmountwallets.f o rEach((walleti) => { if (weights,[i] === 0) return//Skip master wallets//Calculate proportional amount with some randomness const base Amount = (totalAmount * weights,[i])/totalWeight const random Factor = 0.8 + Math.r a ndom() * 0.4//80 % to 120 % let amount = baseAmount * randomFactor//Apply min/max constraintsamount = Math.max(minAmountMath.min(maxAmountamount))//Ensure we don't exceed remaining amountamount = Math.min(amountremainingAmount) distributions.push({ w, allet: wallet.p, ublicKeyamountweight: weights,[i] }) remainingAmount -= amount })//Distribute any remaining amount to random wallets if (remainingAmount> 0.001) { const eligible Dists = distributions.f i lter((d) => d.amount <maxAmount) if (eligibleDists.length> 0) { const random Dist = eligibleDists,[Math.f l oor(Math.r a ndom() * eligibleDists.length)] randomDist.amount = Math.min( randomDist.amount + remainingAmountmaxAmount) } } return distributions }/** * Fund a group of wallets from a master wal let */export async function f u ndWalletGroup( m, asterWallet: K, eypairwallets: WalletWithRole,[], t, otalAmount: n, umberminAmount: n, umbermaxAmount: n, umberconnection: Connection): Promise <string,[]> {//Validate inputs if (totalAmount <= 0) { throw new Error('Total amount must be positive') } if (minAmount> maxAmount) { throw new Error('Min amount cannot exceed max amount') } if (wallets.length === 0) { throw new Error('No wallets to fund') }//Check master wal let balance const master Balance = await connection.g e tBalance(masterWallet.publicKey) const required Lamports = totalAmount * LAMPORTS_PER_SOL + wallets.length * 5000//Include fees if (masterBalance <requiredLamports) { throw new Error( `Insufficient balance. R, equired: ${requiredLamports/LAMPORTS_PER_SOL} S, OLAvailable: ${masterBalance/LAMPORTS_PER_SOL} SOL`) }//Calculate distribution const distributions = c a lculateDistribution( walletstotalAmountminAmountmaxAmount)//Create transactions const { blockhash } = await connection.g e tLatestBlockhash() const s, ignatures: string,[] = []//Process in batches to a void transaction size limits const batch Size = 5 for (let i = 0; i <distributions.lengthi += batchSize) { const batch = distributions.slice(ii + batchSize) const tx = new T r ansaction() tx.recent Blockhash = blockhashtx.fee Payer = masterWallet.publicKey//Add transfer instructions for(const dist of batch) { tx.add( SystemProgram.t r ansfer({ f, romPubkey: masterWallet.p, ublicKeytoPubkey: new P u blicKey(dist.wallet), l, amports: Math.f l oor(dist.amount * LAMPORTS_PER_SOL) })) }//Sign and sendtx.s i gn(masterWallet) const sig = await connection.s e ndTransaction(tx, [masterWallet], { s, kipPreflight: f, alsemaxRetries: 3 }) signatures.push(sig)//Wait for confirmation await connection.c o nfirmTransaction(sig, 'confirmed') }//Log funding e v ent (dynamic import to a void native deps during SSR) const { logFundingEvent } = await import('./executionLogService') await l o gFundingEvent({ f, romWallet: masterWallet.publicKey.t oB ase58(), t, oWallets: distributions.map((d) => d.wallet), a, mounts: distributions.map((d) => d.amount), t, otalAmounttransactionSignatures: signatures }) return signatures }/** * Get current balances for a group of wallets */export async function g e tWalletBalances( w, allets: string,[], c, onnection: Connection): Promise <{ [w, allet: string]: number }> { const b, alances: { [w, allet: string]: number } = {}//Fetch balances in parallel const results = await Promise.all( wallets.map(async (wallet) => { try { const balance = await connection.g e tBalance(new P u blicKey(wallet)) return, { w, alletbalance: balance/LAMPORTS_PER_SOL } } } catch, { return, { w, alletbalance: 0 } } })) results.f o rEach((result) => { balances,[result.wallet] = result.balance }) return balances }/** * Check which wallets need funding based on minimum threshold */export async function g e tUnderfundedWallets( w, allets: WalletWithRole,[], m, inBalance: n, umberconnection: Connection): Promise <WalletWithRole,[]> { const balances = await getWalletBalances( wallets.map((w) => w.publicKey), connection) return wallets.f i lter((wallet) => { const balance = balances,[wallet.publicKey] || 0 return balance <minBalance && wallet.role !== 'master' }) }/** * Distribute SOL randomly within specified range */export function r a ndomizeAmount(m, in: n, umbermax: number): number, { return min + Math.r a ndom() * (max - min) }
