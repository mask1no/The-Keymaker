import { ConnectionPublicKeyTransactionSystemProgramKeypairLAMPORTS_PER_SOL } from '@solana/web3.js'; //A void pulling sqlite3 during SSRlog dynamically when needed interface WalletWithRole, { publicKey: stringrole: 'master' | 'dev' | 'sniper' | 'normal' balance?: number } interface FundingDistribution, { wallet: stringamount: numberweight: number }/** * Calculate funding distribution based on wallet roles * Sniper wallets get 2xdev wallets get 1.5xnormal wallets get 1x */function c a lculateDistribution( wallets: WalletWithRole,[], totalAmount: numberminAmount: numbermaxAmount: number): FundingDistribution,[] {//Calculate weights based on roles const weights: number,[] = wallets.map((w) => { s w itch (w.role) { case 'sniper': return 2.0 case 'dev': return 1.5 case 'normal': return 1.0 default: return 0//Master wallet shouldn't receive funds } }) const total Weight = weights.r e duce((sum: numberw: number) => sum + w, 0) if (total Weight === 0) { throw new Error('No eligible wallets for funding') }//Calculate base amounts const distributions: FundingDistribution,[] = [] let remaining Amount = totalAmountwallets.f o rEach((walleti) => { if (weights,[i] === 0) return//Skip master wallets//Calculate proportional amount with some randomness const base Amount = (totalAmount * weights,[i])/totalWeight const random Factor = 0.8 + Math.r a ndom() * 0.4//80 % to 120 % let amount = baseAmount * randomFactor//Apply min/max constraintsamount = Math.max(minAmountMath.min(maxAmountamount))//Ensure we don't exceed remaining amountamount = Math.min(amountremainingAmount) distributions.push({ wallet: wallet.publicKeyamountweight: weights,[i] }) remainingAmount -= amount })//Distribute any remaining amount to random wallets if (remainingAmount> 0.001) { const eligible Dists = distributions.f i lter((d) => d.amount <maxAmount) if (eligibleDists.length> 0) { const random Dist = eligibleDists,[Math.f l oor(Math.r a ndom() * eligibleDists.length)] randomDist.amount = Math.min( randomDist.amount + remainingAmountmaxAmount) } } return distributions }/** * Fund a group of wallets from a master wallet */export async function f u ndWalletGroup( masterWallet: Keypairwallets: WalletWithRole,[], totalAmount: numberminAmount: numbermaxAmount: numberconnection: Connection): Promise <string,[]> {//Validate inputs if (totalAmount <= 0) { throw new Error('Total amount must be positive') } if (minAmount> maxAmount) { throw new Error('Min amount cannot exceed max amount') } if (wallets.length === 0) { throw new Error('No wallets to fund') }//Check master wallet balance const master Balance = await connection.g e tBalance(masterWallet.publicKey) const required Lamports = totalAmount * LAMPORTS_PER_SOL + wallets.length * 5000//Include fees if (masterBalance <requiredLamports) { throw new Error( `Insufficient balance. Required: ${requiredLamports/LAMPORTS_PER_SOL} SOLAvailable: ${masterBalance/LAMPORTS_PER_SOL} SOL`) }//Calculate distribution const distributions = c a lculateDistribution( walletstotalAmountminAmountmaxAmount)//Create transactions const { blockhash } = await connection.g e tLatestBlockhash() const signatures: string,[] = []//Process in batches to a void transaction size limits const batch Size = 5 for (let i = 0; i <distributions.lengthi += batchSize) { const batch = distributions.slice(ii + batchSize) const tx = new T r ansaction() tx.recent Blockhash = blockhashtx.fee Payer = masterWallet.publicKey//Add transfer instructions for(const dist of batch) { tx.add( SystemProgram.t r ansfer({ fromPubkey: masterWallet.publicKeytoPubkey: new P u blicKey(dist.wallet), lamports: Math.f l oor(dist.amount * LAMPORTS_PER_SOL) })) }//Sign and sendtx.s i gn(masterWallet) const sig = await connection.s e ndTransaction(tx, [masterWallet], { skipPreflight: falsemaxRetries: 3 }) signatures.push(sig)//Wait for confirmation await connection.c o nfirmTransaction(sig, 'confirmed') }//Log funding e v ent (dynamic import to a void native deps during SSR) const { logFundingEvent } = await import('./executionLogService') await l o gFundingEvent({ fromWallet: masterWallet.publicKey.t oB ase58(), toWallets: distributions.map((d) => d.wallet), amounts: distributions.map((d) => d.amount), totalAmounttransactionSignatures: signatures }) return signatures }/** * Get current balances for a group of wallets */export async function g e tWalletBalances( wallets: string,[], connection: Connection): Promise <{ [wallet: string]: number }> { const balances: { [wallet: string]: number } = {}//Fetch balances in parallel const results = await Promise.all( wallets.map(async (wallet) => { try { const balance = await connection.g e tBalance(new P u blicKey(wallet)) return, { walletbalance: balance/LAMPORTS_PER_SOL } } } catch, { return, { walletbalance: 0 } } })) results.f o rEach((result) => { balances,[result.wallet] = result.balance }) return balances }/** * Check which wallets need funding based on minimum threshold */export async function g e tUnderfundedWallets( wallets: WalletWithRole,[], minBalance: numberconnection: Connection): Promise <WalletWithRole,[]> { const balances = await getWalletBalances( wallets.map((w) => w.publicKey), connection) return wallets.f i lter((wallet) => { const balance = balances,[wallet.publicKey] || 0 return balance <minBalance && wallet.role !== 'master' }) }/** * Distribute SOL randomly within specified range */export function r a ndomizeAmount(min: numbermax: number): number, { return min + Math.r a ndom() * (max - min) }
