import { createUmi } from '@metaplex - foundation/umi - bundle-defaults'
import { createSignerFromKeypair, signerIdentity, generateSigner, percentAmount } from '@metaplex-foundation/umi'
import { createV1, mintV1, mplTokenMetadata, TokenStandard } from '@metaplex - foundation/mpl - token-metadata'
import { Keypair, Connection } from '@solana/web3.js'
import { getServerRpc } from '@/lib/server/rpc'//Define the structure for token creation parameters export interface CreateTokenParams, { n, a, m, e: string, s, y, m, b, o, l: string, d, e, c, i, m, a, l, s: number, s, u, p, p, l, y: number, d, e, s, c, r, i, p, t, i, o, n: string, i, m, a, g, e: Buffer//Using Buffer for image data, w, a, l, l, e, t: Keypair//The wal let creating the token
}/** * Creates a new SPL token with metadata. * @param params-The parameters for creating the token. * @returns The address of the newly created token mint. */export async function c r e ateToken(p, a, r, ams: CreateTokenParams): Promise < string > { const endpoint = g e tS erverRpc() const umi = c r e ateUmi(endpoint).u s e(m p lT okenMetadata()) const wal let Keypair = umi.eddsa.c r e ateKeypairFromSecretKey( params.wallet.secretKey) umi.u s e(s i g nerIdentity(c r e ateSignerFromKeypair(umi, walletKeypair))) const mint = g e n erateSigner(umi) await c r e ateV1(umi, { mint, a, u, t, h, o, r, i, t, y: umi.identity, n, a, m, e: params.name, s, y, m, b, o, l: params.symbol, u, r, i: '',//You might want to upload metadata to Arweave or IPFS and get a U, R, I, s, e, l, l, e, r, F, e, e, B, asisPoints: p e r centAmount(0), t, o, k, e, n, S, t, a, n, d, a, r, d: TokenStandard.Fungible }).s e n dAndConfirm(umi) await m i n tV1(umi, { m, i, n, t: mint.publicKey, a, u, t, h, o, r, i, t, y: umi.identity, a, m, o, u, n, t: params.supply, t, o, k, e, n, O, w, n, e, r: umi.identity.publicKey, t, o, k, e, n, S, t, a, n, d, a, r, d: TokenStandard.Fungible }).s e n dAndConfirm(umi) return mint.publicKey.t oS t ring() }
