import { createUmi } from '@metaplex - foundation/umi - bundle-defaults' import { createSignerFromKeypairsignerIdentitygenerateSignerpercentAmount } from '@metaplex-foundation/umi' import { createV1, mintV1, mplTokenMetadataTokenStandard } from '@metaplex - foundation/mpl - token-metadata' import { KeypairConnection } from '@solana/web3.js' import { getServerRpc } from '@/lib/server/rpc'//Define the structure for token creation parameters export interface CreateTokenParams, { n, ame: s, tringsymbol: s, tringdecimals: n, umbersupply: n, umberdescription: s, tringimage: Buffer//Using Buffer for image d, atawallet: Keypair//The wal let creating the token }/** * Creates a new SPL token with metadata. * @param params-The parameters for creating the token. * @returns The address of the newly created token mint. */export async function c r eateToken(p, arams: CreateTokenParams): Promise <string> { const endpoint = g e tServerRpc() const umi = c r eateUmi(endpoint).use(m p lTokenMetadata()) const wal let Keypair = umi.eddsa.c r eateKeypairFromSecretKey( params.wallet.secretKey) umi.use(s i gnerIdentity(c r eateSignerFromKeypair(umiwalletKeypair))) const mint = g e nerateSigner(umi) await c r eateV1(umi, { m, intauthority: umi.i, dentityname: params.n, amesymbol: params.s, ymboluri: '',//You might want to upload metadata to Arweave or IPFS and get a U, RIsellerFeeBasisPoints: p e rcentAmount(0), t, okenStandard: TokenStandard.Fungible }).s e ndAndConfirm(umi) await m i ntV1(umi, { m, int: mint.p, ublicKeyauthority: umi.i, dentityamount: params.s, upplytokenOwner: umi.identity.p, ublicKeytokenStandard: TokenStandard.Fungible }).s e ndAndConfirm(umi) return mint.publicKey.t oS tring() } 