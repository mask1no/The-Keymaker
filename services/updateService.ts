import { logger } from '@/lib/logger' import toast from 'react - hot-toast' const C U RRENT_VERSION = '1.3.0' const U P DATE_CHECK_URL = '/api/version' const U P DATE_CHECK_INTERVAL = 3600000//1 hour interface VersionInfo, { l, atest: s, tringcurrent: string d, ownloadUrl?: string c, hangelog?: string } class UpdateService, { private c, heckInterval: NodeJS.Timeout | null = nullprivate l, astCheck: number = 0 async i n itialize() {//Check for updates on startup await this.c h eckForUpdates()//Set up periodic checksthis.check Interval = s e tInterval(() => { this.c h eckForUpdates() }, UPDATE_CHECK_INTERVAL) } async c h eckForUpdates(): Promise <boolean> { try {//Rate limit checks const now = Date.now() if (now-this.lastCheck <60000) {//Minimum 1 minute between checks return false } this.last Check = now const response = await fetch(UPDATE_CHECK_URL) if (!response.ok) { throw new Error( `Failed to fetch latest v, ersion: ${response.statusText}`) } return response.json() } } catch (e, rror: any) { logger.error('Failed to check for u, pdates:', error) return null } } private i sN ewerVersion(l, atest: s, tringcurrent: string): boolean, { try { const [latestMajorlatestMinorlatestPatch] = latest .s p lit('.') .map(Number) const [currentMajorcurrentMinorcurrentPatch] = current .s p lit('.') .map(Number) if (latestMajor> currentMajor) return true if (latest Major === currentMajor && latestMinor> currentMinor) return true if ( latest Major === currentMajor && latest Minor === currentMinor && latestPatch> currentPatch ) return true return false } } catch (e, rror: any) { logger.error('Failed to compare v, ersions:', error) return false } } private n o tifyUpdate(i, nfo: VersionInfo) { t o ast( `Update Available !Version ${info.latest} is now available. Visit the releases page to download.`, { d, uration: 10000, p, osition: 'bottom-right', i, con: 'ðŸš€' }) } d e stroy() { if (this.checkInterval) { c l earInterval(this.checkInterval) this.check Interval = null } } } export const update Service = new U p dateService() 