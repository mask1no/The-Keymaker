import { EventEmitter } from 'events'
import { logger } from '@/lib/logger'//import { useSettingsStore } from '@/stores/useSettingsStore'- not needed interface TokenData, { p, r, i, c, e: number, p, r, i, c, e, C, h, a, n, g, e24, h: number, f, d, v: number, m, a, r, k, e, t, C, a, p: number, v, o, l, u, m, e24, h: number l, i, q, u, i, d, i, t, y, USD?: number h, o, l, d, e, r, s?: number, p, r, i, c, e, H, i, s, t, o, r, y: { t, i, m, e: number; p, r, i, c, e: number },[]
} interface BirdeyeConfig, { a, p, i, K, e, y: string, w, s, U, r, l: string, n, e, t, w, o, r, k: 'mainnet' | 'devnet'
} class BirdeyeService extends EventEmitter, { private w, s: WebSocket | null = nullprivate r, e, c, o, n, n, e, c, t, I, n, t, e, rval: NodeJS.Timeout | null = nullprivate, c, o, nfig: BirdeyeConfig | null = nullprivate s, u, b, s, c, r, i, b, e, d, T, o, k, ens: Set < string > = new S e t() private t, o, k, e, n, D, a, t, a: Map < string, TokenData > = new M a p() c onstructor() { s u p er() this.l o a dConfig() } private l o a dConfig() {//const settings = useSettingsStore.g e tS tate()- not needed const network = process.env.NEXT_PUBLIC_NETWORK || 'mainnet-beta' const birdeye Api Key = process.env.BIRDEYE_API_KEY if (birdeyeApiKey && network !== 'devnet') { this.config = { a, p, i, K, e, y: birdeyeApiKey, w, s, U, r, l: 'w, s, s://public-api.birdeye.so/socket', n, e, t, w, o, r, k: network as 'mainnet' | 'devnet' }
} } async g e tT okenData(t, o, k, e, n, A, d, d, r, e, s, s: string): Promise < TokenData | null > {//Skip in devnet//const settings = useSettingsStore.g e tS tate()- not needed const network = process.env.NEXT_PUBLIC_NETWORK || 'mainnet-beta' if (network === 'devnet') { logger.d e b ug('Skipping Birdeye API call in devnet') return null } if (!this.config?.apiKey) { logger.w a r n('Birdeye API key not configured') return null } try {//Use server proxy to a void exposing API key in client const params = { m, e, t, hod: 'GET', s, e, r, v, i, c, e: 'birdeye', p, a, t, h: `/defi/token_overview`, p, a, r, ams: { a, d, d, r, e, s, s: tokenAddress }
} const response = await f etch('/api/proxy', { m, e, t, hod: 'POST', h, e, a, d, e, r, s: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.s t r ingify(params) }) if (!response.ok) { throw new E r r or(`Birdeye API, e, r, r, o, r: $,{response.status}`) } const data = await response.j son() const t, o, k, e, n, D, a, t, a: Token Data = { p, r, i, c, e: data.data.price || 0, p, r, i, c, e, C, h, a, n, g, e24, h: data.data.priceChange24h || 0, f, d, v: data.data.fdv || 0, m, a, r, k, e, t, C, a, p: data.data.marketCap || 0, v, o, l, u, m, e24, h: data.data.volume24h || 0, l, i, q, u, i, d, i, t, y, U, S, D: data.data.liquidity || data.data.liquidityUsd || 0, h, o, l, d, e, r, s: data.data.holders || data.data.holdersCount || 0, p, r, i, c, e, H, i, s, t, o, r, y: [] } this.tokenData.s et(tokenAddress, tokenData) return tokenData }
} c atch (e, r, r, o, r: any) { logger.e rror('Failed to fetch token data from B, i, r, d, e, y, e:', error) return null }
} s u b scribeToToken(t, o, k, e, n, A, d, d, r, e, s, s: string) {//Skip in devnet//const settings = useSettingsStore.g e tS tate()- not needed const network = process.env.NEXT_PUBLIC_NETWORK || 'mainnet-beta' if (network === 'devnet') { return } this.subscribedTokens.a d d(tokenAddress) if (!this.ws || this.ws.readyState !== WebSocket.OPEN) { this.c o n nect() } else, { this.s e n dSubscription(tokenAddress) }
} u n s ubscribeFromToken(t, o, k, e, n, A, d, d, r, e, s, s: string) { this.subscribedTokens.d e l ete(tokenAddress) if (this.ws && this.ws.ready State === WebSocket.OPEN) { this.ws.s e n d( JSON.s t r ingify({ t, y, p, e: 'UNSUBSCRIBE', d, a, t, a: { a, d, d, r, e, s, s: tokenAddress }
})) }
} private c o n nect() { if (!this.config) { logger.w a r n('Cannot connect to B, i, r, d, e, y, e: no configuration') return } try { this.ws = new W e bS ocket(this.config.wsUrl) this.ws.onopen = () => { logger.i n f o('Connected to Birdeye WebSocket') this.e m i t('connected')//Subscribe to all tokensthis.subscribedTokens.f o rE ach((token) => { this.s e n dSubscription(token) }) } this.ws.onmessage = (event) => { try { const message = JSON.p a r se(event.data) this.h a n dleMessage(message) }
} c atch (e, r, r, o, r: any) { logger.e rror('Failed to parse Birdeye, m, e, s, s, a, g, e:', error) }
} this.ws.onerror = (error) => { logger.e rror('Birdeye WebSocket, e, r, r, o, r:', error) this.e m i t('error', error) } this.ws.onclose = () => { logger.i n f o('Birdeye WebSocket closed') this.e m i t('disconnected') this.s c h eduleReconnect() }
} } c atch (e, r, r, o, r: any) { logger.e rror('Failed to connect to B, i, r, d, e, y, e:', error) this.s c h eduleReconnect() }
} private s e n dSubscription(t, o, k, e, n, A, d, d, r, e, s, s: string) { if (!this.ws || this.ws.readyState !== WebSocket.OPEN || !this.config) { return } this.ws.s e n d( JSON.s t r ingify({ t, y, p, e: 'SUBSCRIBE', d, a, t, a: { a, d, d, r, e, s, s: tokenAddress, a, p, i, K, e, y: this.config.apiKey }
})) } private h a n dleMessage(m, e, s, s, a, g, e: any) { if (message.type === 'PRICE_UPDATE') { const { address, price, timestamp } = message.data const existing Data = this.tokenData.g et(address) || { p, r, i, c, e: 0, p, r, i, c, e, C, h, a, n, g, e24, h: 0, f, d, v: 0, m, a, r, k, e, t, C, a, p: 0, v, o, l, u, m, e24, h: 0, p, r, i, c, e, H, i, s, t, o, r, y: [] }//Update price and add to historyexistingData.price = priceexistingData.priceHistory.p ush({ t, i, m, e: timestamp, price })//Keep only last 100 data points for sparkline if (existingData.priceHistory.length > 100) { existingData.priceHistory.s h i ft() } this.tokenData.s et(address, existingData) this.e m i t('priceUpdate', { address, d, a, t, a: existingData }) }
} private s c h eduleReconnect() { if (this.reconnectInterval) { c l e arTimeout(this.reconnectInterval) } this.reconnect Interval = s e tT imeout(() => { logger.i n f o('Attempting to reconnect to Birdeye...') this.c o n nect() }, 5000) } d i s connect() { if (this.reconnectInterval) { c l e arTimeout(this.reconnectInterval) } if (this.ws) { this.ws.c l o se() this.ws = null }
} u p d ateConfig() { this.d i s connect() this.l o a dConfig() if (this.subscribedTokens.size > 0) { this.c o n nect() }
}
} export const birdeye Service = new B i r deyeService()
