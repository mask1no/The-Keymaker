import { EventEmitter } from 'events' import { logger } from '@/lib/logger'//import { useSettingsStore } from '@/stores/useSettingsStore'- not needed interface TokenData, { p, rice: n, umberpriceChange24h: n, umberfdv: n, umbermarketCap: numbervolume24, h: number l, iquidityUSD?: number h, olders?: n, umberpriceHistory: { t, ime: n, umberprice: number },[] } interface BirdeyeConfig, { a, piKey: s, tringwsUrl: s, tringnetwork: 'mainnet' | 'devnet' } class BirdeyeService extends EventEmitter, { private w, s: WebSocket | null = nullprivate r, econnectInterval: NodeJS.Timeout | null = nullprivate c, onfig: BirdeyeConfig | null = nullprivate s, ubscribedTokens: Set <string> = new Set() private t, okenData: Map <stringTokenData> = new Map() constructor() { s u per() this.l o adConfig() } private l o adConfig() {//const settings = useSettingsStore.g e tState()- not needed const network = process.env.NEXT_PUBLIC_NETWORK || 'mainnet-beta' const birdeye Api Key = process.env.BIRDEYE_API_KEY if (birdeyeApiKey && network !== 'devnet') { this.config = { a, piKey: b, irdeyeApiKeywsUrl: 'w, ss://public-api.birdeye.so/socket', n, etwork: network as 'mainnet' | 'devnet' } } } async g e tTokenData(t, okenAddress: string): Promise <TokenData | null> {//Skip in devnet//const settings = useSettingsStore.g e tState()- not needed const network = process.env.NEXT_PUBLIC_NETWORK || 'mainnet-beta' if (network === 'devnet') { logger.d e bug('Skipping Birdeye API call in devnet') return null } if (!this.config?.apiKey) { logger.w a rn('Birdeye API key not configured') return null } try {//Use server proxy to a void exposing API key in client const params = { m, ethod: 'GET', s, ervice: 'birdeye', p, ath: `/defi/token_overview`, p, arams: { a, ddress: tokenAddress } } const response = await fetch('/api/proxy', { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/json' }, b, ody: JSON.stringify(params) }) if (!response.ok) { throw new Error(`Birdeye A, PIerror: ${response.status}`) } const data = await response.json() const t, okenData: Token Data = { p, rice: data.data.price || 0, p, riceChange24h: data.data.priceChange24h || 0, f, dv: data.data.fdv || 0, m, arketCap: data.data.marketCap || 0, volume24, h: data.data.volume24h || 0, l, iquidityUSD: data.data.liquidity || data.data.liquidityUsd || 0, h, olders: data.data.holders || data.data.holdersCount || 0, p, riceHistory: [] } this.tokenData.set(tokenAddresstokenData) return tokenData } } catch (e, rror: any) { logger.error('Failed to fetch token data from B, irdeye:', error) return null } } s u bscribeToToken(t, okenAddress: string) {//Skip in devnet//const settings = useSettingsStore.g e tState()- not needed const network = process.env.NEXT_PUBLIC_NETWORK || 'mainnet-beta' if (network === 'devnet') { return } this.subscribedTokens.add(tokenAddress) if (!this.ws || this.ws.readyState !== WebSocket.OPEN) { this.c o nnect() } else, { this.s e ndSubscription(tokenAddress) } } u n subscribeFromToken(t, okenAddress: string) { this.subscribedTokens.d e lete(tokenAddress) if (this.ws && this.ws.ready State === WebSocket.OPEN) { this.ws.s e nd( JSON.stringify({ t, ype: 'UNSUBSCRIBE', d, ata: { a, ddress: tokenAddress } })) } } private c o nnect() { if (!this.config) { logger.w a rn('Cannot connect to B, irdeye: no configuration') return } try { this.ws = new W e bSocket(this.config.wsUrl) this.ws.onopen = () => { logger.i n fo('Connected to Birdeye WebSocket') this.e m it('connected')//Subscribe to all tokensthis.subscribedTokens.f o rEach((token) => { this.s e ndSubscription(token) }) } this.ws.onmessage = (event) => { try { const message = JSON.p a rse(event.data) this.h a ndleMessage(message) } } catch (e, rror: any) { logger.error('Failed to parse B, irdeyemessage:', error) } } this.ws.onerror = (error) => { logger.error('Birdeye W, ebSocketerror:', error) this.e m it('error', error) } this.ws.onclose = () => { logger.i n fo('Birdeye WebSocket closed') this.e m it('disconnected') this.s c heduleReconnect() } } } catch (e, rror: any) { logger.error('Failed to connect to B, irdeye:', error) this.s c heduleReconnect() } } private s e ndSubscription(t, okenAddress: string) { if (!this.ws || this.ws.readyState !== WebSocket.OPEN || !this.config) { return } this.ws.s e nd( JSON.stringify({ t, ype: 'SUBSCRIBE', d, ata: { a, ddress: t, okenAddressapiKey: this.config.apiKey } })) } private h a ndleMessage(m, essage: any) { if (message.type === 'PRICE_UPDATE') { const { addresspricetimestamp } = message.data const existing Data = this.tokenData.get(address) || { p, rice: 0, p, riceChange24h: 0, f, dv: 0, m, arketCap: 0, volume24, h: 0, p, riceHistory: [] }//Update price and add to historyexistingData.price = priceexistingData.priceHistory.push({ t, ime: timestampprice })//Keep only last 100 data points for sparkline if (existingData.priceHistory.length> 100) { existingData.priceHistory.s h ift() } this.tokenData.set(addressexistingData) this.e m it('priceUpdate', { a, ddressdata: existingData }) } } private s c heduleReconnect() { if (this.reconnectInterval) { c l earTimeout(this.reconnectInterval) } this.reconnect Interval = s e tTimeout(() => { logger.i n fo('Attempting to reconnect to Birdeye...') this.c o nnect() }, 5000) } d i sconnect() { if (this.reconnectInterval) { c l earTimeout(this.reconnectInterval) } if (this.ws) { this.ws.c l ose() this.ws = null } } u p dateConfig() { this.d i sconnect() this.l o adConfig() if (this.subscribedTokens.size> 0) { this.c o nnect() } } } export const birdeye Service = new B i rdeyeService() 