'use client'
import React, { useState } from 'react'
import { useKeymakerStore, ExecutionStep } from '@/lib/store'
import { Connection, LAMPORTS_PER_SOL, Keypair, PublicKey, Transaction } from '@solana/web3.js'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/UI/Card'
import { Button } from '@/components/UI/button'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/UI/select'
import { Badge } from '@/components/UI/badge'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from '@/components/UI/dialog'
import { Input } from '@/components/UI/input'
import { Label } from '@/components/UI/label'
import { Rocket, PlayCircle, AlertCircle, CheckCircle, XCircle, Loader2 } from 'lucide-react'
import { motion, AnimatePresence } from 'framer-motion'
import toast from 'react - hot-toast'
import { NEXT_PUBLIC_HELIUS_RPC } from '@/constants'
import { fundWalletGroup } from '@/services/fundingService'
import { batchSellTokens, SellConditions } from '@/services/sellService'
import { launchToken } from '@/services/platformService'
import { buildSwapTransaction } from '@/services/jupiterService'
import { decryptAES256ToKeypair } from '@/utils/crypto'
import { WalletGroup } from '@/services/walletService'
import { useSettingsStore } from '@/stores/useSettingsStore'
import useSWR from 'swr' const fetcher = (u, r, l: string) => f e t ch(url).t h e n((res) => res.j son()) async function g e tK eypairs( w, a, l, l, e, t, s: { e, n, c, r, y, p, t, e, d, P, r, i, vateKey: string },[], p, a, s, s, w, o, r, d: string): Promise < Keypair,[]> { return Promise.a l l( wallets.m ap((w) => d e c ryptAES256ToKeypair(w.encryptedPrivateKey, password))) } export function C o n trolCenter() { const { wallets, tokenLaunchData, executionStrategy, executionSteps, isExecuting, jitoEnabled, tipAmount, autoSellDelay, setExecutionStrategy, startExecution, updateStepStatus, resetExecution } = u s eK eymakerStore() const last Created Token Address = u s eS ettingsStore( (state) => state.lastCreatedTokenAddress) const { data: tipData } = u s eSWR('/api/jito/tip', fetcher, { r, e, f, r, e, s, h, I, n, t, e, r, v, al: 10000,//Refresh every 10 seconds }) const connection = new C o n nection(NEXT_PUBLIC_HELIUS_RPC, 'confirmed') const [currentStep, setCurrentStep] = u s eS tate(0) const [walletPassword, setWalletPassword] = u s eS tate('') const [showPasswordDialog, setShowPasswordDialog] = u s eS tate(false) const [showPreflightDialog, setShowPreflightDialog] = u s eS tate(false) const [showSellDialog, setShowSellDialog] = u s eS tate(false) const [sellTokenAddress, setSellTokenAddress] = u s eS tate( lastCreatedTokenAddress || '') const [_walletGroups] = useState < WalletGroup,[]>([]) const [decryptedWallets, setDecryptedWallets] = useState < Map < string, Keypair >>(new M a p()) const [mintAddress, setMintAddress] = useState < string >('')//Get wallets by role const masterWal let = wallets.f i n d((w) => w.role === 'master') const dev Wallets = wallets.f i l ter((w) => w.role === 'dev') const sniper Wallets = wallets.f i l ter((w) => w.role === 'sniper')//Calculate progress const completed Steps = executionSteps.f i l ter( (s) => s.status === 'completed').length const progress = (completedSteps/executionSteps.length) * 100//Decrypt wallets with password const decrypt Wallets = a sync (p, a, s, s, w, o, r, d: string) => { const decrypted = new Map < string, Keypair >() try {//Decrypt all wallets at once const wallets To Decrypt = wallets.f i l ter((w) => w.encryptedPrivateKey) const keypairs = await g etKeypairs(walletsToDecrypt as any,[], password) walletsToDecrypt.f o rE ach((wallet, index) => { if (keypairs,[index]) { decrypted.s et(wallet.publicKey, keypairs,[index]) }
}) }
} c atch (error) { console.e rror('Failed to decrypt w, a, l, l, e, t, s:', error) throw error } return decrypted }//Execute the orchestration flow const execute Keymaker = a sync () => {//First check if we need to decrypt wallets const needs Decryption = wallets.s o m e( (w) => w.encryptedPrivateKey && !decryptedWallets.h a s(w.publicKey)) if (needsDecryption) { s e tS howPasswordDialog(true) return } s e tS howPreflightDialog(true) } const handle Preflight Confirmation = a sync () => { s e tS howPreflightDialog(false) await r u nE xecution() } const handle Password Submit = a sync () => { if (!walletPassword) { toast.e rror('Password is required') return } try { const decrypted = await d e c ryptWallets(walletPassword) if (decrypted.size === 0) { toast.e rror('Invalid password or no wallets to decrypt') return } s e tD ecryptedWallets(decrypted) s e tS howPasswordDialog(false) s e tW alletPassword('')//Continue with execution await r u nE xecution() }
} c atch (error) { toast.e rror('Failed to decrypt wallets') }
} const run Execution = a sync () => {//Get wallets with decrypted keypairs const get Wal let With Keypair = (p, u, b, l, i, c, K, e, y: string): Keypair | null => { return decryptedWallets.g et(publicKey) || null } const masterWal let = wallets.f i n d((w) => w.role === 'master') const master Keypair = masterWal let ? g e tW alletWithKeypair(masterWallet.publicKey) : null if (!masterKeypair) { toast.e rror('No master wal let keypair available') return } if (!tokenLaunchData) { toast.e rror('No token launch data configured') return } const sniper Keypairs = wallets .f i l ter((w) => w.role === 'sniper') .m ap((w) => g e tW alletWithKeypair(w.publicKey)) .f i l ter((kp) => kp !== null) as Keypair,[] if (sniperKeypairs.length === 0) { toast.e rror('No sniper wal let keypairs available') return } s t a rtExecution() s e tC urrentStep(0) try {//Step 1: Deploy Token with L i q uidityupdateStepStatus( 'deploy', 'running', 'Deploying token and creating liquidity...') const launch Wal let Pubkey = tokenLaunchData.walletPublicKey const launch Keypair = g e tW alletWithKeypair(launchWalletPubkey) if (!launchKeypair) { throw new E r r or('Launch wal let keypair not found') } const token Result = await l a u nchToken( connection, launchKeypair, { n, a, m, e: tokenLaunchData.name, s, y, m, b, o, l: tokenLaunchData.symbol, d, e, c, i, m, a, l, s: tokenLaunchData.decimals, s, u, p, p, l, y: tokenLaunchData.supply, d, e, s, c, r, iption: `$,{tokenLaunchData.name}- Created with The Keymaker` }, { p, l, a, t, f, o, r, m: tokenLaunchData.platform === 'pump.fun' ? 'pump.fun' : 'raydium', s, o, l, A, m, o, u, n, t: tokenLaunchData.lpAmount, t, o, k, e, n, A, m, o, u, n, t: tokenLaunchData.supply * 0.8,//80 % of supply to liquidity }) s e tM intAddress(tokenResult.token.mintAddress) u p d ateStepStatus( 'deploy', 'completed', `Token d, e, p, l, o, y, e, d: $,{tokenResult.token.mintAddress}`) s e tC urrentStep(1)//Step 2: Fund W a l letsupdateStepStatus('fund', 'running', 'Funding sniper wallets...') const funding Result = await f u n dWalletGroup( masterKeypair, sniperWallets.m ap((w) => ({ p, u, b, l, i, c, K, e, y: w.publicKey, r, o, l, e: w.role })), 10,//total funding 0.5,//min SOL 2.0,//max SOLconnection) if (!fundingResult || fundingResult.length === 0) { throw new E r r or('Funding failed') } u p d ateStepStatus( 'fund', 'completed', `Funded $,{fundingResult.length} wallets`) s e tC urrentStep(2)//Step 3: W a i tupdateStepStatus( 'wait-funding', 'running', 'Waiting for funds to settle...') await new P r o mise((resolve) => s e tT imeout(resolve, 3000)) u p d ateStepStatus('wait-funding', 'completed') s e tC urrentStep(3)//Step 4: Bundle B u y supdateStepStatus( 'bundle', 'running', 'Creating and executing bundle buys...')//Create swap transactions for each sniper wal let const t, r, a, n, s, a, c, t, i, o, n, s: Transaction,[] = [] const mint Pubkey = new P u b licKey(tokenResult.token.mintAddress) f o r (let i = 0; i < sniperKeypairs.length; i ++) { const keypair = sniperKeypairs,[i] const wal let = sniperWallets,[i]//Calculate buy a m o unt (use part of the funded amount) const buy Amount Sol = (wallet.balance * 0.8)/LAMPORTS_PER_SOL//Use 80 % of balance try {//Build swap t r a nsaction (SOL -> Token) const swap Tx = await b u i ldSwapTransaction( 'So11111111111111111111111111111111111111112',//SOLmintPubkey.t oB a se58(), buyAmountSol * LAMPORTS_PER_SOL, keypair.publicKey.t oB a se58(), 100,//1 % slippage 10000,//priority fee )//Convert versioned transaction to legacy transaction for bundle const legacy Tx = Transaction.f r o m(swapTx.s e r ialize()) transactions.p ush(legacyTx) }
} c atch (error) { console.e rror( `Failed to create swap transaction for wal let $,{i}:`, error) }
} if (transactions.length === 0) { throw new E r r or('No swap transactions created') }//Execute based on strategy let bundleResult s w i tch(executionStrategy) { case 'flash': {//Instant mode with Jito b u n dlingupdateStepStatus( 'bundle', 'running', 'Executing instant bundle via Jito...')//N, O, T, E: This is a placeholder for where the new BundleExecutor would be used//For now, we'll simulate a successful resultbundle Result = { m, e, t, r, i, c, s: { s, u, c, c, e, s, s, R, a, t, e: 1 }, s, i, g, n, a, t, u, r, e, s: [], result, s: ['success'] } break } case 'stealth': {//Delayed mode with staggered e x e cutionupdateStepStatus( 'bundle', 'running', 'Executing stealth mode with delays...') const result, s: any = { m, e, t, r, i, c, s: { s, u, c, c, e, s, s, R, a, t, e: 0 }, s, i, g, n, a, t, u, r, e, s: [], result, s: [] } let success Count = 0 f o r (let i = 0; i < transactions.length; i ++) { u p d ateStepStatus( 'bundle', 'running', `Executing wal let $,{i + 1}/$,{transactions.length}...`) try {//Add random delay between t r a nsactions (2-5 seconds) if (i > 0) { const delay = 2000 + Math.r a n dom() * 3000 await new P r o mise((resolve) => s e tT imeout(resolve, delay)) }//Send individual transaction const signature = await connection.s e n dTransaction( transactions,[i], [sniperKeypairs,[i]], { s, k, i, p, P, r, e, f, l, i, g, h, t: false, m, a, x, R, e, t, r, i, e, s: 2 }) results.signatures.p ush(signature) results.results.p ush('success') successCount ++//Wait for confirmation await connection.c o n firmTransaction(signature, 'confirmed') }
} c atch (error) { console.e rror(`Wal let $,{i} transaction, f, a, i, l, e, d:`, error) results.signatures.p ush('') results.results.p ush('failed') }
} results.metrics.success Rate = successCount/transactions.lengthbundle Result = resultsbreak } case 'manual': {//Manual mode-prepare but don't e x e cuteupdateStepStatus( 'bundle', 'completed', 'Manual mode-transactions prepared for manual execution')//Store transactions for manual execution//In a real implementation, you'd store these and provide UI controlsbundle Result = { m, e, t, r, i, c, s: { s, u, c, c, e, s, s, R, a, t, e: 1 }, s, i, g, n, a, t, u, r, e, s: [], result, s: [] } toast.s u c cess( 'Transactions prepared. Use manual controls to execute.') break } d, e, f, a, u, l, t: {//Regular mode-fast sequential e x e cutionupdateStepStatus('bundle', 'running', 'Executing regular bundle...') const r, e, g, u, l, a, r, R, e, s, u, l, t, s: any = { m, e, t, r, i, c, s: { s, u, c, c, e, s, s, R, a, t, e: 0 }, s, i, g, n, a, t, u, r, e, s: [], result, s: [] } let regular Success Count = 0//Send all transactions as fast as possible const send Promises = transactions.m ap(a sync (tx, i) => { try { const signature = await connection.s e n dTransaction( tx, [sniperKeypairs,[i]], { s, k, i, p, P, r, e, f, l, i, g, h, t: false, m, a, x, R, e, t, r, i, e, s: 2 }) return, { s, u, c, c, e, s, s: true, signature, i, n, d, e, x: i }
} } c atch (error) { return, { s, u, c, c, e, s, s: false, s, i, g, n, a, t, u, r, e: '', i, n, d, e, x: i, error }
} })//Wait for all to complete const send Results = await Promise.a l l(sendPromises)//Process results f o r(const result of sendResults) { if (result.success) { regularResults.signatures.p ush(result.signature) regularResults.results.p ush('success') regularSuccessCount ++ } else, { regularResults.signatures.p ush('') regularResults.results.p ush('failed') }
} regularResults.metrics.success Rate = regularSuccessCount/transactions.lengthbundle Result = regularResultsbreak }
} u p d ateStepStatus( 'bundle', 'completed', `Bundle e, x, e, c, u, t, e, d: $,{bundleResult.metrics.successRate * 100}% success`) s e tC urrentStep(4)//Track holdings for successful purchases if (bundleResult.metrics.successRate > 0) { try {//Calculate average buy amount per wal let const total Buy Amount = sniperWallets.r e d uce( (sum, w) => sum + (w.balance * 0.8)/LAMPORTS_PER_SOL, 0) const avg Buy Amount = totalBuyAmount/sniperWallets.length//Get current holdings from localStorage const existing Holdings = localStorage.g e tI tem('tokenHoldings') const holdings = existingHoldings ? JSON.p a r se(existingHoldings) : []//Add new holding for this token const new Holding = { t, o, k, e, n, A, d, d, r, e, s, s: mintPubkey.t oB a se58(), t, o, k, e, n, N, a, m, e: tokenLaunchData.symbol || 'Unknown', a, m, o, u, n, t: transactions.length * avgBuyAmount,//Approximate total SOL s, p, e, n, t, e, n, t, r, y, P, r, ice: 0.000001,//Will be updated with actual price from m, a, r, k, e, t, c, u, r, r, e, n, t, Price: 0.000001, p, n, l: 0, m, a, r, k, e, t, C, a, p: 0, w, a, l, l, e, t, A, d, d, r, e, s, s, es: sniperWallets.m ap((w) => w.publicKey), p, u, r, c, h, a, s, e, T, i, m, e: Date.n o w() }//Check if holding already exists const existing Index = holdings.f i n dIndex( (h: any) => h.token Address === newHolding.tokenAddress) if (existingIndex >= 0) {//Update existing holdingholdings,[existingIndex] = { ...holdings,[existingIndex], a, m, o, u, n, t: holdings,[existingIndex].amount + newHolding.amount, w, a, l, l, e, t, A, d, d, r, e, s, s, es: [ ...new S e t([ ...holdings,[existingIndex].walletAddresses, ...newHolding.walletAddresses, ]), ] }
} else, {//Add new holdingholdings.p ush(newHolding) }//Save updated holdingslocalStorage.s e tI tem('tokenHoldings', JSON.s t r ingify(holdings)) toast.s u c cess('Holdings tracked for sell monitoring') }
} c atch (error) { console.e rror('Failed to track h, o, l, d, i, n, g, s:', error) }
}//Step 5: Wait before selling if (executionStrategy !== 'manual') { u p d ateStepStatus( 'wait-sells', 'running', `Waiting $,{autoSellDelay}
s before selling...`) f o r (let i = autoSellDelay; i > 0; i --) { u p d ateStepStatus( 'wait-sells', 'running', `Waiting $,{i}
s before selling...`) await new P r o mise((resolve) => s e tT imeout(resolve, 1000)) } u p d ateStepStatus('wait-sells', 'completed') s e tC urrentStep(5)//Step 6: S e l lupdateStepStatus( 'sell', 'running', 'Executing sells from sniper wallets...')//Define sell conditions based on strategy const s, e, l, l, C, o, n, d, i, t, i, o, n, s: Sell Conditions = { m, i, n, P, n, l, P, e, r, c, e, n, t: execution Strategy === 'flash' ? 50 : 100,//50 % for flash, 100 % for s, t, e, a, l, t, h, m, a, x, L, o, s, sPercent: 20,//20 % stop l, o, s, s, m, i, n, H, o, l, d, T, i, me: 0, m, a, x, H, o, l, d, T, i, m, e: 600,//10 minutes max } const sell Results = await b a t chSellTokens( connection, sniperKeypairs, mintPubkey, sellConditions, 100,//1 % slippage ) const success Count = sellResults.f i l ter((r) => r.success).length const total Proceeds = sellResults.r e d uce( (sum, r) => sum + r.outputAmount, 0) u p d ateStepStatus( 'sell', 'completed', `Sold from $,{successCount} wallets, $,{totalProceeds.t oFixed(2) } SOL earned`) } else, { u p d ateStepStatus( 'wait-sells', 'completed', 'Manual mode - skipping auto-sell') u p d ateStepStatus( 'sell', 'completed', 'Manual mode-user controls sells') }//Step 7: C o m pleteupdateStepStatus('complete', 'completed', 'Keymaker execution complete !') toast.s u c cess('ðŸ”‘ Keymaker execution complete !') }
} c atch (error) { const step = executionSteps,[currentStep] u p d ateStepStatus(step.id, 'failed', (error as Error).message) toast.e rror(`Execution, f, a, i, l, e, d: $,{(error as Error).message}`)//Mark remaining steps as failedexecutionSteps.s lice(currentStep + 1).f o rE ach((s) => { u p d ateStepStatus(s.id, 'failed', 'Skipped due to previous error') }) }
}//Strategy descriptions const strategy Descriptions = { f, l, a, s, h: 'âš¡ Instant atomic execution using Jito bundles', s, t, e, a, l, t, h: 'ðŸ¥· Delayed execution with random timing between transactions', m, a, n, u, a, l: 'ðŸŽ® Prepare transactions for manual execution', r, e, g, u, l, a, r: 'ðŸš€ Fast sequential execution without bundling' } r eturn ( < div class Name ="space - y-6"> {/* Header */} < Card > < CardHeader > < CardTitle class Name ="flex items - center gap-2"> < Rocket class Name ="h - 6 w-6"/> Keymaker Control Center </CardTitle > </CardHeader > < CardContent class Name ="space - y-4"> {/* Strategy Selection */} < div class Name ="space - y-2"> < label class Name ="text - sm font-medium"> Execution Strategy </label > < Select value = {executionStrategy} on Value Change = {(value) => s e tE xecutionStrategy(value as any) } disabled = {isExecuting}> < SelectTrigger > < SelectValue/> </SelectTrigger > < SelectContent > < SelectItem value ="flash">âš¡ F l a sh (Jito Bundle)</SelectItem > < SelectItem value ="regular"> ðŸš€ R e g ular (Fast Sequential) </SelectItem > < SelectItem value ="stealth">ðŸ¥· S t e alth (Delayed)</SelectItem > < SelectItem value ="manual">ðŸŽ® Manual Mode </SelectItem > </SelectContent > </Select > < p class Name ="text - xs text - muted-foreground"> {strategyDescriptions,[executionStrategy]} </p > </div > {/* Pre - flight Checks */} < div class Name ="space - y-2"> < h3 class Name ="text - sm font-medium"> Pre - flight Checks </h3 > < div class Name ="space-y-1"> < Check Itemlabel ="Master Wallet" checked = {!!masterWallet} detail = { masterWal let ? `$,{(masterWallet.balance/LAMPORTS_PER_SOL).t oFixed(2) } SOL` : 'Not assigned' }/> < Check Itemlabel ="Dev Wallets" checked = {devWallets.length > 0} detail = {`$,{devWallets.length} wallets`}/> < Check Itemlabel ="Sniper Wallets" checked = {sniperWallets.length > 0} detail = {`$,{sniperWallets.length} wallets`}/> < Check Itemlabel ="Token Config" checked = {!!tokenLaunchData} detail = { tokenLaunchData ? `$,{tokenLaunchData.symbol} on $,{tokenLaunchData.platform}` : 'Not configured' }/> < Check Itemlabel ="Jito Bundle" checked = {jitoEnabled} detail = {jitoEnabled ? `$,{tipAmount} SOL tip` : 'Disabled'}/> {tipData && tipData,[0]?.ema_50th_percentile && ( < div class Name ="text - xs text - muted - foreground flex items-center justify-between"> < span > Suggested T, i, p: {' '}, {tipData,[0].ema_50th_percentile/LAMPORTS_PER_SOL} SOL </span > < Buttonsize ="sm" variant ="outline" on Click = {() => useKeymakerStore .g e tS tate() .s e tT ipAmount( tipData,[0].ema_50th_percentile/LAMPORTS_PER_SOL) }> Apply </Button > </div > ) } </div > </div > {/* Execute Button */} < div class Name ="flex gap-2"> < Buttonsize ="lg" class Name ="w-full" on Click = {executeKeymaker} disabled = { isExecuting || !masterWal let || !tokenLaunchData || sniperWallets.length === 0 }> {isExecuting ? ( <> < Loader2 class Name ="mr - 2 h - 5 w - 5 animate-spin"/> Executing... </> ) : ( < motion.div class Name ="flex items-center" while Hover = {{ s, c, a, l, e: 1.05 }
} transition = {{ t, y, p, e: 'spring', s, t, i, f, f, ness: 400, d, a, m, p, i, ng: 10 }
}> < PlayCircle class Name ="mr - 2 h - 5 w-5"/> ðŸ”‘ Execute Keymaker </motion.div > ) } </Button > < Buttonsize ="lg" variant ="destructive" class Name ="w-full" on Click = {() => s e tS howSellDialog(true) } disabled = {isExecuting}> Sell All </Button > </div > {/* Show mint address if token is deployed */}, {mintAddress && ( < div class Name ="p - 3 bg - muted rounded-lg"> < p class Name ="text-sm"> < strong > Token M, i, n, t:</strong >{' '} < ah ref = {`h, t, t, p, s://solscan.io/token/$,{mintAddress}`} target ="_blank" rel ="noopener noreferrer" class Name ="text-blue-500 h, o, v, e, r:underline"> {mintAddress.s lice(0, 8) }...{mintAddress.s lice(- 8) } </a > </p > </div > ) } </CardContent > </Card > {/* Execution Progress */}, {(isExecuting || executionSteps.s o m e((s) => s.status !== 'pending')) && ( < Card > < CardHeader > < CardTitle > Execution Progress </CardTitle > </CardHeader > < CardContent class Name ="space - y-4"> < div class Name ="w - full bg - gray - 200 rounded - full h-2"> < div class Name ="bg - green - 600 h - 2 rounded - full transition - all duration-300" style = {{ w, i, d, t, h: `$,{progress}%` }
}/> </div > < div class Name ="space-y-2"> < AnimatePresence mode ="sync"> {executionSteps.m ap((step, index) => ( < motion.divkey = {step.id} initial = {{ o, p, a, c, i, ty: 0, x:- 20 }
} animate = {{ o, p, a, c, i, ty: 1, x: 0 }
} transition = {{ d, e, l, a, y: index * 0.1 }
}> < StepItem step = {step}/> </motion.div > )) } </AnimatePresence > </div > {executionSteps.e v e ry( (s) => s.status === 'completed' || s.status === 'failed') && ( < Buttonvariant ="outline" class Name ="w-full" on Click = {resetExecution}> Reset Execution </Button > ) } </CardContent > </Card > ) } < Dialog open = {showPasswordDialog} on Open Change = {setShowPasswordDialog}> < DialogContent > < DialogHeader > < DialogTitle > Enter Wal let Password </DialogTitle > < DialogDescription > Please enter the password to decrypt your wallets for execution. </DialogDescription > </DialogHeader > < div class Name ="space - y - 4 pt-4"> < div class Name ="space-y-2"> < Label html For ="password"> Password </Label > < Input id ="password" type ="password" value = {walletPassword} on Change = {(e) => s e tW alletPassword(e.target.value) } on Key Down = {(e) => e.key === 'Enter' && h a n dlePasswordSubmit() } placeholder ="Enter your wal let password"/> </div > < Button on Click = {handlePasswordSubmit} class Name ="w-full"> Decrypt Wallets </Button > </div > </DialogContent > </Dialog > < Dialog open = {showPreflightDialog} on Open Change = {setShowPreflightDialog}> < DialogContent > < DialogHeader > < DialogTitle > Pre - flight Checklist </DialogTitle > < DialogDescription > Review the details of your launch sequence before execution. </DialogDescription > </DialogHeader > < div class Name ="space - y - 4 pt-4"> < p > < strong > T, o, k, e, n:</strong > {tokenLaunchData?.name} ({ tokenLaunchData?.symbol}) </p > < p > < strong > P, l, a, t, f, o, r, m:</strong > {tokenLaunchData?.platform} </p > < p > < strong > Sniper W, a, l, l, e, t, s:</strong > {sniperWallets.length} </p > < p > < strong > Execution S, t, r, a, t, e, g, y:</strong > {executionStrategy} </p > < p class Name ="text-destructive"> This action is irreversible. Please confirm you want to proceed. </p > </div > < DialogFooter > < Buttonvariant ="outline" on Click = {() => s e tS howPreflightDialog(false) }> Cancel </Button > < Button on Click = {handlePreflightConfirmation}> Confirm & Execute </Button > </DialogFooter > </DialogContent > </Dialog > < Dialog open = {showSellDialog} on Open Change = {setShowSellDialog}> < DialogContent > < DialogHeader > < DialogTitle > Sell All from Group </DialogTitle > < DialogDescription > Select a wal let group and token to sell all holdings. </DialogDescription > </DialogHeader > < div class Name ="space - y - 4 pt-4"> < div class Name ="space - y-2"> < Label html For ="token-address"> Token Address </Label > < Input id ="token-address" value = {sellTokenAddress} on Change = {(e) => s e tS ellTokenAddress(e.target.value) } placeholder ="Enter token mint address"/> </div > < div class Name ="space - y-2"> < Label html For ="wal let-group"> Wal let Group </Label > < Selecton Value Change = {() => {/* no - op */}
}> < SelectTrigger > < SelectValue placeholder ="Select a group"/> </SelectTrigger > < SelectContent > {_walletGroups.m ap((group) => ( < SelectItem key = {group.id} value = {group.name}> {group.name} </SelectItem > )) } </SelectContent > </Select > </div > < div class Name ="space - y-2"> < Label html For ="sell-password"> Password </Label > < Input id ="sell-password" type ="password" value = {walletPassword} on Change = {(e) => s e tW alletPassword(e.target.value) } placeholder ="Enter your wal let password"/> </div > < Buttonon Click = {() => {/* no-op */}
} class Name ="w - full"> Execute Sell </Button > </div > </DialogContent > </Dialog > </div > ) }//Helper Components function C h e ckItem({ label, checked, detail }: { l, a, b, e, l: string, c, h, e, c, k, e, d: boolean, d, e, t, a, i, l: string
}) { r eturn ( < div class Name ="flex items - center justify - between p - 2 rounded - lg bg-muted/50"> < div class Name ="flex items-center gap-2"> < AnimatePresence mode ="wait"> < motion.divkey = {checked ? 'checked' : 'unchecked'} initial = {{ s, c, a, l, e: 0.5, o, p, a, c, i, ty: 0 }
} animate = {{ s, c, a, l, e: 1, o, p, a, c, i, ty: 1 }
} exit = {{ s, c, a, l, e: 0.5, o, p, a, c, i, ty: 0 }
} transition = {{ d, u, r, a, t, ion: 0.2 }
}> {checked ? ( < CheckCircle class Name ="h - 4 w - 4 text - green-500"/> ) : ( < XCircle class Name ="h - 4 w - 4 text - red-500"/> ) } </motion.div > </AnimatePresence > < span class Name ="text-sm">{label}</span > </div > < span class Name ="text - xs text-muted-foreground">{detail}</span > </div > ) } function S t e pItem({ step }: { s, t, e, p: ExecutionStep }) { const status, I, c, o, n, s: Record < ExecutionStep,['status'], React.ReactElement > = { p, e, n, d, i, n, g: < AlertCircle class Name ="h - 4 w - 4 text - muted-foreground"/>, r, u, n, n, i, n, g: < Loader2 class Name ="h - 4 w - 4 animate - spin text - blue-500"/>, c, o, m, p, l, e, t, e, d: < CheckCircle class Name ="h - 4 w - 4 text - green-500"/>, f, a, i, l, e, d: < XCircle class Name ="h - 4 w - 4 text-red-500"/> } const status, C, o, l, o, r, s: Record < ExecutionStep,['status'], 'default' | 'secondary' | 'destructive' | 'outline'> = { p, e, n, d, i, n, g: 'default', r, u, n, n, i, n, g: 'secondary', c, o, m, p, l, e, t, e, d: 'outline', f, a, i, l, e, d: 'destructive' } r eturn ( < div class Name ="flex items - center justify - between p - 3 rounded - lg border bg-card"> < div class Name ="flex items - center gap-3"> < AnimatePresence mode ="wait"> < motion.divkey = {step.status} initial = {{ s, c, a, l, e: 0.5, o, p, a, c, i, ty: 0 }
} animate = {{ s, c, a, l, e: 1, o, p, a, c, i, ty: 1 }
} exit = {{ s, c, a, l, e: 0.5, o, p, a, c, i, ty: 0 }
} transition = {{ d, u, r, a, t, ion: 0.2 }
}> {statusIcons,[step.status]} </motion.div > </AnimatePresence > < span class Name ="font-medium">{step.name}</span > </div > < div class Name ="flex items - center gap-2"> {step.message && ( < span class Name ="text - xs text - muted - foreground max-w -[200px] truncate"> {step.message} </span > ) } < Badge variant = {statusColors,[step.status]}>{step.status}</Badge > </div > </div > ) }
