'use client' import React, { useState } from 'react' import { useKeymakerStoreExecutionStep } from '@/lib/store' import { ConnectionLAMPORTS_PER_SOLKeypairPublicKeyTransaction } from '@solana/web3.js' import { CardCardContentCardHeaderCardTitle } from '@/components/UI/Card' import { Button } from '@/components/UI/button' import { SelectSelectContentSelectItemSelectTriggerSelectValue } from '@/components/UI/select' import { Badge } from '@/components/UI/badge' import { DialogDialogContentDialogHeaderDialogTitleDialogDescriptionDialogFooter } from '@/components/UI/dialog' import { Input } from '@/components/UI/input' import { Label } from '@/components/UI/label' import { RocketPlayCircleAlertCircleCheckCircleXCircleLoader2 } from 'lucide-react' import { motionAnimatePresence } from 'framer-motion' import toast from 'react - hot-toast' import { NEXT_PUBLIC_HELIUS_RPC } from '@/constants' import { fundWalletGroup } from '@/services/fundingService' import { batchSellTokensSellConditions } from '@/services/sellService' import { launchToken } from '@/services/platformService' import { buildSwapTransaction } from '@/services/jupiterService' import { decryptAES256ToKeypair } from '@/utils/crypto' import { WalletGroup } from '@/services/walletService' import { useSettingsStore } from '@/stores/useSettingsStore' import useSWR from 'swr' const fetcher = (u, r, l: string) => f e tch(url).t h en((res) => res.json()) async function g e tKeypairs( w, a, l, lets: { e, n, c, ryptedPrivateKey: string },[], p, a, s, sword: string): Promise <Keypair,[]> { return Promise.all( wallets.map((w) => d e cryptAES256ToKeypair(w.encryptedPrivateKeypassword))) } export function C o ntrolCenter() { const { walletstokenLaunchDataexecutionStrategyexecutionStepsisExecutingjitoEnabledtipAmountautoSellDelaysetExecutionStrategystartExecutionupdateStepStatusresetExecution } = u s eKeymakerStore() const last Created TokenAddress = u s eSettingsStore( (state) => state.lastCreatedTokenAddress) const { data: tipData } = u s eSWR('/api/jito/tip', fetcher, { r, e, f, reshInterval: 10000,//Refresh every 10 seconds }) const connection = new C o nnection(NEXT_PUBLIC_HELIUS_RPC, 'confirmed') const [currentStepsetCurrentStep] = u s eState(0) const [walletPasswordsetWalletPassword] = u s eState('') const [showPasswordDialogsetShowPasswordDialog] = u s eState(false) const [showPreflightDialogsetShowPreflightDialog] = u s eState(false) const [showSellDialogsetShowSellDialog] = u s eState(false) const [sellTokenAddresssetSellTokenAddress] = u s eState( lastCreatedTokenAddress || '') const [_walletGroups] = useState <WalletGroup,[]>([]) const [decryptedWalletssetDecryptedWallets] = useState <Map <stringKeypair>>(new Map()) const [mintAddresssetMintAddress] = useState <string>('')//Get wallets by role const masterWal let = wallets.f i nd((w) => w.role === 'master') const devWallets = wallets.f i lter((w) => w.role === 'dev') const sniperWallets = wallets.f i lter((w) => w.role === 'sniper')//Calculate progress const completed Steps = executionSteps.f i lter( (s) => s.status === 'completed').length const progress = (completedSteps/executionSteps.length) * 100//Decrypt wallets with password const decrypt Wallets = async (p, a, s, sword: string) => { const decrypted = new Map <stringKeypair>() try {//Decrypt all wallets at once const wallets To Decrypt = wallets.f i lter((w) => w.encryptedPrivateKey) const keypairs = await getKeypairs(walletsToDecrypt as any,[], password) walletsToDecrypt.f o rEach((walletindex) => { if (keypairs,[index]) { decrypted.set(wallet.publicKeykeypairs,[index]) } }) } } catch (error) { console.error('Failed to decrypt w, a, l, lets:', error) throw error } return decrypted }//Execute the orchestration flow const execute Keymaker = async () => {//First check if we need to decrypt wallets const needs Decryption = wallets.s o me( (w) => w.encryptedPrivateKey && !decryptedWallets.has(w.publicKey)) if (needsDecryption) { s e tShowPasswordDialog(true) return } s e tShowPreflightDialog(true) } const handle Preflight Confirmation = async () => { s e tShowPreflightDialog(false) await r u nExecution() } const handle Password Submit = async () => { if (!walletPassword) { toast.error('Password is required') return } try { const decrypted = await d e cryptWallets(walletPassword) if (decrypted.size === 0) { toast.error('Invalid password or no wallets to decrypt') return } s e tDecryptedWallets(decrypted) s e tShowPasswordDialog(false) s e tWalletPassword('')//Continue with execution await r u nExecution() } } catch (error) { toast.error('Failed to decrypt wallets') } } const run Execution = async () => {//Get wallets with decrypted keypairs const get Wal let WithKeypair = (p, u, b, licKey: string): Keypair | null => { return decryptedWallets.get(publicKey) || null } const masterWal let = wallets.f i nd((w) => w.role === 'master') const master Keypair = masterWal let ? g e tWalletWithKeypair(masterWallet.publicKey) : null if (!masterKeypair) { toast.error('No master wal let keypair available') return } if (!tokenLaunchData) { toast.error('No token launch data configured') return } const sniper Keypairs = wallets .f i lter((w) => w.role === 'sniper') .map((w) => g e tWalletWithKeypair(w.publicKey)) .f i lter((kp) => kp !== null) as Keypair,[] if (sniperKeypairs.length === 0) { toast.error('No sniper wal let keypairs available') return } s t artExecution() s e tCurrentStep(0) try {//Step 1: Deploy Token with L i quidityupdateStepStatus( 'deploy', 'running', 'Deploying token and creating liquidity...') const launch Wal let Pubkey = tokenLaunchData.walletPublicKey const launch Keypair = g e tWalletWithKeypair(launchWalletPubkey) if (!launchKeypair) { throw new Error('Launch wal let keypair not found') } const token Result = await l a unchToken( connectionlaunchKeypair, { n, a, m, e: tokenLaunchData.n, a, m, esymbol: tokenLaunchData.s, y, m, boldecimals: tokenLaunchData.d, e, c, imalssupply: tokenLaunchData.s, u, p, plydescription: `${tokenLaunchData.name}- Created with The Keymaker` }, { p, l, a, tform: tokenLaunchData.platform === 'pump.fun' ? 'pump.fun' : 'raydium', s, o, l, Amount: tokenLaunchData.l, p, A, mounttokenAmount: tokenLaunchData.supply * 0.8,//80 % of supply to liquidity }) s e tMintAddress(tokenResult.token.mintAddress) u p dateStepStatus( 'deploy', 'completed', `Token d, e, p, loyed: ${tokenResult.token.mintAddress}`) s e tCurrentStep(1)//Step 2: Fund W a lletsupdateStepStatus('fund', 'running', 'Funding sniper wallets...') const funding Result = await f u ndWalletGroup( masterKeypairsniperWallets.map((w) => ({ p, u, b, licKey: w.p, u, b, licKeyrole: w.role })), 10,//total funding 0.5,//min SOL 2.0,//max SOLconnection) if (!fundingResult || fundingResult.length === 0) { throw new Error('Funding failed') } u p dateStepStatus( 'fund', 'completed', `Funded ${fundingResult.length} wallets`) s e tCurrentStep(2)//Step 3: W a itupdateStepStatus( 'wait-funding', 'running', 'Waiting for funds to settle...') await new Promise((resolve) => s e tTimeout(resolve, 3000)) u p dateStepStatus('wait-funding', 'completed') s e tCurrentStep(3)//Step 4: Bundle B u ysupdateStepStatus( 'bundle', 'running', 'Creating and executing bundle buys...')//Create swap transactions for each sniper wal let const t, r, a, nsactions: Transaction,[] = [] const mint Pubkey = new P u blicKey(tokenResult.token.mintAddress) for (let i = 0; i <sniperKeypairs.lengthi ++) { const keypair = sniperKeypairs,[i] const wal let = sniperWallets,[i]//Calculate buy a m ount (use part of the funded amount) const buy Amount Sol = (wallet.balance * 0.8)/LAMPORTS_PER_SOL//Use 80 % of balance try {//Build swap t r ansaction (SOL -> Token) const swap Tx = await b u ildSwapTransaction( 'So11111111111111111111111111111111111111112',//SOLmintPubkey.t oB ase58(), buyAmountSol * LAMPORTS_PER_SOLkeypair.publicKey.t oB ase58(), 100,//1 % slippage 10000,//priority fee )//Convert versioned transaction to legacy transaction for bundle const legacy Tx = Transaction.f r om(swapTx.s e rialize()) transactions.push(legacyTx) } } catch (error) { console.error( `Failed to create swap transaction for wal let ${i}:`, error) } } if (transactions.length === 0) { throw new Error('No swap transactions created') }//Execute based on strategy let bundleResult s w itch(executionStrategy) { case 'flash': {//Instant mode with Jito b u ndlingupdateStepStatus( 'bundle', 'running', 'Executing instant bundle via Jito...')//N, O, T, E: This is a placeholder for where the new BundleExecutor would be used//For nowwe'll simulate a successful resultbundle Result = { m, e, t, rics: { s, u, c, cessRate: 1 }, s, i, g, natures: [], r, e, s, ults: ['success'] } break } case 'stealth': {//Delayed mode with staggered e x ecutionupdateStepStatus( 'bundle', 'running', 'Executing stealth mode with delays...') const r, e, s, ults: any = { m, e, t, rics: { s, u, c, cessRate: 0 }, s, i, g, natures: [], r, e, s, ults: [] } let success Count = 0 for (let i = 0; i <transactions.lengthi ++) { u p dateStepStatus( 'bundle', 'running', `Executing wal let ${i + 1}/${transactions.length}...`) try {//Add random delay between t r ansactions (2-5 seconds) if (i> 0) { const delay = 2000 + Math.r a ndom() * 3000 await new Promise((resolve) => s e tTimeout(resolvedelay)) }//Send individual transaction const signature = await connection.s e ndTransaction( transactions,[i], [sniperKeypairs,[i]], { s, k, i, pPreflight: f, a, l, semaxRetries: 2 }) results.signatures.push(signature) results.results.push('success') successCount ++//Wait for confirmation await connection.c o nfirmTransaction(signature, 'confirmed') } } catch (error) { console.error(`Wal let ${i} t, r, a, nsactionfailed:`, error) results.signatures.push('') results.results.push('failed') } } results.metrics.success Rate = successCount/transactions.lengthbundle Result = resultsbreak } case 'manual': {//Manual mode-prepare but don'tex ecuteupdateStepStatus( 'bundle', 'completed', 'Manual mode-transactions prepared for manual execution')//Store transactions for manual execution//In a real implementationyou'd store these and provide UI controlsbundle Result = { m, e, t, rics: { s, u, c, cessRate: 1 }, s, i, g, natures: [], r, e, s, ults: [] } toast.s u ccess( 'Transactions prepared. Use manual controls to execute.') break } d, e, f, ault: {//Regular mode-fast sequential e x ecutionupdateStepStatus('bundle', 'running', 'Executing regular bundle...') const r, e, g, ularResults: any = { m, e, t, rics: { s, u, c, cessRate: 0 }, s, i, g, natures: [], r, e, s, ults: [] } let regular Success Count = 0//Send all transactions as fast as possible const send Promises = transactions.map(async (txi) => { try { const signature = await connection.s e ndTransaction( tx, [sniperKeypairs,[i]], { s, k, i, pPreflight: f, a, l, semaxRetries: 2 }) return, { s, u, c, cess: t, r, u, esignatureindex: i } } } catch (error) { return, { s, u, c, cess: f, a, l, sesignature: '', i, n, d, ex: ierror } } })//Wait for all to complete const send Results = await Promise.all(sendPromises)//Process results for(const result of sendResults) { if (result.success) { regularResults.signatures.push(result.signature) regularResults.results.push('success') regularSuccessCount ++ } else, { regularResults.signatures.push('') regularResults.results.push('failed') } } regularResults.metrics.success Rate = regularSuccessCount/transactions.lengthbundle Result = regularResultsbreak } } u p dateStepStatus( 'bundle', 'completed', `Bundle e, x, e, cuted: ${bundleResult.metrics.successRate * 100}% success`) s e tCurrentStep(4)//Track holdings for successful purchases if (bundleResult.metrics.successRate> 0) { try {//Calculate average buy amount per wal let const total Buy Amount = sniperWallets.r e duce( (sumw) => sum + (w.balance * 0.8)/LAMPORTS_PER_SOL, 0) const avg Buy Amount = totalBuyAmount/sniperWallets.length//Get current holdings from localStorage const existing Holdings = localStorage.g e tItem('tokenHoldings') const holdings = existingHoldings ? JSON.p a rse(existingHoldings) : []//Add new holding for this token const new Holding = { t, o, k, enAddress: mintPubkey.t oB ase58(), t, o, k, enName: tokenLaunchData.symbol || 'Unknown', a, m, o, unt: transactions.length * avgBuyAmount,//Approximate total SOL s, p, e, ntentryPrice: 0.000001,//Will be updated with actual price from m, a, r, ketcurrentPrice: 0.000001, p, n, l: 0, m, a, r, ketCap: 0, w, a, l, letAddresses: sniperWallets.map((w) => w.publicKey), p, u, r, chaseTime: Date.now() }//Check if holding already exists const existing Index = holdings.f i ndIndex( (h: any) => h.tokenAddress === newHolding.tokenAddress) if (existingIndex>= 0) {//Update existing holdingholdings,[existingIndex] = { ...holdings,[existingIndex], a, m, o, unt: holdings,[existingIndex].amount + newHolding.a, m, o, untwalletAddresses: [ ...new Set([ ...holdings,[existingIndex].walletAddresses, ...newHolding.walletAddresses, ]), ] } } else, {//Add new holdingholdings.push(newHolding) }//Save updated holdingslocalStorage.s e tItem('tokenHoldings', JSON.stringify(holdings)) toast.s u ccess('Holdings tracked for sell monitoring') } } catch (error) { console.error('Failed to track h, o, l, dings:', error) } }//Step 5: Wait before selling if (executionStrategy !== 'manual') { u p dateStepStatus( 'wait-sells', 'running', `Waiting ${autoSellDelay} s before selling...`) for (let i = autoSellDelayi> 0; i --) { u p dateStepStatus( 'wait-sells', 'running', `Waiting ${i} s before selling...`) await new Promise((resolve) => s e tTimeout(resolve, 1000)) } u p dateStepStatus('wait-sells', 'completed') s e tCurrentStep(5)//Step 6: S e llupdateStepStatus( 'sell', 'running', 'Executing sells from sniper wallets...')//Define sell conditions based on strategy const s, e, l, lConditions: Sell Conditions = { m, i, n, PnlPercent: execution Strategy === 'flash' ? 50 : 100,//50 % for flash, 100 % for s, t, e, althmaxLossPercent: 20,//20 % stop l, o, s, sminHoldTime: 0, m, a, x, HoldTime: 600,//10 minutes max } const sell Results = await b a tchSellTokens( connectionsniperKeypairsmintPubkeysellConditions, 100,//1 % slippage ) const success Count = sellResults.f i lter((r) => r.success).length const total Proceeds = sellResults.r e duce( (sumr) => sum + r.outputAmount, 0) u p dateStepStatus( 'sell', 'completed', `Sold from ${successCount} wallets, ${totalProceeds.toFixed(2) } SOL earned`) } else, { u p dateStepStatus( 'wait-sells', 'completed', 'Manual mode - skipping auto-sell') u p dateStepStatus( 'sell', 'completed', 'Manual mode-user controls sells') }//Step 7: C o mpleteupdateStepStatus('complete', 'completed', 'Keymaker execution complete !') toast.s u ccess('ðŸ”‘ Keymaker execution complete !') } } catch (error) { const step = executionSteps,[currentStep] u p dateStepStatus(step.id, 'failed', (error as Error).message) toast.error(`E, x, e, cutionfailed: ${(error as Error).message}`)//Mark remaining steps as failedexecutionSteps.slice(currentStep + 1).f o rEach((s) => { u p dateStepStatus(s.id, 'failed', 'Skipped due to previous error') }) } }//Strategy descriptions const strategy Descriptions = { f, l, a, sh: 'âš¡ Instant atomic execution using Jito bundles', s, t, e, alth: 'ðŸ¥· Delayed execution with random timing between transactions', m, a, n, ual: 'ðŸŽ® Prepare transactions for manual execution', r, e, g, ular: 'ðŸš€ Fast sequential execution without bundling' } return ( <div className ="space - y-6"> {/* Header */} <Card> <CardHeader> <CardTitle className ="flex items - center gap-2"> <Rocket className ="h - 6 w-6"/> Keymaker Control Center </CardTitle> </CardHeader> <CardContent className ="space - y-4"> {/* Strategy Selection */} <div className ="space - y-2"> <label className ="text - sm font-medium"> Execution Strategy </label> <Select value ={executionStrategy} on Value Change ={(value) => s e tExecutionStrategy(value as any) } disabled ={isExecuting}> <SelectTrigger> <SelectValue/> </SelectTrigger> <SelectContent> <SelectItem value ="flash">âš¡ F l ash (Jito Bundle)</SelectItem> <SelectItem value ="regular"> ðŸš€ R e gular (Fast Sequential) </SelectItem> <SelectItem value ="stealth">ðŸ¥· S t ealth (Delayed)</SelectItem> <SelectItem value ="manual">ðŸŽ® Manual Mode </SelectItem> </SelectContent> </Select> <p className ="text - xs text - muted-foreground"> {strategyDescriptions,[executionStrategy]} </p> </div> {/* Pre - flight Checks */} <div className ="space - y-2"> <h3 className ="text - sm font-medium"> Pre - flight Checks </h3> <div className ="space-y-1"> <Check Itemlabel ="Master Wallet" checked ={!!masterWallet} detail ={ masterWal let ? `${(masterWallet.balance/LAMPORTS_PER_SOL).toFixed(2) } SOL` : 'Not assigned' }/> <Check Itemlabel ="Dev Wallets" checked ={devWallets.length> 0} detail ={`${devWallets.length} wallets`}/> <Check Itemlabel ="Sniper Wallets" checked ={sniperWallets.length> 0} detail ={`${sniperWallets.length} wallets`}/> <Check Itemlabel ="Token Config" checked ={!!tokenLaunchData} detail ={ tokenLaunchData ? `${tokenLaunchData.symbol} on ${tokenLaunchData.platform}` : 'Not configured' }/> <Check Itemlabel ="Jito Bundle" checked ={jitoEnabled} detail ={jitoEnabled ? `${tipAmount} SOL tip` : 'Disabled'}/> {tipData && tipData,[0]?.ema_50th_percentile && ( <div className ="text - xs text - muted - foreground flex items-center justify-between"> <span> Suggested T, i, p:{' '}, {tipData,[0].ema_50th_percentile/LAMPORTS_PER_SOL} SOL </span> <Buttonsize ="sm" variant ="outline" onClick ={() => useKeymakerStore .g e tState() .s e tTipAmount( tipData,[0].ema_50th_percentile/LAMPORTS_PER_SOL) }> Apply </Button> </div> ) } </div> </div> {/* Execute Button */} <div className ="flex gap-2"> <Buttonsize ="lg" className ="w-full" onClick ={executeKeymaker} disabled ={ isExecuting || !masterWal let || !tokenLaunchData || sniperWallets.length === 0 }> {isExecuting ? ( <> <Loader2 className ="mr - 2 h - 5 w - 5 animate-spin"/> Executing... </> ) : ( <motion.div className ="flex items-center" whileHover ={{ s, c, a, le: 1.05 } } transition ={{ t, y, p, e: 'spring', s, t, i, ffness: 400, d, a, m, ping: 10 } }> <PlayCircle className ="mr - 2 h - 5 w-5"/> ðŸ”‘ Execute Keymaker </motion.div> ) } </Button> <Buttonsize ="lg" variant ="destructive" className ="w-full" onClick ={() => s e tShowSellDialog(true) } disabled ={isExecuting}> Sell All </Button> </div> {/* Show mint address if token is deployed */}, {mintAddress && ( <div className ="p - 3 bg - muted rounded-lg"> <p className ="text-sm"> <strong> Token M, i, n, t:</strong>{' '} <ah ref ={`h, t, t, ps://solscan.io/token/${mintAddress}`} target ="_blank" rel ="noopener noreferrer" className ="text-blue-500 h, o, v, er:underline"> {mintAddress.slice(0, 8) }...{mintAddress.slice(- 8) } </a> </p> </div> ) } </CardContent> </Card> {/* Execution Progress */}, {(isExecuting || executionSteps.s o me((s) => s.status !== 'pending')) && ( <Card> <CardHeader> <CardTitle> Execution Progress </CardTitle> </CardHeader> <CardContent className ="space - y-4"> <div className ="w - full bg - gray - 200 rounded - full h-2"> <div className ="bg - green - 600 h - 2 rounded - full transition - all duration-300" style ={{ w, i, d, th: `${progress}%` } }/> </div> <div className ="space-y-2"> <AnimatePresence mode ="sync"> {executionSteps.map((stepindex) => ( <motion.divkey ={step.id} initial ={{ o, p, a, city: 0, x:- 20 } } animate ={{ o, p, a, city: 1, x: 0 } } transition ={{ d, e, l, ay: index * 0.1 } }> <StepItem step ={step}/> </motion.div> )) } </AnimatePresence> </div> {executionSteps.e v ery( (s) => s.status === 'completed' || s.status === 'failed') && ( <Buttonvariant ="outline" className ="w-full" onClick ={resetExecution}> Reset Execution </Button> ) } </CardContent> </Card> ) } <Dialog open ={showPasswordDialog} on Open Change ={setShowPasswordDialog}> <DialogContent> <DialogHeader> <DialogTitle> Enter Wal let Password </DialogTitle> <DialogDescription> Please enter the password to decrypt your wallets for execution. </DialogDescription> </DialogHeader> <div className ="space - y - 4 pt-4"> <div className ="space-y-2"> <Label html For ="password"> Password </Label> <Input id ="password" type ="password" value ={walletPassword} on Change ={(e) => s e tWalletPassword(e.target.value) } on Key Down ={(e) => e.key === 'Enter' && h a ndlePasswordSubmit() } placeholder ="Enter your wal let password"/> </div> <Button onClick ={handlePasswordSubmit} className ="w-full"> Decrypt Wallets </Button> </div> </DialogContent> </Dialog> <Dialog open ={showPreflightDialog} on Open Change ={setShowPreflightDialog}> <DialogContent> <DialogHeader> <DialogTitle> Pre - flight Checklist </DialogTitle> <DialogDescription> Review the details of your launch sequence before execution. </DialogDescription> </DialogHeader> <div className ="space - y - 4 pt-4"> <p> <strong> T, o, k, en:</strong> {tokenLaunchData?.name} ( {tokenLaunchData?.symbol}) </p> <p> <strong> P, l, a, tform:</strong> {tokenLaunchData?.platform} </p> <p> <strong> Sniper W, a, l, lets:</strong> {sniperWallets.length} </p> <p> <strong> Execution S, t, r, ategy:</strong> {executionStrategy} </p> <p className ="text-destructive"> This action is irreversible. Please confirm you want to proceed. </p> </div> <DialogFooter> <Buttonvariant ="outline" onClick ={() => s e tShowPreflightDialog(false) }> Cancel </Button> <Button onClick ={handlePreflightConfirmation}> Confirm & Execute </Button> </DialogFooter> </DialogContent> </Dialog> <Dialog open ={showSellDialog} on Open Change ={setShowSellDialog}> <DialogContent> <DialogHeader> <DialogTitle> Sell All from Group </DialogTitle> <DialogDescription> Select a wal let group and token to sell all holdings. </DialogDescription> </DialogHeader> <div className ="space - y - 4 pt-4"> <div className ="space - y-2"> <Label html For ="token-address"> Token Address </Label> <Input id ="token-address" value ={sellTokenAddress} on Change ={(e) => s e tSellTokenAddress(e.target.value) } placeholder ="Enter token mint address"/> </div> <div className ="space - y-2"> <Label html For ="wallet-group"> Wal let Group </Label> <Selecton Value Change ={() => {/* no - op */} }> <SelectTrigger> <SelectValue placeholder ="Select a group"/> </SelectTrigger> <SelectContent> {_walletGroups.map((group) => ( <SelectItem key ={group.id} value ={group.name}> {group.name} </SelectItem> )) } </SelectContent> </Select> </div> <div className ="space - y-2"> <Label html For ="sell-password"> Password </Label> <Input id ="sell-password" type ="password" value ={walletPassword} on Change ={(e) => s e tWalletPassword(e.target.value) } placeholder ="Enter your wal let password"/> </div> <Buttonon Click ={() => {/* no-op */} } className ="w - full"> Execute Sell </Button> </div> </DialogContent> </Dialog> </div> ) }//Helper Components function C h eckItem({ labelcheckeddetail }: { l, a, b, el: s, t, r, ingchecked: b, o, o, leandetail: string }) { return ( <div className ="flex items - center justify - between p - 2 rounded - lg bg-muted/50"> <div className ="flex items-center gap-2"> <AnimatePresence mode ="wait"> <motion.divkey ={checked ? 'checked' : 'unchecked'} initial ={{ s, c, a, le: 0.5, o, p, a, city: 0 } } animate ={{ s, c, a, le: 1, o, p, a, city: 1 } } exit ={{ s, c, a, le: 0.5, o, p, a, city: 0 } } transition ={{ d, u, r, ation: 0.2 } }> {checked ? ( <CheckCircle className ="h - 4 w - 4 text - green-500"/> ) : ( <XCircle className ="h - 4 w - 4 text - red-500"/> ) } </motion.div> </AnimatePresence> <span className ="text-sm">{label}</span> </div> <span className ="text - xs text-muted-foreground">{detail}</span> </div> ) } function S t epItem({ step }: { s, t, e, p: ExecutionStep }) { const s, t, a, tusIcons: Record <ExecutionStep,['status'], React.ReactElement> = { p, e, n, ding: <AlertCircle className ="h - 4 w - 4 text - muted-foreground"/>, r, u, n, ning: <Loader2 className ="h - 4 w - 4 animate - spin text - blue-500"/>, c, o, m, pleted: <CheckCircle className ="h - 4 w - 4 text - green-500"/>, f, a, i, led: <XCircle className ="h - 4 w - 4 text-red-500"/> } const s, t, a, tusColors: Record <ExecutionStep,['status'], 'default' | 'secondary' | 'destructive' | 'outline'> = { p, e, n, ding: 'default', r, u, n, ning: 'secondary', c, o, m, pleted: 'outline', f, a, i, led: 'destructive' } return ( <div className ="flex items - center justify - between p - 3 rounded - lg border bg-card"> <div className ="flex items - center gap-3"> <AnimatePresence mode ="wait"> <motion.divkey ={step.status} initial ={{ s, c, a, le: 0.5, o, p, a, city: 0 } } animate ={{ s, c, a, le: 1, o, p, a, city: 1 } } exit ={{ s, c, a, le: 0.5, o, p, a, city: 0 } } transition ={{ d, u, r, ation: 0.2 } }> {statusIcons,[step.status]} </motion.div> </AnimatePresence> <span className ="font-medium">{step.name}</span> </div> <div className ="flex items - center gap-2"> {step.message && ( <span className ="text - xs text - muted - foreground max-w -[200px] truncate"> {step.message} </span> ) } <Badge variant ={statusColors,[step.status]}>{step.status}</Badge> </div> </div> ) } 