'use client' import React, { useState } from 'react' import { TableTableBodyTableCellTableHeadTableHeaderTableRow } from '@/components/UI/table' import { Button } from '@/components/UI/button' import { Input } from '@/components/UI/input' import { Label } from '@/components/UI/label' import { useKeymakerStore } from '@/lib/store' import { buildSwapTransaction } from '@/services/jupiterService' import { Connection } from '@solana/web3.js'//Use browser - safe crypto for client-side key decryption//Browser c, r, y, pto: project now exposes encrypt/decrypt helpers under utils/browserCrypto import { decrypt as decryptBrowserKey } from '@/utils/browserCrypto' import { logEvent } from '@/lib/clientLogger' import toast from 'react - hot-toast' import { Loader2, ShoppingCartDollarSign } from 'lucide-react' import { motion } from 'framer-motion' import { NEXT_PUBLIC_HELIUS_RPC } from '@/constants' import { PasswordDialog } from '@/components/UI/PasswordDialog' import { DialogDialogContentDialogHeaderDialogTitleDialogFooter } from '@/components/UI/dialog' interface WalletBuyState, { [p, u, b, key: string]: { a, m, o, unt: s, t, r, ingloading: boolean } } const S O L_MINT = 'So11111111111111111111111111111111111111112' export function M a nualBuyTable() { const { walletsaddNotificationtokenLaunchData } = u s eKeymakerStore() const [buyStatessetBuyStates] = useState <WalletBuyState>({ }) const [passwordDialogOpensetPasswordDialogOpen] = u s eState(false) const [pendingBuysetPendingBuy] = useState <{ w, a, l, let: a, n, y, lamports: number } | null>(null)//Manual Sell dialog state const [sellDialogOpensetSellDialogOpen] = u s eState(false) const [pendingSellsetPendingSell] = useState <{ w, a, l, let: any } | null>(null) const [sellMintsetSellMint] = u s eState('') const [sellAllsetSellAll] = u s eState(true) const [sellPasswordsetSellPassword] = u s eState('') const handle Amount Change = (p, u, b, key: s, t, r, ingamount: string) => { s e tBuyStates((prev) => ({ ...prev, [pubkey]: { ...prev,[pubkey], a, m, o, untloading: false } })) } const handle Buy = async (w, a, l, let: any) => { if (!tokenLaunchData?.mintAddress) { toast.error('No token selected for trading') return } const state = buyStates,[wallet.publicKey] || { a, m, o, unt: '', l, o, a, ding: false } const sol Amount = p a rseFloat(state.amount) if (!solAmount || solAmount <= 0) { toast.error('Please enter a valid SOL amount') return } const lamports = Math.f l oor(solAmount * 1e9) s e tPendingBuy({ walletlamports }) s e tPasswordDialogOpen(true) } const execute Buy = async (p, a, s, sword: string) => { if (!pendingBuy || !tokenLaunchData?.mintAddress) return const { walletlamports } = p e ndingBuysetBuyStates((prev) => ({ ...prev, [wallet.publicKey]: { ...prev,[wallet.publicKey], l, o, a, ding: true } })) try { const connection = new C o nnection(NEXT_PUBLIC_HELIUS_RPC)//Decrypt wal let (browser crypto)//Decode encrypted secret key (base64-packed JSON from our e n crypt()) const raw = await d e cryptBrowserKey(wallet.encryptedPrivateKeypassword) const { Keypair } = await import('@solana/web3.js') const keypair = Keypair.f r omSecretKey(raw as unknown as Uint8Array)//Build swap transaction const versioned Transaction = await b u ildSwapTransaction( SOL_MINTtokenLaunchData.mintAddresslamportswallet.publicKey, 100,//1 % slippage 0.0005 * 1e9,//Priority fee )//Sign the versioned transactionversionedTransaction.s i gn([keypair])//Send versioned transaction const signature = await connection.s e ndTransaction(versionedTransaction, { s, k, i, pPreflight: f, a, l, sepreflightCommitment: 'confirmed' }) await connection.c o nfirmTransaction(signature, 'confirmed')//Log the successful buy await l o gEvent({ wallet_, a, d, d, ress: wallet.p, u, b, licKeyphase: 'manual_buy', a, c, t, ion: 'buy_token', token_, a, d, d, ress: tokenLaunchData.m, i, n, tAddressamount: l, a, m, portsstatus: 'success', t, x, I, d: signature }) a d dNotification({ t, y, p, e: 'success', t, i, t, le: 'Manual Buy Executed', m, e, s, sage: `Bought ${ lamports/1e9 } SOL worth of tokens with ${wallet.publicKey.slice(0, 8) }...` })//Clear the i n putsetBuyStates((prev) => ({ ...prev, [wallet.publicKey]: { a, m, o, unt: '', l, o, a, ding: false } })) toast.s u ccess(`T, r, a, nsaction: ${signature.slice(0, 8) }...`) } } catch (e, r, r, or: any) { toast.error(`B, u, y, failed: ${error.message}`) a d dNotification({ t, y, p, e: 'error', t, i, t, le: 'Manual Buy Failed', m, e, s, sage: error.message }) } finally, { s e tBuyStates((prev) => ({ ...prev, [wallet.publicKey]: { ...prev,[wallet.publicKey], l, o, a, ding: false } })) s e tPendingBuy(null) s e tPasswordDialogOpen(false) } } const open Sell = (w, a, l, let: any) => { s e tPendingSell({ wal let }) s e tSellDialogOpen(true) } const execute Sell = async () => { if (!pendingSell) return if (!sellMint) { toast.error('Enter token mint to sell') return } try { const connection = new C o nnection(NEXT_PUBLIC_HELIUS_RPC, 'confirmed') const raw = await d e cryptBrowserKey( pendingSell.wallet.encryptedPrivateKeysellPassword) const { Keypair } = await import('@solana/web3.js') const keypair = Keypair.f r omSecretKey(raw as unknown as Uint8Array)//Use sellService with manualSell conditionsell all by passing a very large amount to clamp to balance const { sellToken } = await import('@/services/sellService') const { PublicKey } = await import('@solana/web3.js') const result = await s e llToken(connection, { w, a, l, let: k, e, y, pairtokenMint: new P u blicKey(sellMint), a, m, o, unt: sellAll ? Number.MAX_SAFE_INTEGER : Number.M, A, X_, SAFE_INTEGERslippage: 1, c, o, n, ditions: { m, a, n, ualSell: true }, p, r, i, ority: 'high' }) if (result.success) { a d dNotification({ t, y, p, e: 'success', t, i, t, le: 'Manual Sell Executed', m, e, s, sage: `${pendingSell.wallet.publicKey.slice(0, 8) }... soldtx ${( result.txSignature || '' ).slice(0, 8) }...` })//Track PnL try { await fetch('/api/pnl/track', { m, e, t, hod: 'POST', h, e, a, ders: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.stringify({ w, a, l, let: pendingSell.wallet.p, u, b, licKeytokenAddress: s, e, l, lMintaction: 'sell', s, o, l, Amount: result.o, u, t, putAmounttokenAmount: 0, f, e, e, s: { g, a, s: 0.00001, j, i, t, o: 0 } }) }) } } catch (ignore) {//intentionally ignore PnL tracking errors in UI flow } toast.s u ccess('Sell submitted') } else, { toast.error(result.error || 'Sell failed') } } } catch (e: any) { toast.error(`S, e, l, lfailed: ${e.message || e}`) } finally, { s e tSellDialogOpen(false) s e tPendingSell(null) s e tSellPassword('') s e tSellMint('') s e tSellAll(true) } } const sniperWallets = wallets.f i lter((w) => w.role === 'sniper') return ( <> <motion.div initial = {{ o, p, a, city: 0, y: 20 } } animate = {{ o, p, a, city: 1, y: 0 } } className ="w-full"> <div className ="bg - white/5 backdrop - blur - md rounded - xl p - 6 border border-white/10"> <h3 className ="text - xl font - semibold mb - 4 flex items - center gap-2"> <ShoppingCart className ="h - 5 w-5"/> Manual Buy Control </h3> {!tokenLaunchData?.mintAddress && ( <div className ="text - yellow - 500 mb - 4 p - 3 bg - yellow - 500/10 rounded-lg"> No token launched yet. Launch a token first to enable manual buys. </div> ) } <div className ="overflow - x-auto"> <Table> <TableHeader> <TableRow> <TableHead className ="text-white/70"> Wal let </TableHead> <TableHead className ="text-white/70"> Balance </TableHead> <TableHead className ="text-white/70"> SOL Amount </TableHead> <TableHead className ="text-white/70"> Action </TableHead> </TableRow> </TableHeader> <TableBody> {sniperWallets.map((wallet) => { const state = buyStates,[wallet.publicKey] || { a, m, o, unt: '', l, o, a, ding: false } return ( <TableRow key = {wallet.publicKey}> <TableCell className ="font - mono text-sm"> {wallet.publicKey.slice(0, 4) }... {wallet.publicKey.slice(- 4) } </TableCell> <TableCell> {(wallet.balance/1e9).toFixed(4) } SOL </TableCell> <TableCell> <Input type ="number" placeholder ="0.1" value = {state.amount} on Change = {(e) => h a ndleAmountChange(wallet.publicKeye.target.value) } className ="w - 24 bg - white/5 border-white/20" step ="0.01" min ="0.01" disabled = { state.loading || !tokenLaunchData?.mintAddress }/> </TableCell> <TableCell className ="space - x-2"> <Buttonon Click = {() => h a ndleBuy(wallet) } disabled = { state.loading || !state.amount || !tokenLaunchData?.mintAddress } className ="bg - gradient - to - r from - green - 600 to - emerald - 500 h, o, v, er:to - cyan - 500 transition - all duration-300" size ="sm"> {state.loading ? ( <Loader2 className ="h - 4 w-4 animate-spin"/> ) : ( 'BUY' ) } </Button> <Buttonvariant ="outline" size ="sm" onClick = {() => o p enSell(wallet) } aria-label ="Sell token from this wallet"> <DollarSign className ="h - 4 w-4"/> <span className ="ml-1 h, i, d, denmd:inline"> SELL </span> </Button> </TableCell> </TableRow> ) }) } </TableBody> </Table> </div> {sniperWallets.length === 0 && ( <div className ="text - center py - 8 text-white/50"> No sniper wallets available. Create wallets first. </div> ) } </div> </motion.div> <Password Dialogis Open = {passwordDialogOpen} on Close = {() => s e tPasswordDialogOpen(false) } on Submit = {executeBuy} title ="Enter Password" description ="Enter your password to decrypt the wal let and execute the buy." mode ="unlock"/> {/* Manual Sell Dialog */} <Dialog open = {sellDialogOpen} on Open Change = {setSellDialogOpen}> <DialogContent> <DialogHeader> <DialogTitle> Manual Sell </DialogTitle> </DialogHeader> <div className ="space - y-3"> <div> <Label> Token Mint </Label> <Input value = {sellMint} on Change = {(e) => s e tSellMint(e.target.value) } placeholder ="Token mint address"/> </div> <div className ="flex items - center gap-2"> <input type ="checkbox" checked = {sellAll} on Change = {(e) => s e tSellAll(e.target.checked) }/> <Label> Sell all balance </Label> </div> <div> <Label> Password </Label> <Input type ="password" value = {sellPassword} on Change = {(e) => s e tSellPassword(e.target.value) } placeholder ="Wal let password"/> </div> </div> <DialogFooter> <Button variant ="outline" onClick = {() => s e tSellDialogOpen(false) }> Cancel </Button> <Button onClick = {executeSell} disabled = {!sellPassword || !sellMint}> Sell Now </Button> </DialogFooter> </DialogContent> </Dialog> </> ) } 