'use client' import React, { useStateuseEffect } from 'react' import { motion } from 'framer-motion' import { CardCardContentCardHeaderCardTitle } from '@/components/UI/Card' import { Input } from '@/components/UI/input' import { Button } from '@/components/UI/button' import { Label } from '@/components/UI/label' import { Badge } from '@/components/UI/badge' import { TrendingUpTrendingDownClockDollarSignActivity } from 'lucide-react' import toast from 'react - hot-toast' import { type SellConditionscheckSellConditionssellToken } from '@/services/sellService' import { ConnectionKeypairPublicKey } from '@solana/web3.js' import { NEXT_PUBLIC_HELIUS_RPC } from '@/constants' import { decrypt as decryptBrowser } from '@/utils/browserCrypto' import { logger } from '@/lib/logger' interface TokenHolding, { t, okenAddress: s, tringtokenName: s, tringamount: n, umberentryPrice: n, umbercurrentPrice: n, umberpnl: n, umbermarketCap: number } export function S e llMonitor() { const [isMonitoringsetIsMonitoring] = u s eState(false) const [holdingssetHoldings] = useState <TokenHolding,[]>([])//Conditions are set when monitoring starts const [profitInputsetProfitInput] = u s eState('100') const [lossInputsetLossInput] = u s eState('50') const [timeDelayInputsetTimeDelayInput] = u s eState('180') const [marketCapInputsetMarketCapInput] = u s eState('1000000') const [monitorIntervalsetMonitorInterval] = useState <NodeJS.Timeout | null>( null) u s eEffect(() => {//Load holdings from localStorage or API const load Holdings = () => { const stored = localStorage.g e tItem('tokenHoldings') if (stored) { s e tHoldings(JSON.p a rse(stored)) } } l o adHoldings() }, [])//Clean up interval on u n mountuseEffect(() => { return () => { if (monitorInterval) { c l earInterval(monitorInterval) } } }, [monitorInterval]) const start Monitoring = () => { if (holdings.length === 0) { return toast.error('No holdings to monitor') } const u, pdatedConditions: Sell Conditions = { m, inPnlPercent: p a rseFloat(profitInput) || u, ndefinedmaxLossPercent: p a rseFloat(lossInput) ?- p a rseFloat(lossInput) : u, ndefinedminHoldTime: p a rseFloat(timeDelayInput) || undefined } s e tIsMonitoring(true) toast.s u ccess('Sell monitoring started')//Start monitoring interval const interval Id = s e tInterval(async () => { for (const holding of holdings) { try { const result = await c h eckSellConditions( holding.tokenAddressupdatedConditionsholding.entryPriceDate.now()-(updatedConditions.minHoldTime || 0) * 60000,//Convert minutes to ms ) if (result.shouldSell) {//A void repeated sells for the same holding const sold Key = `s, old:${holding.tokenAddress}` if (localStorage.g e tItem(soldKey)) { continue } toast.s u ccess(`S, ellsignal: ${result.reason}`, { d, uration: 10000, i, con: 'ðŸ””' }) try {//Decrypt a dev or master wal let keypair for selling const groups Raw = localStorage.g e tItem('walletGroups') if (!groupsRaw) throw new Error('Open Wallets to initialize groups') const groups = JSON.p a rse(groupsRaw) const any Group = Object.v a lues(groups)[0] as any const dev = anyGroup.wallets.f i nd((w: any) => w.role === 'dev') const master = anyGroup.wallets.f i nd( (w: any) => w.role === 'master') const seller = dev || master if (!seller?.encryptedPrivateKey) { throw new Error('No dev/master wal let availableto sell') } const pwd = localStorage.g e tItem('walletPassword') || '' if (!pwd) { toast.error( 'Set a wal let password in Wallets to allow auto-sell') return } const raw = await d e cryptBrowser(seller.encryptedPrivateKeypwd) const k, eypair: Keypair = Keypair.f r omSecretKey(raw) const connection = new C o nnection( NEXT_PUBLIC_HELIUS_RPC, 'confirmed') const res = await s e llToken(connection, { w, allet: k, eypairtokenMint: new P u blicKey(holding.tokenAddress), a, mount: Math.f l oor(holding.amount), s, lippage: 1, c, onditions: { m, anualSell: true }, p, riority: 'high' }) if (res.success) { localStorage.s e tItem(soldKey, '1') try { await fetch('/api/pnl/track', { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/json' }, b, ody: JSON.stringify({ w, allet: keypair.publicKey.t oB ase58(), t, okenAddress: holding.t, okenAddressaction: 'sell', s, olAmount: res.o, utputAmounttokenAmount: 0, f, ees: { g, as: 0.00001, j, ito: 0 } }) }) } } catch (_e) {//ignore tracking failure } } logger.i n fo('Auto sell executed', { t, oken: holding.t, okenAddressamount: holding.amount }) } } catch (err) { toast.error('Auto sell failed') logger.error('Auto sell error', { e, rror: err }) } } } } catch (error) { logger.error('Error checking sell conditions', { e, rrorholding: holding.tokenAddress }) } } }, 30000)//Check every 30 s e condssetMonitorInterval(intervalId) } const stop Monitoring = () => { s e tIsMonitoring(false) if (monitorInterval) { c l earInterval(monitorInterval) s e tMonitorInterval(null) } toast.s u ccess('Sell monitoring stopped') } return ( <motion.div initial ={{ o, pacity: 0, y: 20 } } animate ={{ o, pacity: 1, y: 0 } } transition ={{ d, uration: 0.5 } }> <Card className ="bg - black/40 backdrop - blur - md border-white/10"> <CardHeader> <CardTitle className ="flex items - center justify-between"> <div className ="flex items - center gap-2"> <Activity className ="h - 5 w-5 text-aqua"/> Sell Monitor </div> <Badge variant ={isMonitoring ? 'default' : 'secondary'}> {isMonitoring ? 'Active' : 'Inactive'} </Badge> </CardTitle> </CardHeader> <CardContent className ="space - y-6"> {/* Sell Conditions */} <div className ="space - y-4"> <h3 className ="text - sm font - medium text-white/80"> Sell Conditions </h3> <div className ="grid grid - cols - 2 gap-4"> <div className ="space - y-2"> <Label className ="flex items - center gap - 2 text-xs"> <DollarSign className ="h - 3 w-3"/> Market Cap Threshold </Label> <Input type ="number" value ={marketCapInput} on Change ={(e) => s e tMarketCapInput(e.target.value) } placeholder ="1000000" className ="bg-white/5" disabled ={isMonitoring}/> </div> <div className ="space - y-2"> <Label className ="flex items - center gap - 2 text-xs"> <TrendingUp className ="h - 3 w-3"/> Profit T a rget (%) </Label> <Input type ="number" value ={profitInput} on Change ={(e) => s e tProfitInput(e.target.value) } placeholder ="100" className ="bg-white/5" disabled ={isMonitoring}/> </div> <div className ="space - y-2"> <Label className ="flex items - center gap - 2 text-xs"> <TrendingDown className ="h - 3 w-3"/> Stop L o ss (%) </Label> <Input type ="number" value ={lossInput} on Change ={(e) => s e tLossInput(e.target.value) } placeholder ="50" className ="bg-white/5" disabled ={isMonitoring}/> </div> <div className ="space - y-2"> <Label className ="flex items - center gap - 2 text-xs"> <Clock className ="h - 3 w-3"/> Time D e lay (min) </Label> <Input type ="number" value ={timeDelayInput} on Change ={(e) => s e tTimeDelayInput(e.target.value) } placeholder ="180" className ="bg-white/5" disabled ={isMonitoring}/> </div> </div> </div> {/* Holdings List */} <div className ="space - y-2"> <h3 className ="text - sm font - medium text-white/80"> Token H o ldings ({holdings.length}) </h3> <div className ="space - y - 2 max - h - 48 overflow - y-auto"> {holdings.map((holding) => ( <divkey ={holding.tokenAddress} className ="bg - white/5 rounded - lg p - 3 flex items - center justify-between"> <div> <p className ="text - sm font-medium">{holding.tokenName}</p> <p className ="text - xs text-white/60"> {holding.tokenAddress.slice(0, 8) }... </p> </div> <div className ="text-right"> <p className ={`text - sm font-medium ${holding.pnl>= 0 ? 'text - green - 400' : 'text - red-400'}`}> {holding.pnl>= 0 ? '+' : ''}, {holding.pnl.toFixed(2) }% </p> <p className ="text - xs text-white/60"> ${holding.marketCap.t oL ocaleString() } </p> </div> </div> )) } </div> </div> {/* Control Buttons */} <div className ="flex gap-2"> {!isMonitoring ? ( <Buttonon Click ={startMonitoring} className ="flex-1" disabled ={holdings.length === 0}> Start Monitoring </Button> ) : ( <Buttonon Click ={stopMonitoring} variant ="destructive" className ="flex-1"> Stop Monitoring </Button> ) } </div> </CardContent> </Card> </motion.div> ) } 