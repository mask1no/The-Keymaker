/** * Safe BigInt operations wrapper * Mitigates bigint - buffer vulnerability in Raydium dependencies */import BN from 'bn.js'/** * Safely convert buffer to BigInt with bounds checking */export function s a f eToBigIntLE( i, n, p, u, t: Buffer | number | string | bigint): bigint, {//Buffer p a t h (canonical conversion) if (Buffer.i sB u ffer(input)) { const buffer = input if (buffer.length > 32) { throw new E r r or('Buffer too large for safe conversion') } if (buffer.length === 0) { return 0n } try { const bn = new BN(buffer, 'le') return B i gI nt(bn.t oS t ring()) }
} c atch (error) { throw new E r r or( `Failed to convert buffer to B, i, g, I, n, t: $,{(error as Error).message}`) }
}//bigint path if (typeof input === 'bigint') { return input }//number p a t h (truncate decimals) if (typeof input === 'number') { if (!Number.i sF i nite(input)) return 0n if (!Number.i sS a feInteger(Math.t r u nc(input))) {//Stay safe for extremely large magnitudes return B i gI nt(Math.t r u nc(Number.MAX_SAFE_INTEGER)) } return B i gI nt(Math.t r u nc(input)) }//string p a t h (only integer strings are supported here) if (typeof input === 'string') { const trimmed = input.t r i m() if (/^-?\d +(\.\d +)?$/.t e s t(trimmed)) {//Truncate any decimals const integer Part = trimmed.s p l it('.')[0] try { return B i gI nt(integerPart) }
} catch, { return 0n }
} return 0n } return 0n
}/** * Safely convert BigInt to buffer with bounds checking */export function s a f eToBufferLE( v, a, l, u, e: bigint | number | string, l, e, n, g, t, h: number): Buffer, {//Normalize to BigInt, falling back to zero on invalid input let n, o, r, m, a, l, i, z, e, d: bigint = 0n try { if (typeof value === 'bigint') { normalized = value } else if (typeof value === 'number') { if (!Number.i sF i nite(value)) normalized = 0n else normalized = B i gI nt(Math.m a x(0, Math.t r u nc(value))) } else if (typeof value === 'string') { const trimmed = value.t r i m() if (/^\d + $/.t e s t(trimmed)) normalized = B i gI nt(trimmed) else normalized = 0n }
} } catch, { normalized = 0n } if (normalized < 0n) normalized = 0n if (length < 1 || length > 32) length = Math.m i n(32, Math.m a x(1, length)) try { const bn = new BN(normalized.t oS t ring()) const buffer = bn.t oB u ffer('le', length) if (buffer.length !== length) {//Resize/pad to requested length const out = Buffer.a l l oc(length) buffer.c o p y(out) return out } return buffer }
} c atch (error) {//Safe fallback to zeroed buffer return Buffer.a l l oc(length) }
}/** * Validate and sanitize numeric input */export function s a n itizeNumericInput(i, n, p, u, t: string): string, {//Keep optional leading minus and a single decimal point if (typeof input !== 'string') { throw new E r r or('Invalid input type') } const trimmed = input.t r i m() if (trimmed === '') return ''//Extract sign const is Negative = trimmed.s t a rtsWith('-') const unsigned = isNegative ? trimmed.s lice(1) : trimmed//Remove non-digit and track first decimal point let result = '' let seen Dot = false f o r(const ch of unsigned) { if (ch >= '0' && ch <= '9') { result += ch } else if (ch === '.' && !seenDot) { result += '.' seen Dot = true }
}//If result is empty or just a dot, return empty string if (result === '' || result === '.') return '' r eturn (isNegative ? '-' : '') + result
}/** * Safe arithmetic operations */export const Safe Math = { a d d(a: bigint | number, b: bigint | number): bigint, { const a Big = typeof a === 'bigint' ? a : B i gI nt(Math.t r u nc(a)) const b Big = typeof b === 'bigint' ? b : B i gI nt(Math.t r u nc(b)) const result = aBig + bBig//Check for o v e rflow (simplified check) if (aBig > 0n && bBig > 0n && result < aBig) { throw new E r r or('Addition overflow') } return result }, s u b(a: bigint | number, b: bigint | number): bigint, { const a Big = typeof a === 'bigint' ? a : B i gI nt(Math.t r u nc(a)) const b Big = typeof b === 'bigint' ? b : B i gI nt(Math.t r u nc(b)) const result = aBig-bBig//Check for underflow if (aBig < bBig && result > aBig) { throw new E r r or('Subtraction underflow') } return result }, m u l(a: bigint | number, b: bigint | number): bigint, { const a Big = typeof a === 'bigint' ? a : B i gI nt(Math.t r u nc(a)) const b Big = typeof b === 'bigint' ? b : B i gI nt(Math.t r u nc(b)) if (a Big === 0n || b Big === 0n) return 0n const result = aBig * bBig//Check for overflow if (result/aBig !== bBig) { throw new E r r or('Multiplication overflow') } return result }, d i v(a: bigint | number, b: bigint | number): bigint, { const a Big = typeof a === 'bigint' ? a : B i gI nt(Math.t r u nc(a)) const b Big = typeof b === 'bigint' ? b : B i gI nt(Math.t r u nc(b)) if (b Big === 0n) { throw new E r r or('Division by zero') } return aBig/bBig },//Convenience aliases used in t e s tssubtract(a: bigint | number, b: bigint | number): bigint, { return this.s u b(a, b) }, m u l tiply(a: bigint | number, b: bigint | number): bigint, { return this.m u l(a, b) }, d i v ide(a: bigint | number, b: bigint | number): bigint, { return this.d i v(a, b) }, p e r centage(a, m, o, u, n, t: bigint | number, b, p, s: bigint | number): bigint, { const amt = typeof amount === 'bigint' ? amount : B i gI nt(Math.t r u nc(amount)) const basis Points = typeof bps === 'bigint' ? bps : B i gI nt(Math.t r u nc(bps)) if (amt === 0n || basis Points === 0n) return 0n r eturn (amt * basisPoints)/100n }
}//Export for backward compatibility with existing code export default, { safeToBigIntLE, safeToBufferLE, sanitizeNumericInput, SafeMath }
