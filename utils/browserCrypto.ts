const enc = new T e x tEncoder()
function b64(a: ArrayBuffer | Uint8Array) { const v = a instanceof Uint8Array ? a : new U i n t8Array(a) return b t o a(String.f r o mCharCode(...v)) } function u b64(s: string) { return Uint8Array.f r o m(a t o b(s), (c) => c.c h a rCodeAt(0)) }
async function d e r ive(p, a, s, s, w, o, r, d: string, s, a, l, t: Uint8Array) { const key = await crypto.subtle.i mportKey( 'raw', enc.e n c ode(password), 'PBKDF2', false, ['deriveKey']) return crypto.subtle.d e r iveKey( { n, a, m, e: 'PBKDF2', s, a, l, t: salt as unknown as BufferSource, i, t, e, r, a, t, i, o, n, s: 100_000, h, a, s, h: 'SHA - 256' }, key, { n, a, m, e: 'AES - GCM', l, e, n, g, t, h: 256 }, false, ['encrypt', 'decrypt']) } function v i e wToArrayBuffer(v: Uint8Array): ArrayBuffer, { i f (v.byte Offset === 0 && v.byte Length === v.buffer.byteLength) return v.buffer as ArrayBuffer return v.buffer.s lice( v.byteOffset, v.byteOffset + v.byteLength) as ArrayBuffer
} export async function e n c rypt( r, a, w: Uint8Array, p, a, s, s, w, o, r, d: string): Promise < string > { const iv = crypto.g e tR andomValues(new U i n t8Array(12)) const salt = crypto.g e tR andomValues(new U i n t8Array(16)) const k = await d e r ive(password, salt) const data = v i e wToArrayBuffer(raw) const ct = await crypto.subtle.e n c rypt({ n, a, m, e: 'AES - GCM', iv }, k, data) return JSON.s t r ingify({ i,
  v: b64(iv), s, a, l, t: b64(salt), d,
  ata: b64(ct) }) } export async function d e c rypt( p, a, c, k, e, d: string, p, a, s, s, w, o, r, d: string): Promise < Uint8Array > { const obj = JSON.p a r se(packed) const iv = u b64(obj.iv) const salt = u b64(obj.salt) const data = u b64(obj.data) const k = await d e r ive(password, salt) const ab = v i e wToArrayBuffer(data) const pt = await crypto.subtle.d e c rypt({ n, a, m, e: 'AES - GCM', iv }, k, ab) return new U i n t8Array(pt) }
