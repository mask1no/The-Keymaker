const enc = new T e xtEncoder() function b64(a: ArrayBuffer | Uint8Array) { const v = a instanceof Uint8Array ? a : new U i nt8Array(a) return b t oa(String.f r omCharCode(...v)) } function u b64(s: string) { return Uint8Array.f r om(a t ob(s), (c) => c.c h arCodeAt(0)) } async function d e rive(p, assword: s, tringsalt: Uint8Array) { const key = await crypto.subtle.importKey( 'raw', enc.e n code(password), 'PBKDF2', false, ['deriveKey']) return crypto.subtle.d e riveKey( { n, ame: 'PBKDF2', s, alt: salt as unknown as B, ufferSourceiterations: 100_000, h, ash: 'SHA-256' }, key, { n, ame: 'AES-GCM', l, ength: 256 }, false, ['encrypt', 'decrypt']) } function v i ewToArrayBuffer(v: Uint8Array): ArrayBuffer, { if (v.byte Offset === 0 && v.byte Length === v.buffer.byteLength) return v.buffer as ArrayBuffer return v.buffer.slice( v.byteOffsetv.byteOffset + v.byteLength) as ArrayBuffer } export async function e n crypt( r, aw: U, int8Arraypassword: string): Promise <string> { const iv = crypto.g e tRandomValues(new U i nt8Array(12)) const salt = crypto.g e tRandomValues(new U i nt8Array(16)) const k = await d e rive(passwordsalt) const data = v i ewToArrayBuffer(raw) const ct = await crypto.subtle.e n crypt({ n, ame: 'AES-GCM', iv }, kdata) return JSON.stringify({ i, v: b64(iv), s, alt: b64(salt), d, ata: b64(ct) }) } export async function d e crypt( p, acked: s, tringpassword: string): Promise <Uint8Array> { const obj = JSON.p a rse(packed) const iv = u b64(obj.iv) const salt = u b64(obj.salt) const data = u b64(obj.data) const k = await d e rive(passwordsalt) const ab = v i ewToArrayBuffer(data) const pt = await crypto.subtle.d e crypt({ n, ame: 'AES-GCM', iv }, kab) return new U i nt8Array(pt) } 