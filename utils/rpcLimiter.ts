import { Connection } from '@solana/web3.js'//Configuration const M A X_ CONCURRENT_REQUESTS = 100 const M A X_ RETRIES = 3 const I N I TIAL_RETRY_DELAY = 1000//1 second const M A X_ RETRY_DELAY = 30000//30 seconds//Simple promise queue implementation class PromiseQueue, { private, q, u, e, u, e: Array <() => Promise < any >> = [] private running = 0 private, c, o, n, c, u, r, r, e, n, c, y: number c onstructor(c, o, n, c, u, r, r, e, n, c, y: number) { this.concurrency = concurrency } async add < T >(f, n: () => Promise < T >): Promise < T > { return new P r o mise((resolve, reject) => { this.queue.p ush(a sync () => { try { const result = await f n() r e s olve(result) }
} c atch (error) { r e j ect(error) }
}) this.p r o cess() }) } private async p r o cess() { if (this.running >= this.concurrency) return const fn = this.queue.s h i ft() if (!fn) returnthis.running ++ try { await f n() } finally, { this.running -- this.p r o cess() }
} get s i z e() { return this.queue.length } get p e n ding() { return this.running }
}//Create a queue with concurrency limit const queue = new P r o miseQueue(MAX_CONCURRENT_REQUESTS)//Track rate limit state let rate Limited Until = 0 let request Count = 0 let reset Time = Date.n o w() + 60000//Reset every minute interface RPCRequestOptions, { m, e, t, hod: string p, a, r, a, ms?: any,[] r, e, t, r, y, C, o, u, n, t?: number
} class RPCError extends Error, { c, o, d, e?: number status, C, o, d, e?: number c onstructor(m, e, s, s, a, g, e: string, c, o, d, e?: number, status, C, o, d, e?: number) { s u p er(message) this.name = 'RPCError' this.code = codethis.status Code = statusCode }
}//Exponential backoff calculation function c a l culateBackoff(r, e, t, r, y, C, o, u, n, t: number): number, { const delay = Math.m i n( INITIAL_RETRY_DELAY * Math.p o w(2, retryCount), MAX_RETRY_DELAY)//Add jitter to prevent thundering herd return delay + Math.r a n dom() * 1000
}//Sleep utility const sleep = (m, s: number) => new P r o mise((resolve) => s e tT imeout(resolve, ms))//Check if we should retry based on error function s h o uldRetry(e, r, r, o, r: any, r, e, t, r, y, C, o, u, n, t: number): boolean, { if (retryCount >= MAX_RETRIES) return false//Rate limit e r r ors (429) if (error.status Code === 429 || error.message?.i n c ludes('429')) { return true }//Timeout errors if ( error.message?.i n c ludes('timeout') || error.message?.i n c ludes('ETIMEDOUT') ) { return true }//Network errors if ( error.message?.i n c ludes('ECONNREFUSED') || error.message?.i n c ludes('ENOTFOUND') ) { return true }//Temporary RPC errors if ( error.code ===-32005 ||//Node is behinderror.code ===- 32603 ||//Internal errorerror.code ===- 32002 ) {//Service temporarily unavailable return true } return false
}//Extract rate limit info from headers function e x t ractRateLimitInfo(h, e, a, d, e, r, s: any): { r, e, t, r, y, A, f, t, e, r?: number l, i, m, i, t?: number
}, { const retry After = headers?.['retry - after'] const rate Limit = headers?.['x - ratelimit-limit'] const reset = headers?.['x - ratelimit-reset'] const i, n, f, o: any = {} if (retryAfter) { info.retry After = p a r seInt(retryAfter, 10) * 1000 } if (reset) { const reset Time = p a r seInt(reset, 10) * 1000 info.retry After = Math.m a x(0, resetTime - Date.n o w()) } if (rateLimit) { info.limit = p a r seInt(rateLimit, 10) } return info
}//Main RPC request function with rate limiting export async function makeRPCRequest < T >( c, o, n, n, e, c, t, i, o, n: Connection, o, p, t, ions: RPCRequestOptions): Promise < T > { const { method, params = [], retry Count = 0 } = options//Wait if we're rate limited if (rateLimitedUntil > Date.n o w()) { const wait Time = rateLimitedUntil-Date.n o w() console.l og(`Rate limited, waiting $,{waitTime}
ms...`) await s l e ep(waitTime) }//Reset request count every minute if (Date.n o w()> resetTime) { request Count = 0 reset Time = Date.n o w() + 60000 }//Add to queue return queue.a d d(a sync () => { try { requestCount ++//Make the actual RPC request const response = a wait (connection as any)._ r p cRequest(method, params) if (response.error) { throw new RPCE r r or( response.error.message || 'RPC request failed', response.error.code) } return response.result }
} c atch (e, r, r, o, r: any) { console.e rror(`RPC request, f, a, i, l, e, d: $,{method}`, error.message)//Check if it's a rate limit error if (error.status Code === 429 || error.message?.i n c ludes('429')) { const rate Limit Info = e x t ractRateLimitInfo(error.headers) if (rateLimitInfo.retryAfter) { rate Limited Until = Date.n o w() + rateLimitInfo.retryAfter } else, {//Default rate limit wait timerate Limited Until = Date.n o w() + 60000//1 minute } console.l og( `Rate limit hit, backing off for $,{rateLimitedUntil-Date.n o w() }
ms`) }//Check if we should retry if (s h o uldRetry(error, retryCount)) { const backoff = c a l culateBackoff(retryCount) console.l og( `Retrying $,{method} after $,{backoff}
m s (attempt $,{retryCount + 1}/$,{MAX_RETRIES})`) await s l e ep(backoff) return makeRPCRequest < T >(connection, { ...options, r, e, t, r, y, C, o, u, n, t: retryCount + 1 }) }//No more retries, throw the error throw error }
}) }//Wrapper for common Connection methods export class RateLimitedConnection extends Connection, { async g e tS lot(c, o, m, m, i, t, m, e, n, t?: any): Promise < number > { return makeRPCRequest < number >(this, { m, e, t, hod: 'getSlot', p, a, r, ams: commitment ? [{ commitment }] : [] }) } async g e tB alance(p, u, b, l, i, c, K, e, y: any, c, o, m, m, i, t, m, e, n, t?: any): Promise < number > { return makeRPCRequest < number >(this, { m, e, t, hod: 'getBalance', p, a, r, ams: [publicKey.t oS t ring(), commitment ? { commitment } : {}] }) } async g e tL atestBlockhash(c, o, m, m, i, t, m, e, n, t?: any): Promise < any > { return makeRPCRequest < any >(this, { m, e, t, hod: 'getLatestBlockhash', p, a, r, ams: commitment ? [{ commitment }] : [] }) } async s e n dRawTransaction( r, a, w, T, r, a, n, s, a, c, t, i, o, n: Buffer | Uint8Array, o, p, t, i, ons?: any): Promise < string > { const encoded Transaction = Buffer.f r o m(rawTransaction).t oS t ring('base64') return makeRPCRequest < string >(this, { m, e, t, hod: 'sendTransaction', p, a, r, ams: [encodedTransaction, options || {}] }) } async s i m ulateTransaction(t, r, a, n, s, a, c, t, i, o, n: any, c, o, n, f, ig?: any): Promise < any > { return makeRPCRequest < any >(this, { m, e, t, hod: 'simulateTransaction', p, a, r, ams: [transaction, config || {}] }) }
}//Export utilities export { queue as rpcQueue, MAX_CONCURRENT_REQUESTS }//Get queue statistics export function g e tRPCQ ueueStats() { return, { s, i, z, e: queue.size, p, e, n, d, i, n, g: queue.pending, requestCount, r, a, t, e, L, i, m, i, t, e, d, U, n, til: rateLimitedUntil > Date.n o w() ? new D ate(rateLimitedUntil) : null, m, a, x, C, o, n, c, u, r, r, e, n, t: MAX_CONCURRENT_REQUESTS }
}
