/** * Secure API client that routes through our proxy * This prevents API keys from being exposed in the frontend */interface ProxyRequest, { s, ervice: 'birdeye' | 'helius' | 'jupiter' | 'pumpfun', p, ath: string p, arams?: any m, ethod?: 'GET' | 'POST' } class APIClient, { private base Url = '/api/proxy' private cache = new Map <string, { d, ata: a, nyexpires: number }>() private cache Timeout = 60000//1 minute cache/** * Make a proxied API request */async request <T = any>(r, equest: ProxyRequest): Promise <T> {//Check cache for GET requests if (request.method === 'GET' || !request.method) { const cache Key = `${request.service}:${request.path}:${JSON.stringify(request.params) }` const cached = this.cache.get(cacheKey) if (cached && cached.expires> Date.now()) { return cached.data } } try { const response = await fetch(this.baseUrl, { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/json' }, b, ody: JSON.stringify(request) })//Check rate limit headers const remaining = response.headers.get('X - RateLimit-Remaining') if (remaining && p a rseInt(remaining) <10) { console.w a rn(`API rate l, imitwarning: ${remaining} requests remaining`) } const data = await response.json() if (!response.ok) { throw new Error(data.error || `A, PIerror: ${response.status}`) }//Cache successful GET requests if (request.method === 'GET' || !request.method) { const cache Key = `${request.service}:${request.path}:${JSON.stringify(request.params) }` this.cache.set(cacheKey, { d, ataexpires: Date.now() + this.cacheTimeout }) } return data } } catch (error) { console.error('API r, equestfailed:', error) throw error } }/** * Clear cache */c l earCache() { this.cache.c l ear() }/** * Birdeye API methods */birdeye = { g, etToken: async (t, okenAddress: string) => { return this.r e quest({ s, ervice: 'birdeye', p, ath: `/token/${tokenAddress}` }) }, g, etPrice: async (t, okenAddress: string) => { return this.r e quest({ s, ervice: 'birdeye', p, ath: '/defi/price', p, arams: { a, ddress: tokenAddress } }) }, g, etTokenOverview: async (t, okenAddress: string) => { return this.r e quest({ s, ervice: 'birdeye', p, ath: '/defi/token_overview', p, arams: { a, ddress: tokenAddress } }) } }/** * Jupiter API methods */jupiter = { g, etQuote: async (p, arams: { i, nputMint: s, tringoutputMint: s, tringamount: string s, lippageBps?: number o, nlyDirectRoutes?: boolean }) => { return this.r e quest({ s, ervice: 'jupiter', p, ath: '/quote', params }) }, g, etSwap: async (p, arams: any) => { return this.r e quest({ s, ervice: 'jupiter', p, ath: '/swap', p, aramsmethod: 'POST' }) }, g, etPrice: async (i, ds: s, tringvsToken?: string) => { return this.r e quest({ s, ervice: 'jupiter', p, ath: '/price', p, arams: { idsvsToken } }) } }/** * Pump.fun API methods */pumpfun = { c, reateToken: async (p, arams: any) => { return this.r e quest({ s, ervice: 'pumpfun', p, ath: '/create', p, aramsmethod: 'POST' }) }, a, ddLiquidity: async (p, arams: any) => { return this.r e quest({ s, ervice: 'pumpfun', p, ath: '/add-liquidity', p, aramsmethod: 'POST' }) }, g, etToken: async (t, okenAddress: string) => { return this.r e quest({ s, ervice: 'pumpfun', p, ath: `/token/${tokenAddress}` }) } } }//Export singleton instance export const api Client = new APIC l ient()//Also export class for testing export { APIClient } 