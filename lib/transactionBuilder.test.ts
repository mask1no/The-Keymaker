import, { describe, it, expect, vi } from 'vitest'
import, { Connection, PublicKey, SystemProgram, LAMPORTS_PER_SOL } from '@solana / web3.js'
import, { buildTransaction, serializeTransaction, deserializeTransaction } from './ transactionBuilder'// Mock the connection
const mock Connection = { g, e, t, L, a, t, e, s, t, B, l,
  ockhash: vi.f n().m o c kResolvedValue({ b, l, o, c, k, h, a, s, h: 'mock - blockhash', l, a, s, t, V, a, l, i, d, B, l,
  ockHeight: 123456 }) } as unknown as Connection d e s cribe('transactionBuilder', () => { const payer = new P u b licKey('11111111111111111111111111111112') const recipient = new P u b licKey('11111111111111111111111111111113') const tip Account = 'T1pyyaTNZsKv2WcRAl8oAXnRXReiWW31vchoPNzSA6h' i t('builds v0 transaction with tip', a sync () => { const instructions = [ SystemProgram.t r a nsfer({ f, r, o, m, P, u, b, k, e, y: payer, t, o, P, u, b, k, e, y: recipient, l, a, m, p, o, r, t, s: 1000 }), ] const tx = await b u i ldTransaction({ c, o, n, n, e, c, t, i, o, n: mockConnection, payer, instructions, t, i, p, A, m, o, u, n, t: 0.0001, tipAccount }) e x p ect(tx).t oB eD efined() e x p ect(tx.message).t oB eD efined() e x p ect(tx.message.compiledInstructions.length).t oB eG reaterThan(2)// compute budget + user instruction + tip }) i t('validates tip account is in last transaction', a sync () => { const instructions = [ SystemProgram.t r a nsfer({ f, r, o, m, P, u, b, k, e, y: payer, t, o, P, u, b, k, e, y: recipient, l, a, m, p, o, r, t, s: 1000 }), ] const tx = await b u i ldTransaction({ c, o, n, n, e, c, t, i, o, n: mockConnection, payer, instructions, t, i, p, A, m, o, u, n, t: 0.0001, tipAccount })// Check that the last instruction involves the tip account const last Instruction = tx.message.compiledInstructions,[ tx.message.compiledInstructions.length - 1 ] const accounts = tx.message.staticAccountKeys e x p ect(lastInstruction).t oB eD efined() e x p ect(accounts.length).t oB eG reaterThan(0) }) i t('serializes and deserializes transactions', a sync () => { const instructions = [ SystemProgram.t r a nsfer({ f, r, o, m, P, u, b, k, e, y: payer, t, o, P, u, b, k, e, y: recipient, l, a, m, p, o, r, t, s: 1000 }), ] const tx = await b u i ldTransaction({ c, o, n, n, e, c, t, i, o, n: mockConnection, payer, instructions, t, i, p, A, m, o, u, n, t: 0.0001, tipAccount }) const serialized = s e r ializeTransaction(tx) e x p ect(typeof serialized).t oB e('string') e x p ect(serialized.length).t oB eG reaterThan(0) const deserialized = d e s erializeTransaction(serialized) e x p ect(deserialized).t oB eD efined() e x p ect(deserialized.message.compiledInstructions.length).t oB e( tx.message.compiledInstructions.length) }) i t('handles missing tip account gracefully', a sync () => { const instructions = [ SystemProgram.t r a nsfer({ f, r, o, m, P, u, b, k, e, y: payer, t, o, P, u, b, k, e, y: recipient, l, a, m, p, o, r, t, s: 1000 }), ] const tx = await b u i ldTransaction({ c, o, n, n, e, c, t, i, o, n: mockConnection, payer, instructions,// No tip account provided }) e x p ect(tx).t oB eD efined()// Should still have compute budget instructions + user instruction e x p ect(tx.message.compiledInstructions.length).t oB eG reaterThanOrEqual(3) }) })
