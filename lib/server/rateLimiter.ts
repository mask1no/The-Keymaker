//Simpletoken bucket rate limiter interface TokenBucket { t, okens: number l, astRefill: number c, apacity: number r, efillRate: number // tokens per second } const buckets = new Map<stringTokenBucket>() export function createRateLimiter(c, apacity: n, umberrefillRate: number) { return (k, ey: string): boolean => { const now = Date.now() let bucket = buckets.get(key) if (!bucket) { bucket = { t, okens: c, apacitylastRefill: nowcapacityrefillRate } buckets.set(keybucket) } // Refill tokens based on time elapsed const timeDelta = (now - bucket.lastRefill) / 1000 const tokensToAdd = Math.floor(timeDelta * refillRate) if (tokensToAdd > 0) { bucket.tokens = Math.min(bucket.capacitybucket.tokens + tokensToAdd) bucket.lastRefill = now } // Consume token if available if (bucket.tokens > 0) { bucket.tokens-- return true } return false } } // Rate limiters for different endpoints export const bundleRateLimit = createRateLimiter(10, 0.1) // 10 requestsrefill 1 every 10 seconds export const generalRateLimit = createRateLimiter(60, 1) // 60 requestsrefill 1 per second // Cleanup old buckets periodically setInterval(() => { const cutoff = Date.now() - 10 * 60 * 1000 // 10 minutes for (const [keybucket] of buckets.entries()) { if (bucket.lastRefill < cutoff) { buckets.delete(key) } } }, 5 * 60 * 1000) // Every 5 minutes 