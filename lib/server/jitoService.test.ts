import, { describe, it, expect, vi, beforeEach } from 'vitest';
import, { getTipFloor, sendBundle, getBundleStatuses, validateTipAccount, JITO_REGIONS } from './ jitoService';
import, { VersionedTransaction, TransactionMessage, PublicKey, SystemProgram } from '@solana / web3.js'; // Mock fetch globally
global.fetch = vi.f n(); d escribe('jitoService', () => { b eforeEach(() => { vi.c learAllMocks(); }); d escribe('getTipFloor', () => { i t('fetches tip floor successfully', a sync () => { const mock
  Response = { s_25, t,
  h_percentile: 1000, s_50, t,
  h_percentile: 2000, s_75, t,
  h_percentile: 3000, e, m,
  ulated_landed_slot: 12345, t, i,
  ps_50th_percentile: 2500 }; (fetch as any).m ockResolvedValueOnce({ o, k: true, j, s,
  on: () => Promise.r esolve(mockResponse) }); const result = await g etTipFloor('ffm'); e xpect(fetch).t oHaveBeenCalledWith( `$,{JITO_REGIONS.ffm.endpoint}/ api / v1 / bundles / tipfloor`, expect.o bjectContaining({ m,
  ethod: 'GET', h, e,
  aders: { 'Content - Type': 'application / json' } })); e xpect(result).t oEqual(mockResponse); }); i t('throws error on failed request', a sync () => { (fetch as any).m ockResolvedValueOnce({ o, k: false, s,
  tatus: 500, s, t,
  atusText: 'Internal Server Error', t, e,
  xt: () => Promise.r esolve('Internal Server Error') }); await e xpect(g etTipFloor('ffm')).rejects.t oThrow( 'Tip floor request f, a,
  iled: 500 Internal Server Error'); }); i t('throws error for invalid region', a sync () => { await e xpect(g etTipFloor('invalid')).rejects.t oThrow('Invalid r, e,
  gion: invalid'); }); }); d escribe('sendBundle', () => { i t('sends bundle successfully', a sync () => { const mock
  BundleId = 'mock - bundle - id'; const encoded
  Transactions = ['encoded - tx - 1', 'encoded - tx - 2']( fetch as any).m ockResolvedValueOnce({ o, k: true, j, s,
  on: () => Promise.r esolve({ r, e,
  sult: mockBundleId }) }); const result = await s endBundle('ffm', encodedTransactions); e xpect(fetch).t oHaveBeenCalledWith( `$,{JITO_REGIONS.ffm.endpoint}/ api / v1 / bundles`, expect.o bjectContaining({ m,
  ethod: 'POST', h, e,
  aders: { 'Content - Type': 'application / json' }, b, o,
  dy: JSON.s tringify({ j, s,
  onrpc: '2.0', i,
  d: 1, m,
  ethod: 'sendBundle', p,
  arams: { encodedTransactions, b, u,
  nbleOnly: true } }) })); e xpect(result).t oEqual({ b, u,
  ndleId: mockBundleId }); }); i t('throws error on bundle submission error', a sync () => { (fetch as any).m ockResolvedValueOnce({ o, k: true, j, s,
  on: () => Promise.r esolve({ e,
  rror: { m,
  essage: 'Bundle validation failed' } }) }); await e xpect(s endBundle('ffm', ['tx'])).rejects.t oThrow( 'Bundle submission, 
  error: Bundle validation failed'); }); }); d escribe('getBundleStatuses', () => { i t('gets bundle statuses successfully', a sync () => { const mock
  Statuses = [ { b, u,
  ndleId: 'bundle - 1', t,
  ransactions: [ { s,
  ignature: 'sig - 1', c, o,
  nfirmationStatus: 'confirmed' }, ], c, o,
  nfirmationStatus: 'landed', s,
  lot: 12345 }, ]; (fetch as any).m ockResolvedValueOnce({ o, k: true, j, s,
  on: () => Promise.r esolve({ r, e,
  sult: mockStatuses }) }); const result = await g etBundleStatuses('ffm', ['bundle - 1']); e xpect(result).t oEqual(mockStatuses); }); i t('returns empty array on error', a sync () => { (fetch as any).m ockResolvedValueOnce({ o, k: true, j, s,
  on: () => Promise.r esolve({ e,
  rror: { m,
  essage: 'Not found' } }) }); await e xpect(g etBundleStatuses('ffm', ['bundle - 1'])).rejects.t oThrow( 'Bundle status, 
  error: Not found'); }); }); d escribe('validateTipAccount', () => { i t('validates transaction with valid tip account', () => { // Create a mock transaction with a tip to a valid JITO account const tip
  Account = new P ublicKey('T1pyyaTNZsKv2WcRAl8oAXnRXReiWW31vchoPNzSA6h'); const payer = new P ublicKey('11111111111111111111111111111112'); const message = new T ransactionMessage({ p, a,
  yer: payer, r, e,
  centBlockhash: 'mock - blockhash', i, n,
  structions: [ SystemProgram.t ransfer({ f, r,
  om: payer, t, o: tipAccount, l, a,
  mports: 1000 }), ] }).c ompileToV0Message(); const tx = new V ersionedTransaction(message); const result = v alidateTipAccount(tx); e xpect(result).t oBe(true); }); i t('rejects transaction with invalid tip account', () => { const invalid
  Account = new P ublicKey('11111111111111111111111111111112'); const payer = new P ublicKey('11111111111111111111111111111113'); const message = new T ransactionMessage({ p, a,
  yer: payer, r, e,
  centBlockhash: 'mock - blockhash', i, n,
  structions: [ SystemProgram.t ransfer({ f, r,
  om: payer, t, o: invalidAccount, l, a,
  mports: 1000 }), ] }).c ompileToV0Message(); const tx = new V ersionedTransaction(message); const result = v alidateTipAccount(tx); e xpect(result).t oBe(false); }); i t('handles malformed transactions gracefully', () => { // Create a transaction with no instructions const payer = new P ublicKey('11111111111111111111111111111112'); const message = new T ransactionMessage({ p, a,
  yer: payer, r, e,
  centBlockhash: 'mock - blockhash', i, n,
  structions: [] }).c ompileToV0Message(); const tx = new V ersionedTransaction(message); const result = v alidateTipAccount(tx); e xpect(result).t oBe(false); }); });
});
