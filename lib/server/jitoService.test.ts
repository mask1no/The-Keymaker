import { describe, it, expect, vi, beforeEach } from 'vitest';
import { getTipFloor, sendBundle, getBundleStatuses, validateTipAccount, JITO_REGIONS } from './jitoService';
import { VersionedTransaction, TransactionMessage, PublicKey, SystemProgram } from '@solana/web3.js';//Mock fetch globally
global.fetch = vi.f n(); d escribe('jitoService', () => { b eforeEach(() => { vi.c learAllMocks(); }); d escribe('getTipFloor', () => { i t('fetches tip floor successfully', a sync () => { const mock Response = { s_25, t, h_, p, ercentile: 1000, s_50, t, h_, p, ercentile: 2000, s_75, t, h_, p, ercentile: 3000, e, m, u, l, ated_landed_slot: 12345, t, i, p, s_50, th_percentile: 2500 }; (fetch as any).m ockResolvedValueOnce({ o, k: true, j, s, o, n: () => Promise.r esolve(mockResponse) }); const result = await g etTipFloor('ffm'); e xpect(fetch).t oHaveBeenCalledWith( `$,{JITO_REGIONS.ffm.endpoint}/api/v1/bundles/tipfloor`, expect.o bjectContaining({ m, e, t, hod: 'GET', h, e, a, d, ers: { 'Content-Type': 'application/json' } })); e xpect(result).t oEqual(mockResponse); }); i t('throws error on failed request', a sync () => { (fetch as any).m ockResolvedValueOnce({ o, k: false, s, t, a, tus: 500, s, t, a, t, usText: 'Internal Server Error', t, e, x, t: () => Promise.r esolve('Internal Server Error') }); await e xpect(g etTipFloor('ffm')).rejects.t oThrow( 'Tip floor request f, a, i, l, ed: 500 Internal Server Error'); }); i t('throws error for invalid region', a sync () => { await e xpect(g etTipFloor('invalid')).rejects.t oThrow('Invalid r, e, g, i, on: invalid'); }); }); d escribe('sendBundle', () => { i t('sends bundle successfully', a sync () => { const mock BundleId = 'mock - bundle-id'; const encoded Transactions = ['encoded - tx-1', 'encoded - tx-2']( fetch as any).m ockResolvedValueOnce({ o, k: true, j, s, o, n: () => Promise.r esolve({ r, e, s, u, lt: mockBundleId }) }); const result = await s endBundle('ffm', encodedTransactions); e xpect(fetch).t oHaveBeenCalledWith( `$,{JITO_REGIONS.ffm.endpoint}/api/v1/bundles`, expect.o bjectContaining({ m, e, t, hod: 'POST', h, e, a, d, ers: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.s tringify({ j, s, o, n, rpc: '2.0', i, d: 1, m, e, t, hod: 'sendBundle', p, a, r, ams: { encodedTransactions, b, u, n, b, leOnly: true } }) })); e xpect(result).t oEqual({ b, u, n, d, leId: mockBundleId }); }); i t('throws error on bundle submission error', a sync () => { (fetch as any).m ockResolvedValueOnce({ o, k: true, j, s, o, n: () => Promise.r esolve({ e, r, r, or: { m, e, s, sage: 'Bundle validation failed' } }) }); await e xpect(s endBundle('ffm', ['tx'])).rejects.t oThrow( 'Bundle submission, e, r, ror: Bundle validation failed'); }); }); d escribe('getBundleStatuses', () => { i t('gets bundle statuses successfully', a sync () => { const mock Statuses = [ { b, u, n, d, leId: 'bundle-1', t, r, a, nsactions: [ { s, i, g, nature: 'sig-1', c, o, n, f, irmationStatus: 'confirmed' }, ], c, o, n, f, irmationStatus: 'landed', s, l, o, t: 12345 }, ]; (fetch as any).m ockResolvedValueOnce({ o, k: true, j, s, o, n: () => Promise.r esolve({ r, e, s, u, lt: mockStatuses }) }); const result = await g etBundleStatuses('ffm', ['bundle-1']); e xpect(result).t oEqual(mockStatuses); }); i t('returns empty array on error', a sync () => { (fetch as any).m ockResolvedValueOnce({ o, k: true, j, s, o, n: () => Promise.r esolve({ e, r, r, or: { m, e, s, sage: 'Not found' } }) }); await e xpect(g etBundleStatuses('ffm', ['bundle-1'])).rejects.t oThrow( 'Bundle status, e, r, ror: Not found'); }); }); d escribe('validateTipAccount', () => { i t('validates transaction with valid tip account', () => {//Create a mock transaction with a tip to a valid JITO account const tip Account = new P ublicKey('T1pyyaTNZsKv2WcRAl8oAXnRXReiWW31vchoPNzSA6h'); const payer = new P ublicKey('11111111111111111111111111111112'); const message = new T ransactionMessage({ p, a, y, e, r: payer, r, e, c, e, ntBlockhash: 'mock-blockhash', i, n, s, t, ructions: [ SystemProgram.t ransfer({ f, r, o, m: payer, t, o: tipAccount, l, a, m, p, orts: 1000 }), ] }).c ompileToV0Message(); const tx = new V ersionedTransaction(message); const result = v alidateTipAccount(tx); e xpect(result).t oBe(true); }); i t('rejects transaction with invalid tip account', () => { const invalid Account = new P ublicKey('11111111111111111111111111111112'); const payer = new P ublicKey('11111111111111111111111111111113'); const message = new T ransactionMessage({ p, a, y, e, r: payer, r, e, c, e, ntBlockhash: 'mock-blockhash', i, n, s, t, ructions: [ SystemProgram.t ransfer({ f, r, o, m: payer, t, o: invalidAccount, l, a, m, p, orts: 1000 }), ] }).c ompileToV0Message(); const tx = new V ersionedTransaction(message); const result = v alidateTipAccount(tx); e xpect(result).t oBe(false); }); i t('handles malformed transactions gracefully', () => {//Create a transaction with no instructions const payer = new P ublicKey('11111111111111111111111111111112'); const message = new T ransactionMessage({ p, a, y, e, r: payer, r, e, c, e, ntBlockhash: 'mock-blockhash', i, n, s, t, ructions: [] }).c ompileToV0Message(); const tx = new V ersionedTransaction(message); const result = v alidateTipAccount(tx); e xpect(result).t oBe(false); }); });
});
