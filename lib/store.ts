import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { Keypair } from '@solana/web3.js' export type Wal let Role = 'master' | 'dev' | 'sniper' | 'normal' export interface WalletData, { i, d: string, p, u, b, l, i, c, K, e, y: string, r, o, l, e: W, a, l, l, e, t, R, o, l, e, b, a, l, ance: number k, e, y, p, a, i, r?: K, e, y, p, a, i, r, e, n, c, ryptedPrivateKey?: string g, r, o, u, p, I, d?: string
} export interface WalletGroup, { i, d: string, n, a, m, e: string, w, a, l, l, e, t, I, d, s: string,[]
} export interface TokenLaunchData, { n, a, m, e: string, s, y, m, b, o, l: string, d, e, c, i, m, a, l, s: number, s, u, p, p, l, y: number, p, l, a, t, f, o, r, m: 'pump.fun' | 'letsbonk.fun' | 'raydium' l, p, A, m, o, u, n, t: number, w, a, l, l, e, t, P, u, b, l, i, cKey: string m, i, n, t, A, d, d, r, e, ss?: string tx, S, i, g, n, a, t, u, re?: string
} export type Execution Strategy = 'flash' | 'stealth' | 'manual' | 'regular' export interface ExecutionStep, { i, d: string, n, a, m, e: string, s, t, a, t, u, s: 'pending' | 'running' | 'completed' | 'failed' m, e, s, s, a, g, e?: string t, i, m, e, s, t, a, m, p?: number
} export interface Notification, { i, d: string, t, y, p, e: 'success' | 'error' | 'warning' | 'info', t, i, t, l, e: string m, e, s, s, a, g, e?: string, t, i, m, e, s, t, a, m, p: number r, e, a, d?: boolean
} interface KeymakerStore, {//Wal let M, a, n, a, g, e, m, e, n, t, w, a, l, lets: WalletData,[] w, a, l, l, e, t, G, r, o, u, p, s: WalletGroup,[] s, e, l, e, c, t, e, d, G, r, o, u, p: string, a, c, t, i, v, e, W, a, l, l, e, t: string | null//Public key of active w, a, l, l, e, t, s, e, t, W, a, l, l, ets: (w, a, l, l, e, t, s: WalletData,[]) => v, o, i, d, a, d, d, W, a, l, l, e, t: (w, a, l, l, e, t: Omit < WalletData, 'id' | 'balance'>) => v, o, i, d, s, e, t, W, a, l, l, e, t, Groups: (g, r, o, u, p, s: WalletGroup,[]) => v, o, i, d, s, e, t, S, e, l, e, c, t, edGroup: (g, r, o, u, p: string) => v, o, i, d, s, e, t, A, c, t, i, v, e, Wallet: (p, u, b, l, i, c, K, e, y: string | null) => v, o, i, d, u, p, d, a, t, e, W, a, l, letBalance: (p, u, b, l, i, c, K, e, y: string, b, a, l, a, n, c, e: number) => void//Token L, a, u, n, c, h, t, o, k, e, n, L, a, unchData: TokenLaunchData | n, u, l, l, s, e, t, T, o, k, e, n, L, aunchData: (d, a, t, a: TokenLaunchData) => void//Execution F, l, o, w, e, x, e, c, u, t, i, o, n, Strategy: E, x, e, c, u, t, i, o, n, S, t, r, a, tegysetExecutionStrategy: (s, t, r, a, t, e, g, y: ExecutionStrategy) => v, o, i, d, e, x, e, c, u, t, i, o, n, Steps: ExecutionStep,[] i, s, E, x, e, c, u, t, i, n, g: boolean//Control F, u, n, c, t, i, o, n, s, s, t, a, r, tExecution: () => v, o, i, d, s, t, o, p, E, x, e, c, u, tion: () => v, o, i, d, u, p, d, a, t, e, S, t, e, pStatus: ( s, t, e, p, I, d: string, s, t, a, t, u, s: ExecutionStep,['status'], m, e, s, s, a, g, e?: string) => v, o, i, d, r, e, s, e, t, E, x, e, c, ution: () => void//S, e, t, t, i, n, g, s, j, i, t, o, E, nabled: boolean, s, e, t, J, i, t, o, E, n, a, b, led: (e, n, a, b, l, e, d: boolean) => v, o, i, d, t, i, p, A, m, o, u, n, t: number, s, e, t, T, i, p, A, m, o, u, n, t: (a, m, o, u, n, t: number) => v, o, i, d, a, u, t, o, S, e, l, l, D, elay: number//s, e, c, o, n, d, s, s, e, t, A, u, t, oSellDelay: (d, e, l, a, y: number) => v, o, i, d, n, e, t, w, o, r, k: 'mainnet-beta' | 'devnet' s, e, t, N, e, t, w, o, r, k: (n, e, t, w, o, r, k: 'mainnet-beta' | 'devnet') => v, o, i, d, r, p, c, U, r, l: string, s, e, t, R, p, c, U, r, l: (u, r, l: string) => v, o, i, d, w, s, U, r, l: string, s, e, t, W, s, U, r, l: (u, r, l: string) => v, o, i, d, t, h, e, m, e: 'dark' | 'light' s, e, t, T, h, e, m, e: (t, h, e, m, e: 'dark' | 'light') => void//PnL T, r, a, c, k, i, n, g, t, o, t, a, l, Invested: number, t, o, t, a, l, R, e, t, u, r, n, ed: number, u, p, d, a, t, e, P, n, L: (i, n, v, e, s, t, e, d: number, r, e, t, u, r, n, e, d: number) => void//N, o, t, i, f, i, c, a, t, i, o, n, s, notifications: Notification,[] a, d, d, N, o, t, i, f, i, c, a, t, i, on: ( n, o, t, i, f, i, c, a, t, i, o, n: Omit < Notification, 'id' | 'timestamp'>) => v, o, i, d, r, e, m, o, v, e, N, o, t, ification: (i, d: string) => v, o, i, d, c, l, e, a, r, N, o, t, i, fications: () => v, o, i, d, m, a, r, k, N, o, t, i, f, icationAsRead: (i, d: string) => void//UI S, t, a, t, e, b, u, n, d, l, e, M, o, de: 'flash' | 'stealth' | 'manual' s, e, t, B, u, n, d, l, e, M, o, d, e: (m, o, d, e: 'flash' | 'stealth' | 'manual') => v, o, i, d, s, e, t, t, i, n, g, s, L, oaded: boolean, s, e, t, S, e, t, t, i, n, g, s, Loaded: (l, o, a, d, e, d: boolean) => v, o, i, d, b, a, n, n, e, r, s: string,[] a, d, d, B, a, n, n, e, r: (b, a, n, n, e, r: string) => v, o, i, d, r, e, m, o, v, e, B, a, n, ner: (b, a, n, n, e, r: string) => void
} const d, e, f, a, u, l, t, E, x, e, c, u, t, ionSteps: ExecutionStep,[] = [ { i, d: 'deploy', n, a, m, e: 'ğŸš€ Deploy Token', s, t, a, t, u, s: 'pending' }, { i, d: 'fund', n, a, m, e: 'ğŸ’° Fund Wallets', s, t, a, t, u, s: 'pending' }, { i, d: 'wait-funding', n, a, m, e: 'â±ï¸ Wait 3s', s, t, a, t, u, s: 'pending' }, { i, d: 'bundle', n, a, m, e: 'ğŸ“¦ Bundle Buys', s, t, a, t, u, s: 'pending' }, { i, d: 'wait-sells', n, a, m, e: 'â±ï¸ Wait 60s', s, t, a, t, u, s: 'pending' }, { i, d: 'sell', n, a, m, e: 'ğŸ’¸ Sell Sniper Wallets', s, t, a, t, u, s: 'pending' }, { i, d: 'complete', n, a, m, e: 'âœ… Complete', s, t, a, t, u, s: 'pending' },
] export const use Keymaker Store = create < KeymakerStore >()( d e v tools( (set) => ({ //Initial s, t, a, t, e, w, a, l, l, e, t, s: [], w, a, l, l, e, t, G, r, o, u, p, s: [{ i, d: 'default', n, a, m, e: 'Default Group', w, a, l, l, e, t, I, d, s: [] }], s, e, l, e, c, t, e, d, G, r, o, u, p: 'default', a, c, t, i, v, e, W, a, l, l, e, t: null, t, o, k, e, n, L, a, u, n, c, h, D, a, ta: null, e, x, e, c, u, t, i, o, n, S, t, r, a, tegy: 'flash', e, x, e, c, u, t, i, o, n, S, t, e, p, s: [...defaultExecutionSteps], i, s, E, x, e, c, u, t, i, n, g: false, j, i, t, o, E, n, a, b, l, e, d: true, t, i, p, A, m, o, u, n, t: 0.001, a, u, t, o, S, e, l, l, D, e, l, a, y: 60, n, e, t, w, o, r, k: 'mainnet-beta', r, p, c, U, r, l: 'h, t, t, p, s://api.mainnet-beta.solana.com', w, s, U, r, l: 'w, s, s://api.mainnet-beta.solana.com', t, h, e, m, e: (typeof window !== 'undefined' && (localStorage.g e tI tem('theme') as 'dark' | 'light')) || 'dark', t, o, t, a, l, I, n, v, e, s, t, e, d: 0, t, o, t, a, l, R, e, t, u, r, n, e, d: 0, n, o, t, i, f, i, c, a, t, i, o, n, s: [], b, u, n, d, l, e, M, o, d, e: 'flash', s, e, t, t, i, n, g, s, L, o, a, d, e, d: false, b, a, n, n, e, r, s: [],//A, c, t, i, o, n, s, s, e, t, W, a, l, lets: (wallets) => s et({ wallets }), a, d, d, W, a, l, l, e, t: (wallet) => s et((state) => { const n, e, w, W, a, l, l, e, t: Wal let Data = { ...wallet, i, d: `wallet_$,{Date.n o w() }
_$,{Math.r a n dom().t oS t ring(36).s u b str(2, 9) }`, b, a, l, a, n, c, e: 0 } return, { w, a, l, l, e, t, s: [...state.wallets, newWallet] }
}), s, e, t, W, a, l, l, e, t, G, r, o, u, ps: (groups) => s et({ w, a, l, l, e, t, G, r, o, u, p, s: groups }), s, e, t, S, e, l, e, c, t, e, d, G, r, oup: (group) => s et({ s, e, l, e, c, t, e, d, G, r, o, u, p: group }), s, e, t, A, c, t, i, v, e, W, a, l, l, et: (publicKey) => s et({ a, c, t, i, v, e, W, a, l, l, e, t: publicKey }), u, p, d, a, t, e, W, a, l, l, e, t, B, alance: (publicKey, balance) => s et((state) => ({ w, a, l, l, e, t, s: state.wallets.m ap((w) => w.public Key === publicKey ? { ...w, balance } : w) })), s, e, t, T, o, k, e, n, L, a, u, n, c, hData: (data) => s et({ t, o, k, e, n, L, a, u, n, c, h, D, a, ta: data }), s, e, t, E, x, e, c, u, t, i, o, n, S, trategy: (strategy) => s et({ e, x, e, c, u, t, i, o, n, S, t, r, a, tegy: strategy }), s, t, a, r, t, E, x, e, c, u, t, i, o, n: () => { s et({ i, s, E, x, e, c, u, t, i, n, g: true, e, x, e, c, u, t, i, o, n, S, t, e, p, s: [...defaultExecutionSteps] }) }, s, t, o, p, E, x, e, c, u, t, i, o, n: () => { s et({ i, s, E, x, e, c, u, t, i, n, g: false }) }, u, p, d, a, t, e, S, t, e, p, S, t, a, tus: (stepId, status, message) => s et((state) => ({ e, x, e, c, u, t, i, o, n, S, t, e, p, s: state.executionSteps.m ap((step) => step.id === stepId ? { ...step, status, message, t, i, m, e, s, t, a, m, p: Date.n o w() } : step) })), r, e, s, e, t, E, x, e, c, u, t, i, o, n: () => s et({ i, s, E, x, e, c, u, t, i, n, g: false, e, x, e, c, u, t, i, o, n, S, t, e, p, s: [...defaultExecutionSteps] }), s, e, t, J, i, t, o, E, n, a, b, l, e, d: (enabled) => s et({ j, i, t, o, E, n, a, b, l, e, d: enabled }), s, e, t, T, i, p, A, m, o, u, n, t: (amount) => s et({ t, i, p, A, m, o, u, n, t: amount }), s, e, t, A, u, t, o, S, e, l, l, D, e, lay: (delay) => s et({ a, u, t, o, S, e, l, l, D, e, l, a, y: delay }), s, e, t, N, e, t, w, o, r, k: (network) => s et({ network }), s, e, t, R, p, c, U, r, l: (url) => s et({ r, p, c, U, r, l: url }), s, e, t, W, s, U, r, l: (url) => s et({ w, s, U, r, l: url }), s, e, t, T, h, e, m, e: (theme) => s et({ theme }), u, p, d, a, t, e, P, n, L: (invested, returned) => s et((state) => ({ t, o, t, a, l, I, n, v, e, s, t, e, d: state.totalInvested + invested, t, o, t, a, l, R, e, t, u, r, n, e, d: state.totalReturned + returned })), a, d, d, N, o, t, i, f, i, c, a, t, i, on: (notification) => s et((state) => ({ n, o, t, i, f, i, c, a, t, i, o, n, s: [ { ...notification, i, d: crypto.r a n domUUID(), t, i, m, e, s, t, a, m, p: Date.n o w(), r, e, a, d: false }, ...state.notifications, ].s lice(0, 100),//Keep max 100 notifications })), r, e, m, o, v, e, N, o, t, i, f, i, c, ation: (id) => s et((state) => ({ n, o, t, i, f, i, c, a, t, i, o, n, s: state.notifications.f i l ter((n) => n.id !== id) })), c, l, e, a, r, N, o, t, i, f, i, c, a, tions: () => s et({ n, o, t, i, f, i, c, a, t, i, o, n, s: [] }), m, a, r, k, N, o, t, i, f, i, c, a, t, ionAsRead: (id) => s et((state) => ({ n, o, t, i, f, i, c, a, t, i, o, n, s: state.notifications.m ap((n) => n.id === id ? { ...n, r, e, a, d: true } : n) })), s, e, t, B, u, n, d, l, e, M, o, d, e: (mode) => s et({ b, u, n, d, l, e, M, o, d, e: mode }), s, e, t, S, e, t, t, i, n, g, s, L, o, aded: (loaded) => s et({ s, e, t, t, i, n, g, s, L, o, a, d, e, d: loaded }), a, d, d, B, a, n, n, e, r: (banner) => s et((state) => ({ b, a, n, n, e, r, s: [...state.banners, banner] })), r, e, m, o, v, e, B, a, n, n, e, r: (banner) => s et((state) => ({ b, a, n, n, e, r, s: state.banners.f i l ter((b) => b !== banner) })) }), { n, a, m, e: 'keymaker-store' }))
