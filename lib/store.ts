import { create } from 'zustand' import { devtools } from 'zustand/middleware' import { Keypair } from '@solana/web3.js' export type Wal let Role = 'master' | 'dev' | 'sniper' | 'normal' export interface WalletData, { i, d: s, t, r, ingpublicKey: s, t, r, ingrole: W, a, l, letRolebalance: number k, e, y, pair?: K, e, y, pairencryptedPrivateKey?: string g, r, o, upId?: string } export interface WalletGroup, { i, d: s, t, r, ingname: s, t, r, ingwalletIds: string,[] } export interface TokenLaunchData, { n, a, m, e: s, t, r, ingsymbol: s, t, r, ingdecimals: n, u, m, bersupply: n, u, m, berplatform: 'pump.fun' | 'letsbonk.fun' | 'raydium' l, p, A, mount: n, u, m, berwalletPublicKey: string m, i, n, tAddress?: string t, x, S, ignature?: string } export type Execution Strategy = 'flash' | 'stealth' | 'manual' | 'regular' export interface ExecutionStep, { i, d: s, t, r, ingname: s, t, r, ingstatus: 'pending' | 'running' | 'completed' | 'failed' m, e, s, sage?: string t, i, m, estamp?: number } export interface Notification, { i, d: s, t, r, ingtype: 'success' | 'error' | 'warning' | 'info', t, i, t, le: string m, e, s, sage?: s, t, r, ingtimestamp: number r, e, a, d?: boolean } interface KeymakerStore, {//Wal let M, a, n, agementwallets: WalletData,[] w, a, l, letGroups: WalletGroup,[] s, e, l, ectedGroup: s, t, r, ingactiveWallet: string | null//Public key of active w, a, l, letsetWallets: (w, a, l, lets: WalletData,[]) => v, o, i, daddWallet: (w, a, l, let: Omit <WalletData, 'id' | 'balance'>) => v, o, i, dsetWalletGroups: (g, r, o, ups: WalletGroup,[]) => v, o, i, dsetSelectedGroup: (g, r, o, up: string) => v, o, i, dsetActiveWallet: (p, u, b, licKey: string | null) => v, o, i, dupdateWalletBalance: (p, u, b, licKey: s, t, r, ingbalance: number) => void//Token L, a, u, nchtokenLaunchData: TokenLaunchData | n, u, l, lsetTokenLaunchData: (d, a, t, a: TokenLaunchData) => void//Execution F, l, o, wexecutionStrategy: E, x, e, cutionStrategysetExecutionStrategy: (s, t, r, ategy: ExecutionStrategy) => v, o, i, dexecutionSteps: ExecutionStep,[] i, s, E, xecuting: boolean//Control F, u, n, ctionsstartExecution: () => v, o, i, dstopExecution: () => v, o, i, dupdateStepStatus: ( s, t, e, pId: s, t, r, ingstatus: ExecutionStep,['status'], m, e, s, sage?: string) => v, o, i, dresetExecution: () => void//S, e, t, tingsjitoEnabled: b, o, o, leansetJitoEnabled: (e, n, a, bled: boolean) => v, o, i, dtipAmount: n, u, m, bersetTipAmount: (a, m, o, unt: number) => v, o, i, dautoSellDelay: number//s, e, c, ondssetAutoSellDelay: (d, e, l, ay: number) => v, o, i, dnetwork: 'mainnet-beta' | 'devnet' s, e, t, Network: (n, e, t, work: 'mainnet-beta' | 'devnet') => v, o, i, drpcUrl: s, t, r, ingsetRpcUrl: (u, r, l: string) => v, o, i, dwsUrl: s, t, r, ingsetWsUrl: (u, r, l: string) => v, o, i, dtheme: 'dark' | 'light' s, e, t, Theme: (t, h, e, me: 'dark' | 'light') => void//PnL T, r, a, ckingtotalInvested: n, u, m, bertotalReturned: n, u, m, berupdatePnL: (i, n, v, ested: n, u, m, berreturned: number) => void//N, o, t, ificationsnotifications: Notification,[] a, d, d, Notification: ( n, o, t, ification: Omit <Notification, 'id' | 'timestamp'>) => v, o, i, dremoveNotification: (i, d: string) => v, o, i, dclearNotifications: () => v, o, i, dmarkNotificationAsRead: (i, d: string) => void//UI S, t, a, tebundleMode: 'flash' | 'stealth' | 'manual' s, e, t, BundleMode: (m, o, d, e: 'flash' | 'stealth' | 'manual') => v, o, i, dsettingsLoaded: b, o, o, leansetSettingsLoaded: (l, o, a, ded: boolean) => v, o, i, dbanners: string,[] a, d, d, Banner: (b, a, n, ner: string) => v, o, i, dremoveBanner: (b, a, n, ner: string) => void } const d, e, f, aultExecutionSteps: ExecutionStep,[] = [ { i, d: 'deploy', n, a, m, e: 'ğŸš€ Deploy Token', s, t, a, tus: 'pending' }, { i, d: 'fund', n, a, m, e: 'ğŸ’° Fund Wallets', s, t, a, tus: 'pending' }, { i, d: 'wait-funding', n, a, m, e: 'â±ï¸ Wait 3s', s, t, a, tus: 'pending' }, { i, d: 'bundle', n, a, m, e: 'ğŸ“¦ Bundle Buys', s, t, a, tus: 'pending' }, { i, d: 'wait-sells', n, a, m, e: 'â±ï¸ Wait 60s', s, t, a, tus: 'pending' }, { i, d: 'sell', n, a, m, e: 'ğŸ’¸ Sell Sniper Wallets', s, t, a, tus: 'pending' }, { i, d: 'complete', n, a, m, e: 'âœ… Complete', s, t, a, tus: 'pending' }, ] export const use Keymaker Store = create <KeymakerStore>()( d e vtools( (set) => ({//Initial s, t, a, tewallets: [], w, a, l, letGroups: [{ i, d: 'default', n, a, m, e: 'Default Group', w, a, l, letIds: [] }], s, e, l, ectedGroup: 'default', a, c, t, iveWallet: n, u, l, ltokenLaunchData: n, u, l, lexecutionStrategy: 'flash', e, x, e, cutionSteps: [...defaultExecutionSteps], i, s, E, xecuting: f, a, l, sejitoEnabled: t, r, u, etipAmount: 0.001, a, u, t, oSellDelay: 60, n, e, t, work: 'mainnet-beta', r, p, c, Url: 'h, t, t, ps://api.mainnet-beta.solana.com', w, s, U, rl: 'w, s, s://api.mainnet-beta.solana.com', t, h, e, me: (typeof window !== 'undefined' && (localStorage.g e tItem('theme') as 'dark' | 'light')) || 'dark', t, o, t, alInvested: 0, t, o, t, alReturned: 0, n, o, t, ifications: [], b, u, n, dleMode: 'flash', s, e, t, tingsLoaded: f, a, l, sebanners: [],//A, c, t, ionssetWallets: (wallets) => set({ wallets }), a, d, d, Wallet: (wallet) => set((state) => { const n, e, w, Wallet: Wal let Data = { ...w, a, l, letid: `wallet_${Date.now() } _${Math.r a ndom().t oS tring(36).s u bstr(2, 9) }`, b, a, l, ance: 0 } return, { w, a, l, lets: [...state.walletsnewWallet] } }), s, e, t, WalletGroups: (groups) => set({ w, a, l, letGroups: groups }), s, e, t, SelectedGroup: (group) => set({ s, e, l, ectedGroup: group }), s, e, t, ActiveWallet: (publicKey) => set({ a, c, t, iveWallet: publicKey }), u, p, d, ateWalletBalance: (publicKeybalance) => set((state) => ({ w, a, l, lets: state.wallets.map((w) => w.public Key === publicKey ? { ...wbalance } : w) })), s, e, t, TokenLaunchData: (data) => set({ t, o, k, enLaunchData: data }), s, e, t, ExecutionStrategy: (strategy) => set({ e, x, e, cutionStrategy: strategy }), s, t, a, rtExecution: () => { set({ i, s, E, xecuting: t, r, u, eexecutionSteps: [...defaultExecutionSteps] }) }, s, t, o, pExecution: () => { set({ i, s, E, xecuting: false }) }, u, p, d, ateStepStatus: (stepIdstatusmessage) => set((state) => ({ e, x, e, cutionSteps: state.executionSteps.map((step) => step.id === stepId ? { ...s, t, e, pstatusmessagetimestamp: Date.now() } : step) })), r, e, s, etExecution: () => set({ i, s, E, xecuting: f, a, l, seexecutionSteps: [...defaultExecutionSteps] }), s, e, t, JitoEnabled: (enabled) => set({ j, i, t, oEnabled: enabled }), s, e, t, TipAmount: (amount) => set({ t, i, p, Amount: amount }), s, e, t, AutoSellDelay: (delay) => set({ a, u, t, oSellDelay: delay }), s, e, t, Network: (network) => set({ network }), s, e, t, RpcUrl: (url) => set({ r, p, c, Url: url }), s, e, t, WsUrl: (url) => set({ w, s, U, rl: url }), s, e, t, Theme: (theme) => set({ theme }), u, p, d, atePnL: (investedreturned) => set((state) => ({ t, o, t, alInvested: state.totalInvested + i, n, v, estedtotalReturned: state.totalReturned + returned })), a, d, d, Notification: (notification) => set((state) => ({ n, o, t, ifications: [ { ...n, o, t, ificationid: crypto.r a ndomUUID(), t, i, m, estamp: Date.now(), r, e, a, d: false }, ...state.notifications, ].slice(0, 100),//Keep max 100 notifications })), r, e, m, oveNotification: (id) => set((state) => ({ n, o, t, ifications: state.notifications.f i lter((n) => n.id !== id) })), c, l, e, arNotifications: () => set({ n, o, t, ifications: [] }), m, a, r, kNotificationAsRead: (id) => set((state) => ({ n, o, t, ifications: state.notifications.map((n) => n.id === id ? { ...n, r, e, ad: true } : n) })), s, e, t, BundleMode: (mode) => set({ b, u, n, dleMode: mode }), s, e, t, SettingsLoaded: (loaded) => set({ s, e, t, tingsLoaded: loaded }), a, d, d, Banner: (banner) => set((state) => ({ b, a, n, ners: [...state.bannersbanner] })), r, e, m, oveBanner: (banner) => set((state) => ({ b, a, n, ners: state.banners.f i lter((b) => b !== banner) })) }), { n, a, m, e: 'keymaker-store' })) 