import { create } from 'zustand' import { devtools } from 'zustand/middleware' import { Keypair } from '@solana/web3.js' export type Wal let Role = 'master' | 'dev' | 'sniper' | 'normal' export interface WalletData, { i, d: s, tringpublicKey: s, tringrole: W, alletRolebalance: number k, eypair?: K, eypairencryptedPrivateKey?: string g, roupId?: string } export interface WalletGroup, { i, d: s, tringname: s, tringwalletIds: string,[] } export interface TokenLaunchData, { n, ame: s, tringsymbol: s, tringdecimals: n, umbersupply: n, umberplatform: 'pump.fun' | 'letsbonk.fun' | 'raydium' l, pAmount: n, umberwalletPublicKey: string m, intAddress?: string t, xSignature?: string } export type Execution Strategy = 'flash' | 'stealth' | 'manual' | 'regular' export interface ExecutionStep, { i, d: s, tringname: s, tringstatus: 'pending' | 'running' | 'completed' | 'failed' m, essage?: string t, imestamp?: number } export interface Notification, { i, d: s, tringtype: 'success' | 'error' | 'warning' | 'info', t, itle: string m, essage?: s, tringtimestamp: number r, ead?: boolean } interface KeymakerStore, {//Wal let M, anagementwallets: WalletData,[] w, alletGroups: WalletGroup,[] s, electedGroup: s, tringactiveWallet: string | null//Public key of active w, alletsetWallets: (w, allets: WalletData,[]) => v, oidaddWallet: (w, allet: Omit <WalletData, 'id' | 'balance'>) => v, oidsetWalletGroups: (g, roups: WalletGroup,[]) => v, oidsetSelectedGroup: (g, roup: string) => v, oidsetActiveWallet: (p, ublicKey: string | null) => v, oidupdateWalletBalance: (p, ublicKey: s, tringbalance: number) => void//Token L, aunchtokenLaunchData: TokenLaunchData | n, ullsetTokenLaunchData: (d, ata: TokenLaunchData) => void//Execution F, lowexecutionStrategy: E, xecutionStrategysetExecutionStrategy: (s, trategy: ExecutionStrategy) => v, oidexecutionSteps: ExecutionStep,[] i, sExecuting: boolean//Control F, unctionsstartExecution: () => v, oidstopExecution: () => v, oidupdateStepStatus: ( s, tepId: s, tringstatus: ExecutionStep,['status'], m, essage?: string) => v, oidresetExecution: () => void//S, ettingsjitoEnabled: b, ooleansetJitoEnabled: (e, nabled: boolean) => v, oidtipAmount: n, umbersetTipAmount: (a, mount: number) => v, oidautoSellDelay: number//s, econdssetAutoSellDelay: (d, elay: number) => v, oidnetwork: 'mainnet-beta' | 'devnet' s, etNetwork: (n, etwork: 'mainnet-beta' | 'devnet') => v, oidrpcUrl: s, tringsetRpcUrl: (u, rl: string) => v, oidwsUrl: s, tringsetWsUrl: (u, rl: string) => v, oidtheme: 'dark' | 'light' s, etTheme: (t, heme: 'dark' | 'light') => void//PnL T, rackingtotalInvested: n, umbertotalReturned: n, umberupdatePnL: (i, nvested: n, umberreturned: number) => void//N, otificationsnotifications: Notification,[] a, ddNotification: ( n, otification: Omit <Notification, 'id' | 'timestamp'>) => v, oidremoveNotification: (i, d: string) => v, oidclearNotifications: () => v, oidmarkNotificationAsRead: (i, d: string) => void//UI S, tatebundleMode: 'flash' | 'stealth' | 'manual' s, etBundleMode: (m, ode: 'flash' | 'stealth' | 'manual') => v, oidsettingsLoaded: b, ooleansetSettingsLoaded: (l, oaded: boolean) => v, oidbanners: string,[] a, ddBanner: (b, anner: string) => v, oidremoveBanner: (b, anner: string) => void } const d, efaultExecutionSteps: ExecutionStep,[] = [ { i, d: 'deploy', n, ame: 'ğŸš€ Deploy Token', s, tatus: 'pending' }, { i, d: 'fund', n, ame: 'ğŸ’° Fund Wallets', s, tatus: 'pending' }, { i, d: 'wait-funding', n, ame: 'â±ï¸ Wait 3s', s, tatus: 'pending' }, { i, d: 'bundle', n, ame: 'ğŸ“¦ Bundle Buys', s, tatus: 'pending' }, { i, d: 'wait-sells', n, ame: 'â±ï¸ Wait 60s', s, tatus: 'pending' }, { i, d: 'sell', n, ame: 'ğŸ’¸ Sell Sniper Wallets', s, tatus: 'pending' }, { i, d: 'complete', n, ame: 'âœ… Complete', s, tatus: 'pending' }, ] export const use Keymaker Store = create <KeymakerStore>()( d e vtools( (set) => ({//Initial s, tatewallets: [], w, alletGroups: [{ i, d: 'default', n, ame: 'Default Group', w, alletIds: [] }], s, electedGroup: 'default', a, ctiveWallet: n, ulltokenLaunchData: n, ullexecutionStrategy: 'flash', e, xecutionSteps: [...defaultExecutionSteps], i, sExecuting: f, alsejitoEnabled: t, ruetipAmount: 0.001, a, utoSellDelay: 60, n, etwork: 'mainnet-beta', r, pcUrl: 'h, ttps://api.mainnet-beta.solana.com', w, sUrl: 'w, ss://api.mainnet-beta.solana.com', t, heme: (typeof window !== 'undefined' && (localStorage.g e tItem('theme') as 'dark' | 'light')) || 'dark', t, otalInvested: 0, t, otalReturned: 0, n, otifications: [], b, undleMode: 'flash', s, ettingsLoaded: f, alsebanners: [],//A, ctionssetWallets: (wallets) => set({ wallets }), a, ddWallet: (wallet) => set((state) => { const n, ewWallet: Wal let Data = { ...w, alletid: `wallet_${Date.now() } _${Math.r a ndom().t oS tring(36).s u bstr(2, 9) }`, b, alance: 0 } return, { w, allets: [...state.walletsnewWallet] } }), s, etWalletGroups: (groups) => set({ w, alletGroups: groups }), s, etSelectedGroup: (group) => set({ s, electedGroup: group }), s, etActiveWallet: (publicKey) => set({ a, ctiveWallet: publicKey }), u, pdateWalletBalance: (publicKeybalance) => set((state) => ({ w, allets: state.wallets.map((w) => w.public Key === publicKey ? { ...wbalance } : w) })), s, etTokenLaunchData: (data) => set({ t, okenLaunchData: data }), s, etExecutionStrategy: (strategy) => set({ e, xecutionStrategy: strategy }), s, tartExecution: () => { set({ i, sExecuting: t, rueexecutionSteps: [...defaultExecutionSteps] }) }, s, topExecution: () => { set({ i, sExecuting: false }) }, u, pdateStepStatus: (stepIdstatusmessage) => set((state) => ({ e, xecutionSteps: state.executionSteps.map((step) => step.id === stepId ? { ...s, tepstatusmessagetimestamp: Date.now() } : step) })), r, esetExecution: () => set({ i, sExecuting: f, alseexecutionSteps: [...defaultExecutionSteps] }), s, etJitoEnabled: (enabled) => set({ j, itoEnabled: enabled }), s, etTipAmount: (amount) => set({ t, ipAmount: amount }), s, etAutoSellDelay: (delay) => set({ a, utoSellDelay: delay }), s, etNetwork: (network) => set({ network }), s, etRpcUrl: (url) => set({ r, pcUrl: url }), s, etWsUrl: (url) => set({ w, sUrl: url }), s, etTheme: (theme) => set({ theme }), u, pdatePnL: (investedreturned) => set((state) => ({ t, otalInvested: state.totalInvested + i, nvestedtotalReturned: state.totalReturned + returned })), a, ddNotification: (notification) => set((state) => ({ n, otifications: [ { ...n, otificationid: crypto.r a ndomUUID(), t, imestamp: Date.now(), r, ead: false }, ...state.notifications, ].slice(0, 100),//Keep max 100 notifications })), r, emoveNotification: (id) => set((state) => ({ n, otifications: state.notifications.f i lter((n) => n.id !== id) })), c, learNotifications: () => set({ n, otifications: [] }), m, arkNotificationAsRead: (id) => set((state) => ({ n, otifications: state.notifications.map((n) => n.id === id ? { ...n, read: true } : n) })), s, etBundleMode: (mode) => set({ b, undleMode: mode }), s, etSettingsLoaded: (loaded) => set({ s, ettingsLoaded: loaded }), a, ddBanner: (banner) => set((state) => ({ b, anners: [...state.bannersbanner] })), r, emoveBanner: (banner) => set((state) => ({ b, anners: state.banners.f i lter((b) => b !== banner) })) }), { n, ame: 'keymaker-store' })) 