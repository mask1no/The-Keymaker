import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { Keypair } from '@solana/web3.js'

export type Wal let Role = 'master' | 'dev' | 'sniper' | 'normal' export interface WalletData, { i, d: string, p, u, b, l, i, c, K, e, y: string, r, o, l, e: W, a, l, l, e, t, R, o, l, e, balance: number k, e, y, p, a, i, r?: K, e, y, p, a, i, r, e, ncryptedPrivateKey?: string g, r, o, u, p, I, d?: string
} export interface WalletGroup, { i, d: string, n, a, m, e: string, w, a, l, l, e, t, I, d, s: string,[]
} export interface TokenLaunchData, { n, a, m, e: string, s, y, m, b, o, l: string, d, e, c, i, m, a, l, s: number, s, u, p, p, l, y: number, p, l, a, t, f, o, r, m: 'pump.fun' | 'letsbonk.fun' | 'raydium' l, p, A, m, o, u, n, t: number, w, a, l, l, e, t, P, u, blicKey: string m, i, n, t, A, d, d, ress?: string tx, S, i, g, n, a, ture?: string
} export type Execution Strategy = 'flash' | 'stealth' | 'manual' | 'regular' export interface ExecutionStep, { i, d: string, n, a, m, e: string, s, t, atus: 'pending' | 'running' | 'completed' | 'failed' m, e, s, s, a, g, e?: string t, i, m, e, s, t, a, mp?: number
} export interface Notification, { i, d: string, t, y, pe: 'success' | 'error' | 'warning' | 'info', t, i, tle: string m, e, s, s, a, g, e?: string, t, i, m, e, s, t, a, m, p: number r, e, a, d?: boolean
} interface KeymakerStore, {//Wal let M, a, n, a, g, e, m, e, n, t, wallets: WalletData,[] w, a, l, l, e, t, G, r, o, u, ps: WalletGroup,[] s, e, l, e, c, t, e, d, G, r, oup: string, a, c, t, i, v, e, W, a, llet: string | null//Public key of active w, a, l, l, e, t, s, e, t, W, allets: (w, a, l, l, e, t, s: WalletData,[]) => v, o, i, d, a, d, d, W, a, l, let: (w, a, l, l, e, t: Omit <WalletData, 'id' | 'balance'>) => v, o, i, d, s, e, t, W, a, l, letGroups: (g, r, o, u, p, s: WalletGroup,[]) => v, o, i, d, s, e, t, S, e, l, ectedGroup: (g, r, o, u, p: string) => v, o, i, d, s, e, t, A, c, t, iveWallet: (p, u, b, l, i, c, K, e, y: string | null) => v, o, i, d, u, p, d, a, t, e, WalletBalance: (p, u, b, l, i, c, K, e, y: string, b, a, l, a, n, c, e: number) => void//Token L, a, u, n, c, h, t, o, k, e, nLaunchData: TokenLaunchData | n, u, l, l, s, e, t, T, o, k, enLaunchData: (d, a, t, a: TokenLaunchData) => void//Execution F, l, o, w, e, x, e, c, u, t, ionStrategy: E, x, e, c, u, t, i, o, n, S, trategysetExecutionStrategy: (s, t, r, a, t, e, g, y: ExecutionStrategy) => v, o, i, d, e, x, e, c, u, t, ionSteps: ExecutionStep,[] i, s, E, x, e, c, u, t, i, n, g: boolean//Control F, u, n, c, t, i, o, n, s, s, tartExecution: () => v, o, i, d, s, t, o, p, E, x, ecution: () => v, o, i, d, u, p, d, a, t, e, StepStatus: ( s, t, e, p, I, d: string, s, t, atus: ExecutionStep,['status'], m, e, s, s, a, g, e?: string) => v, o, i, d, r, e, s, e, t, E, xecution: () => void//S, e, t, t, i, n, g, s, j, i, toEnabled: boolean, s, e, t, J, i, t, o, E, nabled: (e, n, a, b, l, e, d: boolean) => v, o, i, d, t, i, p, A, m, o, unt: number, s, e, t, T, i, p, A, m, ount: (a, m, o, u, n, t: number) => v, o, i, d, a, u, t, o, S, e, llDelay: number//s, e, c, o, n, d, s, s, e, t, AutoSellDelay: (d, e, lay: number) => v, o, i, d, n, e, t, w, o, r, k: 'mainnet-beta' | 'devnet' s, e, t, N, e, t, w, o, r, k: (n, e, t, w, o, r, k: 'mainnet-beta' | 'devnet') => v, o, i, d, r, p, c, U, r, l: string, s, e, t, R, p, c, U, r, l: (u, r, l: string) => v, o, i, d, w, s, U, r, l: string, s, e, t, W, s, U, r, l: (u, r, l: string) => v, o, i, d, t, h, e, m, e: 'dark' | 'light' s, e, t, T, h, e, m, e: (t, h, e, m, e: 'dark' | 'light') => void//PnL T, r, a, c, k, i, n, g, t, o, talInvested: number, t, o, t, a, l, R, e, t, urned: number, u, p, d, a, t, e, P, n, L: (i, n, v, e, s, t, e, d: number, r, e, t, u, r, n, e, d: number) => void//N, o, t, i, f, i, c, a, t, i, onsnotifications: Notification,[] a, d, d, N, o, t, i, f, i, c, ation: ( n, o, t, i, f, i, c, a, t, i, on: Omit <Notification, 'id' | 'timestamp'>) => v, o, i, d, r, e, m, o, v, e, Notification: (i, d: string) => v, o, i, d, c, l, e, a, r, N, otifications: () => v, o, i, d, m, a, r, k, N, o, tificationAsRead: (i, d: string) => void//UI S, t, a, t, e, b, u, n, d, l, eMode: 'flash' | 'stealth' | 'manual' s, e, t, B, u, n, d, l, e, M, ode: (m, o, d, e: 'flash' | 'stealth' | 'manual') => v, o, i, d, s, e, t, t, i, n, gsLoaded: boolean, s, e, t, S, e, t, t, i, ngsLoaded: (l, o, a, d, e, d: boolean) => v, o, i, d, b, a, n, n, e, r, s: string,[] a, d, d, B, a, n, n, e, r: (b, a, n, n, e, r: string) => v, o, i, d, r, e, m, o, v, e, Banner: (b, a, n, n, e, r: string) => void
} const d, e, f, a, u, l, t, E, x, e, cutionSteps: ExecutionStep,[] = [ { i, d: 'deploy', n, a, m, e: 'ğŸš€ Deploy Token', s, t, atus: 'pending' }, { i, d: 'fund', n, a, m, e: 'ğŸ’° Fund Wallets', s, t, atus: 'pending' }, { i, d: 'wait-funding', n, a, m, e: 'â±ï¸ Wait 3s', s, t, atus: 'pending' }, { i, d: 'bundle', n, a, m, e: 'ğŸ“¦ Bundle Buys', s, t, atus: 'pending' }, { i, d: 'wait-sells', n, a, m, e: 'â±ï¸ Wait 60s', s, t, atus: 'pending' }, { i, d: 'sell', n, a, m, e: 'ğŸ’¸ Sell Sniper Wallets', s, t, atus: 'pending' }, { i, d: 'complete', n, a, m, e: 'âœ… Complete', s, t, atus: 'pending' },
] export const use Keymaker Store = create <KeymakerStore>()( d e vtools( (set) => ({//Initial s, t, a, t, e, w, a, l, l, e, ts: [], w, a, l, l, e, t, G, r, o, u, ps: [{ i, d: 'default', n, a, m, e: 'Default Group', w, a, l, l, e, t, I, d, s: [] }], s, e, l, e, c, t, e, d, G, r, oup: 'default', a, c, t, i, v, e, W, a, l, l, et: null, t, o, k, e, n, L, a, u, n, c, hData: null, e, x, e, c, u, t, i, o, n, S, trategy: 'flash', e, x, e, c, u, t, i, o, n, S, teps: [...defaultExecutionSteps], i, s, E, x, e, c, u, t, i, n, g: false, j, i, t, o, E, n, a, b, l, e, d: true, t, i, p, A, m, o, u, n, t: 0.001, a, u, t, o, S, e, l, l, D, e, lay: 60, n, e, t, w, o, r, k: 'mainnet-beta', r, p, c, U, r, l: 'h, t, t, p, s://api.mainnet-beta.solana.com', w, s, U, r, l: 'w, s, s://api.mainnet-beta.solana.com', t, h, e, m, e: (typeof window !== 'undefined' && (localStorage.g e tItem('theme') as 'dark' | 'light')) || 'dark', t, o, t, a, l, I, n, v, e, s, ted: 0, t, o, t, a, l, R, e, t, u, r, ned: 0, n, o, t, i, f, i, c, a, t, i, ons: [], b, u, n, d, l, e, M, o, d, e: 'flash', s, e, t, t, i, n, g, s, L, o, aded: false, b, a, n, n, e, r, s: [],//A, c, t, i, o, n, s, s, e, t, Wallets: (wallets) => set({ wallets }), a, d, d, W, a, l, l, e, t: (wallet) => set((state) => {
  const n, e, w, W, a, l, l, e, t: Wal let Data = { ...wallet, i, d: `wallet_${Date.n o w()
  }
_${Math.r a ndom().t oS tring(36).s u bstr(2, 9)
  }`, b, a, l, a, n, c, e: 0 } return, { w, a, l, l, e, t, s: [...state.wallets, newWallet] }
}), s, e, t, W, a, l, l, e, t, G, roups: (groups) => set({ w, a, l, l, e, t, G, r, o, u, ps: groups }), s, e, t, S, e, l, e, c, t, e, dGroup: (group) => set({ s, e, l, e, c, t, e, d, G, r, oup: group }), s, e, t, A, c, t, i, v, e, W, allet: (publicKey) => set({ a, c, t, i, v, e, W, a, l, l, et: publicKey }), u, p, d, a, t, e, W, a, l, l, etBalance: (publicKey, balance) => set((state) => ({ w, a, l, l, e, t, s: state.wallets.map((w) => w.public Key === publicKey ? { ...w, balance } : w)
  })), s, e, t, T, o, k, e, n, L, a, unchData: (data) => set({ t, o, k, e, n, L, a, u, n, c, hData: data }), s, e, t, E, x, e, c, u, t, i, onStrategy: (strategy) => set({ e, x, e, c, u, t, i, o, n, S, trategy: strategy }), s, t, a, r, t, E, x, e, c, u, tion: () => { set({ i, s, E, x, e, c, u, t, i, n, g: true, e, x, e, c, u, t, i, o, n, S, teps: [...defaultExecutionSteps] })
  }, s, t, o, p, E, x, e, c, u, t, ion: () => { set({ i, s, E, x, e, c, u, t, i, n, g: false })
  }, u, p, d, a, t, e, S, t, e, p, Status: (stepId, status, message) => set((state) => ({ e, x, e, c, u, t, i, o, n, S, teps: state.executionSteps.map((step) => step.id === stepId ? { ...step, status, message, t, i, m, e, s, t, a, m, p: Date.n o w()
  } : step)
  })), r, e, s, e, t, E, x, e, c, u, tion: () => set({ i, s, E, x, e, c, u, t, i, n, g: false, e, x, e, c, u, t, i, o, n, S, teps: [...defaultExecutionSteps] }), s, e, t, J, i, t, o, E, n, a, bled: (enabled) => set({ j, i, t, o, E, n, a, b, l, e, d: enabled }), s, e, t, T, i, p, A, m, o, u, nt: (amount) => set({ t, i, p, A, m, o, u, n, t: amount }), s, e, t, A, u, t, o, S, e, l, lDelay: (delay) => set({ a, u, t, o, S, e, l, l, D, e, lay: delay }), s, e, t, N, e, t, w, o, r, k: (network) => set({ network }), s, e, t, R, p, c, U, r, l: (url) => set({ r, p, c, U, r, l: url }), s, e, t, W, s, U, r, l: (url) => set({ w, s, U, r, l: url }), s, e, t, T, h, e, m, e: (theme) => set({ theme }), u, p, d, a, t, e, P, n, L: (invested, returned) => set((state) => ({ t, o, t, a, l, I, n, v, e, s, ted: state.totalInvested + invested, t, o, t, a, l, R, e, t, u, r, ned: state.totalReturned + returned })), a, d, d, N, o, t, i, f, i, c, ation: (notification) => set((state) => ({ n, o, t, i, f, i, c, a, t, i, ons: [ { ...notification, i, d: crypto.r a ndomUUID(), t, i, m, e, s, t, a, m, p: Date.n o w(), r, e, a, d: false }, ...state.notifications, ].slice(0, 100),//Keep max 100 notifications })), r, e, m, o, v, e, N, o, t, i, fication: (id) => set((state) => ({ n, o, t, i, f, i, c, a, t, i, ons: state.notifications.f i lter((n) => n.id !== id)
  })), c, l, e, a, r, N, o, t, i, f, ications: () => set({ n, o, t, i, f, i, c, a, t, i, ons: [] }), m, a, r, k, N, o, t, i, f, i, cationAsRead: (id) => set((state) => ({ n, o, t, i, f, i, c, a, t, i, ons: state.notifications.map((n) => n.id === id ? { ...n, r, e, a, d: true } : n)
  })), s, e, t, B, u, n, d, l, e, M, ode: (mode) => set({ b, u, n, d, l, e, M, o, d, e: mode }), s, e, t, S, e, t, t, i, n, g, sLoaded: (loaded) => set({ s, e, t, t, i, n, g, s, L, o, aded: loaded }), a, d, d, B, a, n, n, e, r: (banner) => set((state) => ({ b, a, n, n, e, r, s: [...state.banners, banner] })), r, e, m, o, v, e, B, a, n, n, er: (banner) => set((state) => ({ b, a, n, n, e, r, s: state.banners.f i lter((b) => b !== banner)
  }))
  }), { n, a, m, e: 'keymaker-store' }))
