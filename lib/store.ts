import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { Keypair } from '@solana/web3.js'

export type Wallet Role = 'master' | 'dev' | 'sniper' | 'normal' export interface WalletData, { id: string, p, u, b, l, i, c, Key: string, r, o, l, e: W, a, l, l, e, t, R, o, lebalance: number k, e, y, p, a, ir?: K, e, y, p, a, i, rencryptedPrivateKey?: string g, r, o, u, p, Id?: string
} export interface WalletGroup, { id: string, n, a, m, e: string, w, a, l, l, e, t, Ids: string,[]
} export interface TokenLaunchData, { n, a, m, e: string, s, y, m, b, o, l: string, d, e, c, i, m, a, ls: number, s, u, p, p, l, y: number, p, l, a, t, f, o, rm: 'pump.fun' | 'letsbonk.fun' | 'raydium' l, p, A, m, o, u, n, t: number, w, a, l, l, e, t, PublicKey: string m, i, n, t, A, ddress?: string tx, S, i, g, nature?: string
} export type Execution Strategy = 'flash' | 'stealth' | 'manual' | 'regular' export interface ExecutionStep, { id: string, n, a, m, e: string, status: 'pending' | 'running' | 'completed' | 'failed' m, e, s, s, a, ge?: string t, i, m, e, s, tamp?: number
} export interface Notification, { id: string, type: 'success' | 'error' | 'warning' | 'info', title: string m, e, s, s, a, ge?: string, t, i, m, e, s, t, amp: number r, e, a, d?: boolean
} interface KeymakerStore, {//Wallet M, a, n, a, g, e, m, e, ntwallets: WalletData,[] w, a, l, l, e, t, G, r, oups: WalletGroup,[] s, e, l, e, c, t, e, d, Group: string, a, c, t, i, v, e, Wallet: string | null//Public key of active w, a, l, l, e, t, s, e, tWallets: (w, a, l, l, e, t, s: WalletData,[]) => v, o, i, d, a, d, d, W, allet: (w, a, l, l, e, t: Omit <WalletData, 'id' | 'balance'>) => v, o, i, d, s, e, t, W, alletGroups: (g, r, o, u, p, s: WalletGroup,[]) => v, o, i, d, s, e, t, S, electedGroup: (g, r, o, u, p: string) => v, o, i, d, s, e, t, A, ctiveWallet: (p, u, b, l, i, c, K, ey: string | null) => v, o, i, d, u, p, d, a, teWalletBalance: (p, u, b, l, i, c, K, ey: string, b, a, l, a, n, c, e: number) => void//Token L, a, u, n, c, h, t, o, kenLaunchData: TokenLaunchData | n, u, l, l, s, e, t, T, okenLaunchData: (d, a, t, a: TokenLaunchData) => void//Execution F, l, o, w, e, x, e, c, utionStrategy: E, x, e, c, u, t, i, o, nStrategysetExecutionStrategy: (s, t, r, a, t, e, g, y: ExecutionStrategy) => v, o, i, d, e, x, e, c, utionSteps: ExecutionStep,[] i, s, E, x, e, c, u, t, ing: boolean//Control F, u, n, c, t, i, o, n, sstartExecution: () => v, o, i, d, s, t, o, p, Execution: () => v, o, i, d, u, p, d, a, teStepStatus: ( s, t, e, p, I, d: string, status: ExecutionStep,['status'], m, e, s, s, a, ge?: string) => v, o, i, d, r, e, s, e, tExecution: () => void//S, e, t, t, i, n, g, s, jitoEnabled: boolean, s, e, t, J, i, t, oEnabled: (e, n, a, b, l, e, d: boolean) => v, o, i, d, t, i, p, A, mount: number, s, e, t, T, i, p, Amount: (a, m, o, u, n, t: number) => v, o, i, d, a, u, t, o, SellDelay: number//s, e, c, o, n, d, s, s, etAutoSellDelay: (delay: number) => v, o, i, d, n, e, t, w, ork: 'mainnet-beta' | 'devnet' s, e, t, N, e, t, w, o, rk: (n, e, t, w, o, r, k: 'mainnet-beta' | 'devnet') => v, o, i, d, r, p, c, U, rl: string, s, e, t, R, p, c, Url: (u, r, l: string) => v, o, i, d, w, s, U, r, l: string, s, e, t, W, s, U, rl: (u, r, l: string) => v, o, i, d, t, h, e, m, e: 'dark' | 'light' s, e, t, T, h, e, m, e: (t, h, e, m, e: 'dark' | 'light') => void//PnL T, r, a, c, k, i, n, g, totalInvested: number, t, o, t, a, l, R, eturned: number, u, p, d, a, t, e, PnL: (i, n, v, e, s, t, e, d: number, r, e, t, u, r, n, e, d: number) => void//N, o, t, i, f, i, c, a, tionsnotifications: Notification,[] a, d, d, N, o, t, i, f, ication: ( n, o, t, i, f, i, c, a, tion: Omit <Notification, 'id' | 'timestamp'>) => v, o, i, d, r, e, m, o, veNotification: (id: string) => v, o, i, d, c, l, e, a, rNotifications: () => v, o, i, d, m, a, r, k, NotificationAsRead: (id: string) => void//UI S, t, a, t, e, b, u, n, dleMode: 'flash' | 'stealth' | 'manual' s, e, t, B, u, n, d, l, eMode: (m, o, d, e: 'flash' | 'stealth' | 'manual') => v, o, i, d, s, e, t, t, ingsLoaded: boolean, s, e, t, S, e, t, tingsLoaded: (l, o, a, d, e, d: boolean) => v, o, i, d, b, a, n, n, ers: string,[] a, d, d, B, a, n, n, e, r: (b, a, n, n, e, r: string) => v, o, i, d, r, e, m, o, veBanner: (b, a, n, n, e, r: string) => void
} const d, e, f, a, u, l, t, E, xecutionSteps: ExecutionStep,[] = [ { id: 'deploy', n, a, m, e: 'ğŸš€ Deploy Token', status: 'pending' }, { id: 'fund', n, a, m, e: 'ğŸ’° Fund Wallets', status: 'pending' }, { id: 'wait-funding', n, a, m, e: 'â±ï¸ Wait 3s', status: 'pending' }, { id: 'bundle', n, a, m, e: 'ğŸ“¦ Bundle Buys', status: 'pending' }, { id: 'wait-sells', n, a, m, e: 'â±ï¸ Wait 60s', status: 'pending' }, { id: 'sell', n, a, m, e: 'ğŸ’¸ Sell Sniper Wallets', status: 'pending' }, { id: 'complete', n, a, m, e: 'âœ… Complete', status: 'pending' },
] export const use Keymaker Store = create <KeymakerStore>()( d e vtools( (set) => ({//Initial s, t, a, t, e, w, a, l, lets: [], w, a, l, l, e, t, G, r, oups: [{ id: 'default', n, a, m, e: 'Default Group', w, a, l, l, e, t, I, d, s: [] }], s, e, l, e, c, t, e, d, Group: 'default', a, c, t, i, v, e, W, a, llet: null, t, o, k, e, n, L, a, u, nchData: null, e, x, e, c, u, t, i, o, nStrategy: 'flash', e, x, e, c, u, t, i, o, nSteps: [...defaultExecutionSteps], i, s, E, x, e, c, u, t, ing: false, j, i, t, o, E, n, a, b, led: true, t, i, p, A, m, o, u, n, t: 0.001, a, u, t, o, S, e, l, l, Delay: 60, n, e, t, w, o, r, k: 'mainnet-beta', r, p, c, U, r, l: 'h, t, t, p, s://api.mainnet-beta.solana.com', w, s, U, r, l: 'w, s, s://api.mainnet-beta.solana.com', t, h, e, m, e: (typeof window !== 'undefined' && (localStorage.g e tItem('theme') as 'dark' | 'light')) || 'dark', t, o, t, a, l, I, n, v, ested: 0, t, o, t, a, l, R, e, t, urned: 0, n, o, t, i, f, i, c, a, tions: [], b, u, n, d, l, e, M, o, de: 'flash', s, e, t, t, i, n, g, s, Loaded: false, b, a, n, n, e, r, s: [],//A, c, t, i, o, n, s, s, etWallets: (wallets) => set({ wallets }), a, d, d, W, a, l, l, e, t: (wallet) => set((state) => {
  const n, e, w, W, a, l, l, e, t: Wallet Data = { ...wallet, id: `wallet_${Date.n o w()
  }
_${Math.r a ndom().t oS tring(36).s u bstr(2, 9)
  }`, b, a, l, a, n, c, e: 0 } return, { w, a, l, l, e, t, s: [...state.wallets, newWallet] }
}), s, e, t, W, a, l, l, e, tGroups: (groups) => set({ w, a, l, l, e, t, G, r, oups: groups }), s, e, t, S, e, l, e, c, tedGroup: (group) => set({ s, e, l, e, c, t, e, d, Group: group }), s, e, t, A, c, t, i, v, eWallet: (publicKey) => set({ a, c, t, i, v, e, W, a, llet: publicKey }), u, p, d, a, t, e, W, a, lletBalance: (publicKey, balance) => set((state) => ({ w, a, l, l, e, t, s: state.wallets.map((w) => w.public Key === publicKey ? { ...w, balance } : w)
  })), s, e, t, T, o, k, e, n, LaunchData: (data) => set({ t, o, k, e, n, L, a, u, nchData: data }), s, e, t, E, x, e, c, u, tionStrategy: (strategy) => set({ e, x, e, c, u, t, i, o, nStrategy: strategy }), s, t, a, r, t, E, x, e, cution: () => { set({ i, s, E, x, e, c, u, t, ing: true, e, x, e, c, u, t, i, o, nSteps: [...defaultExecutionSteps] })
  }, s, t, o, p, E, x, e, c, ution: () => { set({ i, s, E, x, e, c, u, t, ing: false })
  }, u, p, d, a, t, e, S, t, epStatus: (stepId, status, message) => set((state) => ({ e, x, e, c, u, t, i, o, nSteps: state.executionSteps.map((step) => step.id === stepId ? { ...step, status, message, t, i, m, e, s, t, a, mp: Date.n o w()
  } : step)
  })), r, e, s, e, t, E, x, e, cution: () => set({ i, s, E, x, e, c, u, t, ing: false, e, x, e, c, u, t, i, o, nSteps: [...defaultExecutionSteps] }), s, e, t, J, i, t, o, E, nabled: (enabled) => set({ j, i, t, o, E, n, a, b, led: enabled }), s, e, t, T, i, p, A, m, ount: (amount) => set({ t, i, p, A, m, o, u, n, t: amount }), s, e, t, A, u, t, o, S, ellDelay: (delay) => set({ a, u, t, o, S, e, l, l, Delay: delay }), s, e, t, N, e, t, w, o, rk: (network) => set({ network }), s, e, t, R, p, c, U, r, l: (url) => set({ r, p, c, U, r, l: url }), s, e, t, W, s, U, r, l: (url) => set({ w, s, U, r, l: url }), s, e, t, T, h, e, m, e: (theme) => set({ theme }), u, p, d, a, t, e, P, n, L: (invested, returned) => set((state) => ({ t, o, t, a, l, I, n, v, ested: state.totalInvested + invested, t, o, t, a, l, R, e, t, urned: state.totalReturned + returned })), a, d, d, N, o, t, i, f, ication: (notification) => set((state) => ({ n, o, t, i, f, i, c, a, tions: [ { ...notification, id: crypto.r a ndomUUID(), t, i, m, e, s, t, a, mp: Date.n o w(), r, e, a, d: false }, ...state.notifications, ].slice(0, 100),//Keep max 100 notifications })), r, e, m, o, v, e, N, o, tification: (id) => set((state) => ({ n, o, t, i, f, i, c, a, tions: state.notifications.f i lter((n) => n.id !== id)
  })), c, l, e, a, r, N, o, t, ifications: () => set({ n, o, t, i, f, i, c, a, tions: [] }), m, a, r, k, N, o, t, i, ficationAsRead: (id) => set((state) => ({ n, o, t, i, f, i, c, a, tions: state.notifications.map((n) => n.id === id ? { ...n, r, e, a, d: true } : n)
  })), s, e, t, B, u, n, d, l, eMode: (mode) => set({ b, u, n, d, l, e, M, o, de: mode }), s, e, t, S, e, t, t, i, ngsLoaded: (loaded) => set({ s, e, t, t, i, n, g, s, Loaded: loaded }), a, d, d, B, a, n, n, e, r: (banner) => set((state) => ({ b, a, n, n, e, r, s: [...state.banners, banner] })), r, e, m, o, v, e, B, a, nner: (banner) => set((state) => ({ b, a, n, n, e, r, s: state.banners.f i lter((b) => b !== banner)
  }))
  }), { n, a, m, e: 'keymaker-store' }))
