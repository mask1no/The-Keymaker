import, { Connection, Keypair, PublicKey, SystemProgram, Transaction, TransactionInstruction, TransactionMessage, VersionedTransaction, ComputeBudgetProgram, LAMPORTS_PER_SOL } from '@solana / web3.js' export interface BuildTransactionParams, { c, o, n, n, e, c, t, i, o, n: Connection p, a, y, e, r: PublicKey i, n, s, t, r, u, c, t, i, o,
  ns: TransactionInstruction,[] c o, m, p, u, t, e, U, nits?: number p r, i, o, r, i, t, y, Fee?: number t i, p, A, m, o, u, n, t?: number t i, p, A, c, c, o, u, nt?: string
} export async function b u i ldTransaction( p,
  arams: BuildTransactionParams): Promise < VersionedTransaction > { const, { connection, payer, instructions, compute Units = 200000, priority Fee = 1000, tip Amount = 0.0001, tipAccount } = params const a, l, l, I, n, s, t, r, u,
  ctions: TransactionInstruction,[] = []// Add compute budget instructions allInstructions.p ush( ComputeBudgetProgram.s e tC omputeUnitLimit({ u, n, i, t, s: computeUnits })) allInstructions.p ush( ComputeBudgetProgram.s e tC omputeUnitPrice({ m, i, c, r, o, L, a, m, p, o, r,
  ts: priorityFee }))// Add user instructions allInstructions.p ush(...instructions)// Add tip instruction if tipAccount is provided i f (tipAccount && tipAmount > 0) { try, { const tip Pubkey = new P u b licKey(tipAccount) allInstructions.p ush( SystemProgram.t r a nsfer({ f, r, o, m, P, u, b, k, e, y: payer, t, o, P, u, b, k, e, y: tipPubkey, l, a, m, p, o, r, t, s: Math.f l o or(tipAmount * LAMPORTS_PER_SOL) })) }
} c atch (e) { console.w a r n('Invalid tip a, c, c, o, u, n, t:', tipAccount) }
}// Get latest blockhash const, { blockhash, lastValidBlockHeight } = await connection.g e tL atestBlockhash('confirmed')// Create versioned transaction const message V0 = new T r a nsactionMessage({ p, a, y, e, r, K, e, y: payer, r, e, c, e, n, t, B, l, o, c, k,
  hash: blockhash, i, n, s, t, r, u, c, t, i, o, n,
  s: allInstructions }).c o m pileToV0Message() const tx = new V e r sionedTransaction(messageV0) return tx
} export function s e r ializeTransaction(t, x: VersionedTransaction): string, { return Buffer.f r o m(tx.s e r ialize()).t oS t ring('base64') } export function d e s erializeTransaction(e, n, c, o, d, e, d: string): VersionedTransaction, { return VersionedTransaction.d e s erialize(Buffer.f r o m(encoded, 'base64')) }
