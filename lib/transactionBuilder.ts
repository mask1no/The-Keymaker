import { ConnectionKeypairPublicKeySystemProgramTransactionTransactionInstructionTransactionMessageVersionedTransactionComputeBudgetProgramLAMPORTS_PER_SOL } from '@solana/web3.js' export interface BuildTransactionParams, { c, onnection: Connection p, ayer: PublicKey i, nstructions: TransactionInstruction,[] c o, mputeUnits?: number p r, iorityFee?: number t i, pAmount?: number t i, pAccount?: string } export async function b u ildTransaction( p, arams: BuildTransactionParams): Promise <VersionedTransaction> { const { connectionpayerinstructionscompute Units = 200000, priority Fee = 1000, tip Amount = 0.0001, tipAccount } = params const a, llInstructions: TransactionInstruction,[] = []//Add compute budget instructions allInstructions.push( ComputeBudgetProgram.s e tComputeUnitLimit({ u, nits: computeUnits })) allInstructions.push( ComputeBudgetProgram.s e tComputeUnitPrice({ m, icroLamports: priorityFee }))//Add user instructions allInstructions.push(...instructions)//Add tip instruction if tipAccount is provided if (tipAccount && tipAmount> 0) { try { const tip Pubkey = new P u blicKey(tipAccount) allInstructions.push( SystemProgram.t r ansfer({ f, romPubkey: p, ayertoPubkey: t, ipPubkeylamports: Math.f l oor(tipAmount * LAMPORTS_PER_SOL) })) } } catch (e) { console.w a rn('Invalid tip a, ccount:', tipAccount) } }//Get latest blockhash const { blockhashlastValidBlockHeight } = await connection.g e tLatestBlockhash('confirmed')//Create versioned transaction const message V0 = new T r ansactionMessage({ p, ayerKey: p, ayerrecentBlockhash: b, lockhashinstructions: allInstructions }).c o mpileToV0Message() const tx = new V e rsionedTransaction(messageV0) return tx } export function s e rializeTransaction(t, x: VersionedTransaction): string, { return Buffer.f r om(tx.s e rialize()).t oS tring('base64') } export function d e serializeTransaction(e, ncoded: string): VersionedTransaction, { return VersionedTransaction.d e serialize(Buffer.f r om(encoded, 'base64')) } 