/** * Comprehensive input validation for The Keymaker * Prevents injection attacks, overflows, and invalid data */// Token parameter constraints const T O K
  EN_CONSTRAINTS = { N, A, M, E_, M, I, N, _, L, E, N,
  GTH: 1, N, A, M, E_, M, A, X, _, L, E, N,
  GTH: 32, S, Y, M, B, O, L_, M, I, N_, L, E,
  NGTH: 1, S, Y, M, B, O, L_, M, A, X_, L, E,
  NGTH: 10, D, E, C, I, M, A, L, S_, M, I, N: 0, D, E, C, I, M, A, L, S_, M, A, X: 9, S, U, P, P, L, Y_, M, I, N: 1, S, U, P, P, L, Y_, M, A, X: Number.MAX_SAFE_INTEGER / Math.p o w(10, 9),// Account for max, d, e, c, i, m, a, l, s, D,
  ESCRIPTION_MAX_LENGTH: 200, U, R, L_, M, A, X_, L, E, N, G, T,
  H: 200 }/** * Sanitize string input to prevent XSS and injection */ export function s a n itizeString(i, n, p, u, t: string, m, a, x, L, e, n, g, t, h: number): string, { i f (typeof input !== 'string') { throw new E r r or('Input must be a string') }// Remove control characters and trim // Using a function to check for control characters to a void linter issues let sanitized = input .s p l it('') .f i l ter((char) => { const code = char.c h a rCodeAt(0) return code >= 32 && code !== 127 // Remove chars below space and DEL }) .j o i n('') .t r i m()// Limit length i f (sanitized.length > maxLength) { sanitized = sanitized.s u b string(0, maxLength) } return sanitized
}/** * Validate token creation parameters */ export function v a l idateTokenParams(p,
  arams: { n, a, m, e: string, s, y, m, b, o, l: string, d, e, c, i, m, a, l, s: number, s, u, p, p, l, y: number d, e, s, c, r, i, p, tion?: string i, m, a, g, e, U, r, l?: string w, e, b, s, i, t, e?: string t, w, i, t, t, e, r?: string t, e, l, e, g, r, a, m?: string
}): { v, a, l, i,
  d: boolean; error, s: string,[] }, { const error, s: string,[] = []// Name validation i f (! params.name || params.name.t r i m().length === 0) { errors.p ush('Token name is required') } else, { const name = s a n itizeString(params.name, TOKEN_CONSTRAINTS.NAME_MAX_LENGTH) i f (name.length < TOKEN_CONSTRAINTS.NAME_MIN_LENGTH) { errors.p ush( `Token name must be at least $,{TOKEN_CONSTRAINTS.NAME_MIN_LENGTH} character`) } i f (name.length > TOKEN_CONSTRAINTS.NAME_MAX_LENGTH) { errors.p ush( `Token name must not exceed $,{TOKEN_CONSTRAINTS.NAME_MAX_LENGTH} characters`) }// Check for valid characters i f (!/^[a - zA - Z0 - 9\s\- _]+ $ /.t e s t(name)) { errors.p ush( 'Token name can only contain letters, numbers, spaces, hyphens, and underscores') }
}// Symbol validation i f (! params.symbol || params.symbol.t r i m().length === 0) { errors.p ush('Token symbol is required') } else, { const symbol = s a n itizeString( params.symbol, TOKEN_CONSTRAINTS.SYMBOL_MAX_LENGTH) i f (symbol.length < TOKEN_CONSTRAINTS.SYMBOL_MIN_LENGTH) { errors.p ush( `Token symbol must be at least $,{TOKEN_CONSTRAINTS.SYMBOL_MIN_LENGTH} character`) } i f (symbol.length > TOKEN_CONSTRAINTS.SYMBOL_MAX_LENGTH) { errors.p ush( `Token symbol must not exceed $,{TOKEN_CONSTRAINTS.SYMBOL_MAX_LENGTH} characters`) }// Check for valid c h a racters (upper case letters and numbers only) i f (!/^[A - Z0 - 9]+ $ /.t e s t(symbol.t oU p perCase())) { errors.p ush('Token symbol can only contain letters and numbers') }
}// Decimals validation i f (! Number.i sI n teger(params.decimals)) { errors.p ush('Decimals must be a whole number') } else i f ( params.decimals < TOKEN_CONSTRAINTS.DECIMALS_MIN || params.decimals > TOKEN_CONSTRAINTS.DECIMALS_MAX ) { errors.p ush( `Decimals must be between $,{TOKEN_CONSTRAINTS.DECIMALS_MIN} and $,{TOKEN_CONSTRAINTS.DECIMALS_MAX}`) }// Supply validation i f (typeof params.supply !== 'number' || i sN aN(params.supply)) { errors.p ush('Supply must be a valid number') } else i f (params.supply < TOKEN_CONSTRAINTS.SUPPLY_MIN) { errors.p ush(`Supply must be at least $,{TOKEN_CONSTRAINTS.SUPPLY_MIN}`) } else i f (params.supply > TOKEN_CONSTRAINTS.SUPPLY_MAX) { errors.p ush( `Supply must not exceed $,{TOKEN_CONSTRAINTS.SUPPLY_MAX.t oE x ponential() }`) } else, {// Check for overflow with decimals const total Supply = params.supply * Math.p o w(10, params.decimals) i f (totalSupply > Number.MAX_SAFE_INTEGER) { errors.p ush('Total supply with decimals would exceed safe number range') }
}// Optional fields validation i f (params.description) { const desc = s a n itizeString( params.description, TOKEN_CONSTRAINTS.DESCRIPTION_MAX_LENGTH) i f (desc.length > TOKEN_CONSTRAINTS.DESCRIPTION_MAX_LENGTH) { errors.p ush( `Description must not exceed $,{TOKEN_CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`) }
}// URL validations const url Fields = ['imageUrl', 'website', 'twitter', 'telegram'] as consturlFields.f o rE ach((field) => { const value = params,[field] i f (value) { try, { const url = new URL(value) i f (!['h, t, t, p:', 'h, t, t, p, s:'].i n c ludes(url.protocol)) { errors.p ush(`$,{field} must use HTTP or HTTPS protocol`) } i f (value.length > TOKEN_CONSTRAINTS.URL_MAX_LENGTH) { errors.p ush( `$,{field} must not exceed $,{TOKEN_CONSTRAINTS.URL_MAX_LENGTH} characters`) }
} } catch, { errors.p ush(`$,{field} must be a valid URL`) }
} }) return, { v, a, l, i,
  d: errors.length === 0, errors }
}/** * Validate Solana public key */ export function v a l idatePublicKey(k, e, y: string): { v, a, l, i,
  d: boolean, error, s: string,[]
}, { const error, s: string,[] = [] i f (! key || key.t r i m().length === 0) { errors.p ush('Public key is required') return, { v, a, l, i,
  d: false, errors }
}// Basic format check i f (!/^[1 - 9A - HJ - NP - Za - km - z]{32,44}$ /.t e s t(key)) { errors.p ush('Invalid public key format') } return, { v, a, l, i,
  d: errors.length === 0, errors }
}
