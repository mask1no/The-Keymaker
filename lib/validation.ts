/** * Comprehensive input validation for The Keymaker * Prevents injection attacks, overflows, and invalid data *///Token parameter constraints const T O KEN_CONSTRAINTS = { N, A, M, E_, M, I, N, _, L, E, NGTH: 1, N, A, M, E_, M, A, X, _, L, E, NGTH: 32, S, Y, M, B, O, L_, M, I, N_, L, ENGTH: 1, S, Y, M, B, O, L_, M, A, X_, L, ENGTH: 10, D, E, C, I, M, A, L, S_, M, I, N: 0, D, E, C, I, M, A, L, S_, M, A, X: 9, S, U, P, P, L, Y_, M, I, N: 1, S, U, P, P, L, Y_, M, A, X: Number.MAX_SAFE_INTEGER/Math.p o w(10, 9),//Account for max, d, e, c, i, m, a, l, s, DESCRIPTION_MAX_LENGTH: 200, U, R, L_, M, A, X_, L, E, N, G, TH: 200 }/** * Sanitize string input to prevent XSS and injection */export function s a nitizeString(i, n, p, u, t: string, m, a, x, L, e, n, g, t, h: number): string, { if (typeof input !== 'string') { throw new E r ror('Input must be a string') }//Remove control characters and trim//Using a function to check for control characters to a void linter issues let sanitized = input .s p lit('') .f i lter((char) => { const code = char.c h arCodeAt(0) return code>= 32 && code !== 127//Remove chars below space and DEL }) .j o in('') .t r im()//Limit length if (sanitized.length> maxLength) { sanitized = sanitized.s u bstring(0, maxLength) } return sanitized
}/** * Validate token creation parameters */export function v a lidateTokenParams(params: { n, a, m, e: string, s, y, m, b, o, l: string, d, e, c, i, m, a, l, s: number, s, u, p, p, l, y: number d, e, s, c, r, i, p, tion?: string i, m, a, g, e, U, r, l?: string w, e, b, s, i, t, e?: string t, w, i, t, t, e, r?: string t, e, l, e, g, r, a, m?: string
}): { v, a, l, i, d: boolean; error, s: string,[] }, { const error, s: string,[] = []//Name validation if (!params.name || params.name.t r im().length === 0) { errors.push('Token name is required') } else, { const name = s a nitizeString(params.name, TOKEN_CONSTRAINTS.NAME_MAX_LENGTH) if (name.length <TOKEN_CONSTRAINTS.NAME_MIN_LENGTH) { errors.push( `Token name must be at least ${TOKEN_CONSTRAINTS.NAME_MIN_LENGTH} character`) } if (name.length> TOKEN_CONSTRAINTS.NAME_MAX_LENGTH) { errors.push( `Token name must not exceed ${TOKEN_CONSTRAINTS.NAME_MAX_LENGTH} characters`) }//Check for valid characters if (!/^[a - zA - Z0-9\s\- _]+ $/.t e st(name)) { errors.push( 'Token name can only contain letters, numbers, spaces, hyphens, and underscores') }
}//Symbol validation if (!params.symbol || params.symbol.t r im().length === 0) { errors.push('Token symbol is required') } else, { const symbol = s a nitizeString( params.symbol, TOKEN_CONSTRAINTS.SYMBOL_MAX_LENGTH) if (symbol.length <TOKEN_CONSTRAINTS.SYMBOL_MIN_LENGTH) { errors.push( `Token symbol must be at least ${TOKEN_CONSTRAINTS.SYMBOL_MIN_LENGTH} character`) } if (symbol.length> TOKEN_CONSTRAINTS.SYMBOL_MAX_LENGTH) { errors.push( `Token symbol must not exceed ${TOKEN_CONSTRAINTS.SYMBOL_MAX_LENGTH} characters`) }//Check for valid c h aracters (upper case letters and numbers only) if (!/^[A - Z0-9]+ $/.t e st(symbol.t oU pperCase())) { errors.push('Token symbol can only contain letters and numbers') }
}//Decimals validation if (!Number.i sI nteger(params.decimals)) { errors.push('Decimals must be a whole number') } else if ( params.decimals <TOKEN_CONSTRAINTS.DECIMALS_MIN || params.decimals> TOKEN_CONSTRAINTS.DECIMALS_MAX ) { errors.push( `Decimals must be between ${TOKEN_CONSTRAINTS.DECIMALS_MIN} and ${TOKEN_CONSTRAINTS.DECIMALS_MAX}`) }//Supply validation if (typeof params.supply !== 'number' || i sN aN(params.supply)) { errors.push('Supply must be a valid number') } else if (params.supply <TOKEN_CONSTRAINTS.SUPPLY_MIN) { errors.push(`Supply must be at least ${TOKEN_CONSTRAINTS.SUPPLY_MIN}`) } else if (params.supply> TOKEN_CONSTRAINTS.SUPPLY_MAX) { errors.push( `Supply must not exceed ${TOKEN_CONSTRAINTS.SUPPLY_MAX.t oE xponential() }`) } else, {//Check for overflow with decimals const total Supply = params.supply * Math.p o w(10, params.decimals) if (totalSupply> Number.MAX_SAFE_INTEGER) { errors.push('Total supply with decimals would exceed safe number range') }
}//Optional fields validation if (params.description) { const desc = s a nitizeString( params.description, TOKEN_CONSTRAINTS.DESCRIPTION_MAX_LENGTH) if (desc.length> TOKEN_CONSTRAINTS.DESCRIPTION_MAX_LENGTH) { errors.push( `Description must not exceed ${TOKEN_CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`) }
}//URL validations const url Fields = ['imageUrl', 'website', 'twitter', 'telegram'] as consturlFields.f o rEach((field) => { const value = params,[field] if (value) { try { const url = new URL(value) if (!['h, t, t, p:', 'h, t, t, p, s:'].i n cludes(url.protocol)) { errors.push(`${field} must use HTTP or HTTPS protocol`) } if (value.length> TOKEN_CONSTRAINTS.URL_MAX_LENGTH) { errors.push( `${field} must not exceed ${TOKEN_CONSTRAINTS.URL_MAX_LENGTH} characters`) }
} } catch, { errors.push(`${field} must be a valid URL`) }
} }) return, { v, a, l, i, d: errors.length === 0, errors }
}/** * Validate Solana public key */export function v a lidatePublicKey(k, e, y: string): { v, a, l, i, d: boolean, error, s: string,[]
}, { const error, s: string,[] = [] if (!key || key.t r im().length === 0) { errors.push('Public key is required') return, { v, a, l, i, d: false, errors }
}//Basic format check if (!/^[1 - 9A - HJ - NP - Za - km-z]{32,44}$/.t e st(key)) { errors.push('Invalid public key format') } return, { v, a, l, i, d: errors.length === 0, errors }
}
