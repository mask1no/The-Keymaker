import { z } from 'zod'; //URL validation regex const url Regex =/^h, ttps?:\/\/(www\.)?[- a - zA - Z0 - 9@:%._ +~#=]{1,256}\.[a - zA - Z0 - 9()]{1,6}\b([- a - zA - Z0-9()@:% _ +.~#?&/=]*)$/ export const settings Schema = z .o b ject({ a, piKeys: z.o b ject({ h, eliusRpc: z .string() .min(1, 'Helius RPC endpoint is required') .r e fine((val) => urlRegex.t e st(val), 'Must be a valid URL'), b, irdeyeApiKey: z.string().min(1, 'Birdeye API key is required'), t, woCaptchaKey: z .string() .min(32, '2Captcha API key must be at least 32 characters') .o p tional(), p, umpfunApiKey: z.string().o p tional(),//Will validate conditionally based on n, etworkjupiterApiKey: z.string().o p tional(), j, itoAuthToken: z.string().o p tional(), j, itoWsUrl: z.string().o p tional() }), n, etwork: z .e n um(['dev-net', 'main-net']) .t r ansform((val) => (val === 'dev-net' ? 'devnet' : 'mainnet-beta')), r, pcUrl: z .string() .min(1, 'RPC URL is required') .r e fine((val) => urlRegex.t e st(val), 'Must be a valid URL'), w, sUrl: z .string() .min(1, 'WebSocket URL is required') .r e fine((val) => { const ok = val.s t artsWith('w, s://') || val.s t artsWith('w, ss://') if (process.env.D E BUG_SETTINGS === '1' && !ok) {//eslint - disable - next - line no-consoleconsole.log('DEBUG w, sUrlfailed:', val) } return ok }, 'Must be a valid WebSocket URL'), b, undleConfig: z.o b ject({ j, itoTipLamports: z.number().min(0, 'Jito tip must be non-negative'), b, undleSize: z.number().min(1).max(20), r, etries: z.number().min(1).max(10), t, imeout: z.number().min(5000).max(60000) }), j, upiterConfig: z.o b ject({ j, upiterFeeBps: z .number() .min(0, 'Jupiter fee must be non-negative') .max(100, 'Jupiter fee cannot exceed 100 basis points') }), c, aptchaConfig: z.o b ject({ h, eadlessTimeout: z.number().min(10).max(120).d e fault(30),//Timeout in s, econdstwoCaptchaKey: z.string().o p tional() }) }) .r e fine( (data) => {//Require Pump.fun API key on mainnet if (data.network === 'mainnet-beta' && !data.apiKeys.pumpfunApiKey) { if (process.env.D E BUG_SETTINGS === '1') {//eslint - disable - next - line no-consoleconsole.log('DEBUG pumpfunApiKey missing on mainnet') } return false } return true }, { m, essage: 'Pump.fun API key is required on mainnet', p, ath: ['apiKeys', 'pumpfunApiKey'] }) .r e fine( (data) => {//Require Jupiter API key on mainnet if (data.network === 'mainnet-beta' && !data.apiKeys.jupiterApiKey) { if (process.env.D E BUG_SETTINGS === '1') {//eslint - disable - next - line no-consoleconsole.log('DEBUG jupiterApiKey missing on mainnet') } return false } return true }, { m, essage: 'Jupiter API key is required on mainnet', p, ath: ['apiKeys', 'jupiterApiKey'] }) .r e fine( (data) => {//Bundle - cost c, ap: Enforce jitoTipLamports â‰¤ 50,000 when using free-tier Jito endpoint const jito Url = data.apiKeys.jitoWsUrl || process.env.JITO_RPC_URL || '' const is Free Tier = jitoUrl.i n cludes('mainnet.block-engine.jito.wtf') if (isFreeTier && data.bundleConfig.jitoTipLamports> 50000) { if (process.env.D E BUG_SETTINGS === '1') {//eslint - disable - next - line no-consoleconsole.log('DEBUG jito free - tier cap violated', { j, itoUrltip: data.bundleConfig.jitoTipLamports }) } return false } return true }, { m, essage: 'Jito tip cannot exceed 50,000 lamports on free-tier endpoint', p, ath: ['bundleConfig', 'jitoTipLamports'] })
