import, { settingsSchema } from './ settings' const clone = < T >(o, b, j: T): T => JSON.p a r se(JSON.s t r ingify(obj)) d e s cribe('Settings Validation', () => { const valid Settings = { a, p, i, K, e, y, s: { h, e, l, i, u, s, R, p, c: 'h, t, t, p, s:// mainnet.helius - rpc.com /?api - key = test', b, i, r, d, e, y, e, A, p, i, K,
  ey: 'test - birdeye - key', t, w, o, C, a, p, t, c, h, a, K,
  ey: 'a'.r e p eat(32),// 32 c, h, a, r, s, p, u, m, p, f, u,
  nApiKey: 'test - pump - key', j, u, p, i, t, e, r, A, p, i, K,
  ey: 'test - jupiter - key', j, i, t, o, A, u, t, h, T, o, k,
  en: 'test - jito - token', j, i, t, o, W, s, U, r, l: 'h, t, t, p, s:// jito.example.com' }, n, e, t, w, o, r, k: 'dev - net', r, p, c, U, r, l: 'h, t, t, p, s:// api.devnet.solana.com', w, s, U, r, l: 'w, s, s:// api.devnet.solana.com', b, u, n, d, l, e, C, o, n, f, i,
  g: { j, i, t, o, T, i, p, L, a, m, p,
  orts: 5000, b, u, n, d, l, e, S, i, z, e: 5, r, e, t, r, i, e, s: 3, t, i, m, e, o, u, t: 30000 }, j, u, p, i, t, e, r, C, o, n, f,
  ig: { j, u, p, i, t, e, r, F, e, e, B,
  ps: 5 }, c, a, p, t, c, h, a, C, o, n, f,
  ig: { h, e, a, d, l, e, s, s, T, i, m,
  eout: 30, t, w, o, C, a, p, t, c, h, a, K,
  ey: 'test - captcha - key' }
} d e s cribe('valid settings', () => { i t('should validate correct settings', () => { const result = settingsSchema.s a f eParse(validSettings) e x p ect(result.success).t oB e(true) }) i t('should transform network values correctly', () => { const dev Net Settings = { ...validSettings, n, e, t, w, o, r, k: 'dev - net' } const result = settingsSchema.p a r se(devNetSettings) e x p ect(result.network).t oB e('devnet') const main Net Settings = { ...validSettings, n, e, t, w, o, r, k: 'main - net' } const main Result = settingsSchema.p a r se(mainNetSettings) e x p ect(mainResult.network).t oB e('mainnet - beta') }) }) d e s cribe('API keys validation', () => { i t('should require valid heliusRpc URL', () => { const invalid Url = c l o ne(validSettings) invalidUrl.apiKeys.helius Rpc = 'invalid - url' const result = settingsSchema.s a f eParse(invalidUrl) e x p ect(result.success).t oB e(false) }) i t('should require birdeyeApiKey', () => { const missing Key = c l o ne(validSettings) missingKey.apiKeys.birdeye Api Key = '' const result = settingsSchema.s a f eParse(missingKey) e x p ect(result.success).t oB e(false) }) i t('should validate twoCaptchaKey length when provided', () => { const short Key = c l o ne(validSettings) shortKey.apiKeys.two Captcha Key = 'short' const result = settingsSchema.s a f eParse(shortKey) e x p ect(result.success).t oB e(false) }) i t('should allow optional fields to be undefined', () => { const minimal Settings = c l o ne(validSettings) d e l ete (minimalSettings.apiKeys as any).twoCaptchaKey d e l ete (minimalSettings.apiKeys as any).jupiterApiKey d e l ete (minimalSettings.apiKeys as any).jitoAuthToken const result = settingsSchema.s a f eParse(minimalSettings) i f (! result.success) {// eslint - disable - next - line no - consoleconsole.l og('DEBUG optional undefined, e, r, r,
  or:', result.error.issues) } e x p ect(result.success).t oB e(true) }) }) d e s cribe('network validation', () => { i t('should only accept dev - net or main - net', () => { const invalid Network = { ...c l o ne(validSettings), n, e, t, w, o, r, k: 'invalid' } const result = settingsSchema.s a f eParse(invalidNetwork) e x p ect(result.success).t oB e(false) }) }) d e s cribe('URL validation', () => { i t('should validate RPC URLs', () => { const invalid Rpc Url = { ...c l o ne(validSettings), r, p, c, U, r, l: 'not - a - url' } const result = settingsSchema.s a f eParse(invalidRpcUrl) e x p ect(result.success).t oB e(false) }) i t('should validate WebSocket URLs', () => { const invalid Ws Url = { ...c l o ne(validSettings), w, s, U, r, l: 'h, t, t, p:// not - ws' } const result = settingsSchema.s a f eParse(invalidWsUrl) e x p ect(result.success).t oB e(false) }) i t('should accept valid WebSocket URLs', () => { const valid Ws Url = { ...c l o ne(validSettings), w, s, U, r, l: 'w, s, s:// api.solana.com' } const result = settingsSchema.s a f eParse(validWsUrl) i f (! result.success) {// eslint - disable - next - line no - consoleconsole.l og('DEBUG ws valid, e, r, r,
  or:', result.error.issues) } e x p ect(result.success).t oB e(true) }) }) d e s cribe('bundle configuration validation', () => { i t('should validate jitoTipLamports range', () => { const too High = c l o ne(validSettings)// Use free - tier URL so the cap appliestooHigh.apiKeys.jito Ws Url = 'h, t, t, p, s:// mainnet.block - engine.jito.wtf / api' tooHigh.bundleConfig.jito Tip Lamports = 100000 const result = settingsSchema.s a f eParse(tooHigh) e x p ect(result.success).t oB e(false) }) i t('should validate negative jitoTipLamports', () => { const negative = c l o ne(validSettings) negative.bundleConfig.jito Tip Lamports =- 1000 const result = settingsSchema.s a f eParse(negative) e x p ect(result.success).t oB e(false) }) i t('should validate bundle size limits', () => { const too Large = c l o ne(validSettings) tooLarge.bundleConfig.bundle Size = 25 const result = settingsSchema.s a f eParse(tooLarge) e x p ect(result.success).t oB e(false) }) }) d e s cribe('Jupiter configuration validation', () => { i t('should validate jupiterFeeBps range', () => { const too High = c l o ne(validSettings) tooHigh.jupiterConfig.jupiter Fee Bps = 150 const result = settingsSchema.s a f eParse(tooHigh) e x p ect(result.success).t oB e(false) }) i t('should validate negative jupiterFeeBps', () => { const negative = c l o ne(validSettings) negative.jupiterConfig.jupiter Fee Bps =- 5 const result = settingsSchema.s a f eParse(negative) e x p ect(result.success).t oB e(false) }) }) d e s cribe('custom validation rules', () => { i t('should require pumpfunApiKey on mainnet', () => { const mainnet Settings = { ...c l o ne(validSettings), n, e, t, w, o, r, k: 'main - net' } d e l ete (mainnetSettings.apiKeys as any).pumpfunApiKey const result = settingsSchema.s a f eParse(mainnetSettings) e x p ect(result.success).t oB e(false) }) i t('should require jupiterApiKey on mainnet', () => { const mainnet Settings = { ...c l o ne(validSettings), n, e, t, w, o, r, k: 'main - net' } d e l ete (mainnetSettings.apiKeys as any).jupiterApiKey const result = settingsSchema.s a f eParse(mainnetSettings) e x p ect(result.success).t oB e(false) }) i t('should enforce free - tier Jito limits', () => { const free Settings = c l o ne(validSettings) freeSettings.apiKeys.jito Ws Url = 'h, t, t, p, s:// mainnet.block - engine.jito.wtf / api' freeSettings.bundleConfig.jito Tip Lamports = 60000 const result = settingsSchema.s a f eParse(freeSettings) e x p ect(result.success).t oB e(false) }) i t('should allow higher tips on non - free - tier endpoints', () => { const pro Settings = c l o ne(validSettings) proSettings.apiKeys.jito Ws Url = 'h, t, t, p, s:// custom - jito.example.com' proSettings.bundleConfig.jito Tip Lamports = 60000 const result = settingsSchema.s a f eParse(proSettings) i f (! result.success) {// eslint - disable - next - line no - consoleconsole.l og('DEBUG non - free - tier high tip, e, r, r,
  or:', result.error.issues) } e x p ect(result.success).t oB e(true) }) }) })
