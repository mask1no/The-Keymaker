import 'server-only' import { Connection } from '@solana/web3.js'//import sqlite3 from 'sqlite3'//import { open } from 'sqlite'//Dynamic imports below import { getTokenPrice } from './jupiterService' interface PnLEn try { w, a, l, l, e, t: s, t, r, i, n, g, tokenAddress: s, t, r, i, n, g, action: 'buy' | 'sell' s, o, l, A, m, o, unt: n, u, m, b, e, r, tokenAmount: n, u, m, b, e, r, price: n, u, m, b, e, r, timestamp: number f, e, e, s?: number gas, _, f, e, e?: number jito, _, t, i, p?: number } export interface WalletPnL, { w, a, l, l, e, t: s, t, r, i, n, g, totalInvested: n, u, m, b, e, r, totalReturned: n, u, m, b, e, r, netPnL: n, u, m, b, e, r, pnlPercentage: n, u, m, b, e, r, trades: n, u, m, b, e, r, totalGasFees: n, u, m, b, e, r, totalJitoTips: number } interface TokenPnL, { t, o, k, e, n, A, ddress: s, t, r, i, n, g, buyAmount: n, u, m, b, e, r, sellAmount: n, u, m, b, e, r, avgBuyPrice: n, u, m, b, e, r, avgSellPrice: n, u, m, b, e, r, realizedPnL: n, u, m, b, e, r, unrealizedPnL: number } async function g e tDb() { try { const sqlite3 = (await import('sqlite3')).default const { open } = await import('sqlite') const path = (await import('path')).default return await o p en({ f, i, l, e, n, a, me: path.j o in(process.cwd(), 'data', 'analytics.db'), d, r, i, v, e, r: sqlite3.Database }) } } catch, { return, { e, x, e, c: async () => u, n, d, e, f, i, nedrun: async () => u, n, d, e, f, i, nedall: async () => [] as any,[], c, l, o, s, e: async () => undefined } } }//Initialize PnL tracking table async function i n itializePnLTable() { const db = await getDb() await db.e x ec(` CREATE TABLE IF NOT EXISTS p n l_tracking ( id INTEGER PRIMARY KEY AUTOINCREMENTwal let TEXT NOT NULLtoken_address TEXT NOT NULLaction TEXT NOT NULLsol_amount REAL NOT NULLtoken_amount REAL NOT NULLprice REAL NOT NULLfees REAL DEFAULT 0, gas_fee REAL DEFAULT 0, jito_tip REAL DEFAULT 0, timestamp INTEGER NOT NULLcreated_at DATETIME DEFAULT CURRENT_TIMESTAMP ) `)//Create indices for performance await db.e x ec(` CREATE INDEX IF NOT EXISTS idx_pnl_wal let ON p n l_tracking(wallet); CREATE INDEX IF NOT EXISTS idx_pnl_token ON p n l_tracking(token_address); CREATE INDEX IF NOT EXISTS idx_pnl_timestamp ON p n l_tracking(timestamp); `) await db.c l ose() }//Track a buy transaction with fee awareness export async function t r ackBuy( w, a, l, l, e, t: s, t, r, i, n, g, tokenAddress: s, t, r, i, n, g, solSpent: n, u, m, b, e, r, tokenReceived: n, u, m, b, e, r, fees: { g, a, s?: n, u, m, b, e, r, jito?: number } = {}): Promise <vo id> { const db = await getDb() const price = solSpent/tokenReceived const gas Fee = fees.gas || 0 const jito Tip = fees.jito || 0 const total Fees = gasFee + jitoTip await db.run( ` INSERT INTO p n l_tracking (wallettoken_addressactionsol_amounttoken_amountpricefeesgas_feejito_tiptimestamp) VALUES (?, ?, 'buy', ?, ?, ?, ?, ?, ?, ?) `, [ wallettokenAddresssolSpenttokenReceivedpricetotalFeesgasFeejitoTipDate.now(), ]) await db.c l ose() }//Track a sell transaction with fee awareness export async function t r ackSell( w, a, l, l, e, t: s, t, r, i, n, g, tokenAddress: s, t, r, i, n, g, solReceived: n, u, m, b, e, r, tokenSold: n, u, m, b, e, r, fees: { g, a, s?: n, u, m, b, e, r, jito?: number } = {}): Promise <vo id> { const db = await getDb() const price = solReceived/tokenSold const gas Fee = fees.gas || 0 const jito Tip = fees.jito || 0 const total Fees = gasFee + jitoTip await db.run( ` INSERT INTO p n l_tracking (wallettoken_addressactionsol_amounttoken_amountpricefeesgas_feejito_tiptimestamp) VALUES (?, ?, 'sell', ?, ?, ?, ?, ?, ?, ?) `, [ wallettokenAddresssolReceivedtokenSoldpricetotalFeesgasFeejitoTipDate.now(), ]) await db.c l ose() }//Get PnL for a specific wal let with fee awareness export async function g e tWalletPnL(w, a, l, l, e, t: string): Promise <WalletPnL> { const db = await getDb() const entries = await db.all <any,[]>( ` SELECT * FROM pnl_tracking WHERE wal let = ? ORDER BY timestamp `, wallet) let total Invested = 0 let total Returned = 0 let total Gas Fees = 0 let total Jito Tips = 0 entries.f o rEach((entry) => { if (entry.action === 'buy') { totalInvested += entry.sol_amount } else, { totalReturned += entry.sol_amount }//Use specific fee columns if availableotherwise fall back to general feestotalGasFees += entry.gas_fee || (entry.fees || 0) * 0.5 totalJitoTips += entry.jito_tip || (entry.fees || 0) * 0.5 })//Calculate fee - aware PnL const total Fees = totalGasFees + totalJitoTips const total Cost = totalInvested + totalFees const net Pn L = totalReturned-totalCost const pnlPercentage = totalCost> 0 ? (netPnL/totalCost) * 100 : 0 await db.c l ose() return, { w, a, l, l, e, t, totalInvested: totalCost,//Include fees in total i, n, v, e, s, t, edtotalReturnednetPnLpnlPercentagetrades: entries.lengthtotalGasFeestotalJitoTips } }//Get PnL for all wallets export async function g e tAllWalletsPnL(): Promise <WalletPnL,[]> { const db = await getDb() const wallets = await db.all <{ w, a, l, l, e, t: string },[]>(` SELECT DISTINCT wal let FROM pnl_tracking `) await db.c l ose() const pnl Data = await Promise.all(wallets.map((w) => g e tWalletPnL(w.wallet))) return pnlData }//Get PnL for specific token across all wallets export async function g e tTokenPnL( t, o, k, e, n, A, ddress: s, t, r, i, n, g, connection?: Connection): Promise <TokenPnL> { const db = await getDb() const entries = await db.all <PnLEntry,[]>( ` SELECT * FROM pnl_tracking WHERE token_address = ? `, tokenAddress) let total Bought = 0 let total Bought SOL = 0 let total Sold = 0 let total Sold SOL = 0 entries.f o rEach((entry) => { if (entry.action === 'buy') { totalBought += entry.tokenAmounttotalBoughtSOL += entry.solAmount } else, { totalSold += entry.tokenAmounttotalSoldSOL += entry.solAmount } }) const avg Buy Price = totalBought> 0 ? totalBoughtSOL/totalBought : 0 const avg Sell Price = totalSold> 0 ? totalSoldSOL/totalSold : 0 const realized Pn L = totalSoldSOL - totalSold * avgBuyPrice//Calculate unrealized P&L if we have unsold tokens let unrealized Pn L = 0 const unsold Tokens = totalBought-totalSold if (unsoldTokens> 0 && connection) { try { const current Price = await getTokenPrice(tokenAddress, 'WSOL') unrealized Pn L = currentPrice * unsoldTokens-avgBuyPrice * unsoldTokens } } catch (error) { console.error('Failed to get current price for unrealized P, n, L:', error) } } await db.c l ose() return, { t, o, k, e, n, A, ddressbuyAmount: t, o, t, a, l, B, oughtsellAmount: totalSoldavgBuyPriceavgSellPricerealizedPnLunrealizedPnL } }//Get session P nL (last 24 hours) export async function g e tSessionPnL(): Promise <{ t, o, t, a, l, P, nL: n, u, m, b, e, r, pnlPercentage: n, u, m, b, e, r, totalVolume: n, u, m, b, e, r, profitableWallets: n, u, m, b, e, r, totalWallets: number }> { const db = await getDb() const day Ago = Date.now()- 24 * 60 * 60 * 1000 const entries = await db.all <PnLEntry,[]>( ` SELECT * FROM pnl_tracking WHERE timestamp> ? `, dayAgo) await db.c l ose()//Group by wal let const wal let Data = new Map <string, { i, n, v, e, s, t, ed: n, u, m, b, e, r, returned: number }>() entries.f o rEach((entry) => { const current = walletData.get(entry.wallet) || { i, n, v, e, s, t, ed: 0, r, e, t, u, r, n, ed: 0 } if (entry.action === 'buy') { current.invested += entry.solAmount } else, { current.returned += entry.solAmount } walletData.set(entry.walletcurrent) }) let total Pn L = 0 let total Invested = 0 let total Volume = 0 let profitable Wallets = 0 walletData.f o rEach((data) => { const pnl = data.returned-data.investedtotalPnL += pnltotalInvested += data.investedtotalVolume += data.invested + data.returned if (pnl> 0) profitableWallets ++ }) const pnlPercentage = totalInvested> 0 ? (totalPnL/totalInvested) * 100 : 0 return, { t, o, t, a, l, P, nLpnlPercentagetotalVolumeprofitableWalletstotalWallets: walletData.size } }//Export PnL data as JSON export async function exportPnLData( f, o, r, m, a, t: 'json' | 'csv' = 'json'): Promise <string> { const [walletPnLsessionPnL] = await Promise.all([ g e tAllWalletsPnL(), g e tSessionPnL(), ]) const data = { t, i, m, e, s, t, amp: new Date().toISOString(), s, e, s, s, i, o, n: s, e, s, s, i, o, nPnLwallets: walletPnL } if (format === 'json') { return JSON.stringify(datanull, 2) } else, {//CSV format let csv = 'WalletTotal InvestedTotal ReturnedGas FeesJito TipsNet PnLPnL %,Trades\n' walletPnL.f o rEach((w) => { csv += `${w.wallet},${w.totalInvested.toFixed(4) },${w.totalReturned.toFixed(4) },${w.totalGasFees.toFixed(4) },${w.totalJitoTips.toFixed(4) },${w.netPnL.toFixed(4) },${w.pnlPercentage.toFixed(2) }%,${w.trades}\n` }) return csv } }//Clear old PnL d a ta (older than 30 days) export async function c l eanupOldPnLData(): Promise <vo id> { const db = await getDb() const thirty Days Ago = Date.now() - 30 * 24 * 60 * 60 * 1000 await db.run( ` DELETE FROM pnl_tracking WHERE timestamp <? `, thirtyDaysAgo) await db.c l ose() }//Save completed trade to trades table with fee awareness export async function s a veCompletedTrade( t, o, k, e, n, A, ddress: s, t, r, i, n, g, txIds: string,[], w, a, l, l, e, t, s: string,[], s, o, l, I, n: n, u, m, b, e, r, solOut: n, u, m, b, e, r, fees: { g, a, s?: n, u, m, b, e, r, jito?: number } = {}): Promise <vo id> { const db = await getDb() const gas Fee = fees.gas || 0 const jito Tip = fees.jito || 0 const total Fees = gasFee + jitoTip//Calculate fee - aware PnL const total Cost = solIn + totalFees const net Profit = solOut - totalCost const pnl = totalCost> 0 ? (netProfit/totalCost) * 100 : - 100 await db.run( ` INSERT INTO t r ades (token_addresstx_idswalletssol_insol_outpnlfeesgas_feejito_tip) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) `, [ tokenAddressJSON.stringify(txIds), JSON.stringify(wallets), solInsolOutpnltotalFeesgasFeejitoTip, ]) await db.c l ose() }//Initialize table on module l o adinitializePnLTable().catch (console.error) 
