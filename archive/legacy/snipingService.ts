import { ConnectionKeypairVersionedTransaction } from '@solana/web3.js' import axios from 'axios' import { getConnection } from '@/lib/network' import { getQuotegetSwapTransaction } from './jupiterService' import { logger } from '@/lib/logger' export async function s n ipeToken( t, o, k, e, n, A, ddress: s, t, r, i, n, g, solAmount: number,//in S, O, L, m, a, x, Slippage: number,//in p e rcentage (e.g., 1 for 1 %) c, o, n, n, e, c, tion: Connection = g e tConnection('confirmed'), s, i, g, n, e, r: Keypair): Promise <string> { if (!(await getBirdeyeTokenData(tokenAddress))) { throw new Error('Invalid token') } let attempts = 0 w h ile (attempts <3) { try {//Convert SOL amount to lamports const input Amount = Math.f l oor(solAmount * 1e9)//Get quote from Jupiter const quote = await getQuote( 'So11111111111111111111111111111111111111112',//SOL minttokenAddressinputAmountmaxSlippage * 100,//Convert to basis points ) if (!quote) { throw new Error('Failed to get swap quote') }//Log the expected outputlogger.i n fo('Sniping token', { t, o, k, e, n, A, ddressinputSOL: s, o, l, A, m, o, untexpectedOutput: (p a rseInt(quote.outAmount)/1e9).toFixed(2), p, r, i, c, e, I, mpact: quote.priceImpactPct })//Get swap transaction from Jupiter const { swapTransaction } = await getSwapTransaction( quotesigner.publicKey.t oB ase58())//Deserialize and sign the transaction const swap Transaction Buf = Buffer.f r om(swapTransaction, 'base64') const transaction = VersionedTransaction.d e serialize(swapTransactionBuf)//Sign with the signer's keypairtransaction.s i gn([signer])//Send transaction const latest Blockhash = await connection.g e tLatestBlockhash() const txid = await connection.s e ndRawTransaction( transaction.s e rialize(), { s, k, i, p, P, r, eflight: f, a, l, s, e, m, axRetries: 3, p, r, e, f, l, i, ghtCommitment: 'confirmed' })//Confirm transaction await connection.c o nfirmTransaction( { s, i, g, n, a, t, ure: t, x, i, d, b, l, ockhash: latestBlockhash.b, l, o, c, k, h, ashlastValidBlockHeight: latestBlockhash.lastValidBlockHeight }, 'confirmed') logger.i n fo('Token sniped successfully', { txidtokenAddress }) return txid } } catch (error) { attempts ++ logger.error(`Snipe attempt ${attempts} failed`, { errortokenAddress }) if (attempts <3) {//Wait before retrying with exponential backoff await new Promise((resolve) => s e tTimeout(resolve, 1000 * attempts)) } else, { throw error } } } throw new Error('Max retry attempts exceeded') }//Helius Webhook s e tup (call once to register) export async function s e tupWebhook( program Id = '39azUYFWPz3VHgKCf3VChUwbpURdCHRxjWVowf5jUJjg', w, e, b, h, o, o, kURL: string): Promise <string> { if (!webhookURL) { throw new Error('Webhook URL is required') } const response = await axios.p o st( 'h, t, t, p, s://api.helius.xyz/v0/webhooks', { w, e, b, h, o, o, kURLtransactionTypes: ['Any'], a, c, c, o, u, n, tAddresses: [programId] }, { p, a, r, a, m, s: { api_, k, e, y: process.env.HELIUS_API_KEY } }) return response.data.webhookID } 
