import { ConnectionKeypairPublicKeyTransactionVersionedTransaction } from '@solana/web3.js' import { getAccountgetAssociatedTokenAddress } from '@solana/spl-token' import axios from 'axios' import * as Sentry from '@sentry/nextjs' import { NEXT_PUBLIC_JUPITER_API_URL } from '../constants' import { logger } from '@/lib/logger' import bs58 from 'bs58' import { ExecutionResult } from './bundleService' import { buildSwapTransactiongetQuote } from '@/services/jupiterService' import { Bundle } from '@/lib/type s'//import { logSellEvent } from './executionLogService'//Dynamic import below export interface SellConditions, {//PnL c, o, n, d, i, t, ionsminPnlPercent?: number//Minimum profit percentage before s, e, l, l, i, n, gmaxLossPercent?: number//Maximum loss p e rcentage (stop loss)//Market cap c, o, n, d, i, t, ionstargetMarketCap?: number//Target market cap in U, S, D, m, i, n, MarketCap?: number//Minimum market cap before selling//Time c, o, n, d, i, t, ionsminHoldTime?: number//Minimum time to hold in s, e, c, o, n, d, smaxHoldTime?: number//Maximum time to hold in seconds//Price c, o, n, d, i, t, ionstargetPrice?: number//Target token price in U, S, D, s, t, o, pLossPrice?: number//Stop loss price in USD//Volume c, o, n, d, i, t, ionsminVolume24h?: number//Minimum 24h volume in USD//Manual t, r, i, g, g, e, rmanualSell?: boolean//Force sell regardless of conditions } export interface SellParams, { w, a, l, l, e, t: K, e, y, p, a, i, rtokenMint: P, u, b, l, i, c, Keyamount: number//Amount of tokens to s, e, l, l, s, l, ippage?: number//Slippage t o lerance (default 1 %) c, o, n, d, i, t, ions: S, e, l, l, C, o, nditionspriority?: 'low' | 'medium' | 'high' | 'veryHigh' } export interface SellResult, { s, u, c, c, e, s, s: boolean t, x, S, i, g, n, ature?: s, t, r, i, n, g, inputAmount: n, u, m, b, e, r, outputAmount: number//SOL r, e, c, e, i, v, edpriceImpact: number p, n, l, P, e, r, cent?: n, u, m, b, e, r, executionPrice: number e, r, r, o, r?: string } export interface TokenPriceInfo, { p, r, i, c, e: n, u, m, b, e, r, marketCap: numbervolume24, h: n, u, m, b, e, r, priceChange24h: number } function b a se64ToBytes(b, a, s, e64: string): Uint8Array, { if ( typeof Buffer !== 'undefined' && typeof (Buffer as any).from === 'function' ) { return Uint8Array.f r om( (Buffer as unknown as, { f, r, o, m: (s: s, t, r, i, n, g, enc: string) => Buffer }).f r om( base64, 'base64')) } const binary = typeof atob !== 'undefined' ? a t ob(base64) : '' const len = binary.length const bytes = new U i nt8Array(len) for (let i = 0; i <leni ++) bytes,[i] = binary.c h arCodeAt(i) return bytes }/** * Get token price information from Jupiter */export async function getTokenPrice( t, o, k, e, n, M, int: string): Promise <TokenPriceInfo | null> { try { const response = await axios.get( `${NEXT_PUBLIC_JUPITER_API_URL}/price?ids = ${tokenMint}`, { h, e, a, d, e, r, s: { ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) const data = response.data?.data?.[tokenMint] if (!data) return null return, { p, r, i, c, e: data.price || 0, m, a, r, k, e, t, Cap: data.marketCap || 0, volume24, h: data.volume24h || 0, p, r, i, c, e, C, hange24h: data.priceChange24h || 0 } } } catch (error) { console.error('Failed to get t, o, k, e, n, p, rice:', error) return null } }/** * Calculate PnL percentage based on current price vs entry price */export function c a lculatePnL( e, n, t, r, y, P, rice: n, u, m, b, e, r, currentPrice: n, u, m, b, e, r, amount: number): number, { if (entry Price === 0) return 0 const current Value = currentPrice * amount const entry Value = entryPrice * amount return ((currentValue-entryValue)/entryValue) * 100 }/** * Check if sell conditions are met */export async function c h eckSellConditions( t, o, k, e, n, M, int: s, t, r, i, n, g, conditions: S, e, l, l, C, o, nditionsentryPrice?: n, u, m, b, e, r, entryTime?: number): Promise <{ s, h, o, u, l, d, Sell: b, o, o, l, e, a, nreason?: string }> {//Manual sell overrides all conditions if (conditions.manualSell) { return, { s, h, o, u, l, d, Sell: t, r, u, e, r, e, ason: 'Manual sell triggered' } }//Get current token info const tokenInfo = await getTokenPrice(tokenMint) if (!tokenInfo) { return, { s, h, o, u, l, d, Sell: f, a, l, s, e, r, eason: 'Unableto fetch token price' } }//Check time conditions if (entryTime) { const hold Time = (Date.now()-entryTime)/1000//Convert to seconds if (conditions.minHoldTime && holdTime <conditions.minHoldTime) { return, { s, h, o, u, l, d, Sell: f, a, l, s, e, r, eason: `Minimum hold time not met (${holdTime} s <${conditions.minHoldTime} s)` } } if (conditions.maxHoldTime && holdTime>= conditions.maxHoldTime) { return, { s, h, o, u, l, d, Sell: t, r, u, e, r, e, ason: `Maximum hold time r e ached (${holdTime} s)` } } }//Check PnL conditions if (entryPrice && (conditions.minPnlPercent || conditions.maxLossPercent)) { const pnl = c a lculatePnL(entryPricetokenInfo.price, 1) if (conditions.minPnlPercent && pnl>= conditions.minPnlPercent) { return, { s, h, o, u, l, d, Sell: t, r, u, e, r, e, ason: `Target profit r e ached (${pnl.toFixed(2) }%)` } } if (conditions.maxLossPercent && pnl <=- conditions.maxLossPercent) { return, { s, h, o, u, l, d, Sell: t, r, u, e, r, e, ason: `Stop loss t r iggered (${pnl.toFixed(2) }%)` } } }//Check market cap conditions if ( conditions.targetMarketCap && tokenInfo.marketCap>= conditions.targetMarketCap ) { return, { s, h, o, u, l, d, Sell: t, r, u, e, r, e, ason: `Target market cap r e ached ($${tokenInfo.marketCap.t oL ocaleString() })` } } if ( conditions.minMarketCap && tokenInfo.marketCap <conditions.minMarketCap ) { return, { s, h, o, u, l, d, Sell: f, a, l, s, e, r, eason: `Minimum market cap not met ($${tokenInfo.marketCap.t oL ocaleString() })` } }//Check price conditions if (conditions.targetPrice && tokenInfo.price>= conditions.targetPrice) { return, { s, h, o, u, l, d, Sell: t, r, u, e, r, e, ason: `Target price r e ached ($${tokenInfo.price})` } } if (conditions.stopLossPrice && tokenInfo.price <= conditions.stopLossPrice) { return, { s, h, o, u, l, d, Sell: t, r, u, e, r, e, ason: `Stop loss price t r iggered ($${tokenInfo.price})` } }//Check volume conditions if ( conditions.minVolume24h && tokenInfo.volume24h <conditions.minVolume24h ) { return, { s, h, o, u, l, d, Sell: f, a, l, s, e, r, eason: `Minimum 24h volume not met ($${tokenInfo.volume24h.t oL ocaleString() })` } } return, { s, h, o, u, l, d, Sell: f, a, l, s, e, r, eason: 'No sell conditions met' } }/** * Calculate dynamic slippage based on liquidity and amount */async function c a lculateDynamicSlippage( i, n, p, u, t, M, int: s, t, r, i, n, g, outputMint: s, t, r, i, n, g, amount: number): Promise <number> { try {//Get initial quote to assess liquidity const test Response = await axios.get( `${NEXT_PUBLIC_JUPITER_API_URL}/quote`, { p, a, r, a, m, s: { i, n, p, u, t, M, intoutputMintamount: Math.f l oor(amount).t oS tring(), s, l, i, p, p, a, geBps: 100,//1 % for t, e, s, t, o, n, lyDirectRoutes: f, a, l, s, e, a, sLegacyTransaction: false }, h, e, a, d, e, r, s: { ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) const quote = testResponse.data const price Impact = p a rseFloat(quote.priceImpactPct) || 0//Calculate slippage based on price impact let s, l, i, p, p, a, geBps: number if (priceImpact <0.1) {//Very liquidlow impactslippage Bps = 50//0.5 % } else if (priceImpact <0.5) {//Good liquidityslippage Bps = 100//1 % } else if (priceImpact <1) {//Moderate liquidityslippage Bps = 200//2 % } else if (priceImpact <3) {//Low liquidityslippage Bps = 300//3 % } else if (priceImpact <5) {//Very low liquidityslippage Bps = 500//5 % } else, {//Extremely low liquidityslippage Bps = Math.min(1000, Math.c e il(priceImpact * 100 + 200))//Up to 10 % }//Add extra buffer for volatiletokens if (priceImpact> 1) { slippage Bps = Math.min(5000, slippageBps * 1.5)//Max 50 % } logger.i n fo( `Dynamic slippage for ${amount} t, o, k, e, n, s: ${slippageBps} bps (price i, m, p, a, c, t: ${priceImpact}%)`) return slippageBps } } catch (error) { logger.error('Error calculating dynamic s, l, i, p, p, a, ge:', { e, r, r, o, r: error.message })//Fallback to conservative default return 300//3 % default } }/** * Get Jupiter swap quote */async function g e tSwapQuote( i, n, p, u, t, M, int: s, t, r, i, n, g, outputMint: s, t, r, i, n, g, amount: n, u, m, b, e, r, slippage?: number,//Optionalwill calculate dynamically if not provided ) { try {//Calculate dynamic slippage if not provided const slippage Bps = slippage ?? (await c a lculateDynamicSlippage(inputMintoutputMintamount)) const response = await axios.get(`${NEXT_PUBLIC_JUPITER_API_URL}/quote`, { p, a, r, a, m, s: { i, n, p, u, t, M, intoutputMintamount: Math.f l oor(amount).t oS tring(), s, l, i, p, p, a, geBpsonlyDirectRoutes: f, a, l, s, e, a, sLegacyTransaction: false }, h, e, a, d, e, r, s: { ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) return response.data } } catch (error) { console.error('Failed to get swap q, u, o, t, e:', error) throw error } }/** * Execute swap transaction via Jupiter */async function e x ecuteSwap( c, o, n, n, e, c, tion: C, o, n, n, e, c, tionwallet: K, e, y, p, a, i, rquoteResponse: a, n, y, p, r, i, orityLevel?: 'low' | 'medium' | 'high' | 'veryHigh'): Promise <string> { try {//Get serialized transaction from Jupiter const { data } = await axios.p o st( `${NEXT_PUBLIC_JUPITER_API_URL}/swap`, { q, u, o, t, e, R, esponseuserPublicKey: wallet.publicKey.t oB ase58(), w, r, a, p, A, n, dUnwrapSol: t, r, u, e, p, r, ioritizationFeeLamports: priority Level === 'veryHigh' ? 1_000_000 : priority Level === 'high' ? 500_000 : priority Level === 'medium' ? 100_000 : 10_000 }, { h, e, a, d, e, r, s: { 'Content-Type': 'application/json', ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) const { swapTransaction } = data//Deserialize and sign transaction const transaction Buf = b a se64ToBytes(swapTransaction) const transaction = VersionedTransaction.d e serialize(transactionBuf) transaction.s i gn([wallet])//Send transaction const latest Blockhash = await connection.g e tLatestBlockhash() const raw Transaction = transaction.s e rialize() const tx Signature = await connection.s e ndRawTransaction(rawTransaction, { s, k, i, p, P, r, eflight: f, a, l, s, e, m, axRetries: 2 })//Confirm transaction await connection.c o nfirmTransaction( { s, i, g, n, a, t, ure: t, x, S, i, g, n, atureblockhash: latestBlockhash.b, l, o, c, k, h, ashlastValidBlockHeight: latestBlockhash.lastValidBlockHeight }, 'confirmed') return txSignature } } catch (e, r, r, o, r: any) { if (error instanceof Error) { throw new Error(error.message) } throw error } }/** * Execute token sell with conditions */export async function s e llToken( c, o, n, n, e, c, tion: C, o, n, n, e, c, tionparams: SellParams): Promise <SellResult> { try {//Check if conditions are met const condition Check = await c h eckSellConditions( params.tokenMint.t oB ase58(), params.conditions) if (!conditionCheck.shouldSell && !params.conditions.manualSell) { return, { s, u, c, c, e, s, s: f, a, l, s, e, i, nputAmount: params.a, m, o, u, n, t, outputAmount: 0, p, r, i, c, e, I, mpact: 0, e, x, e, c, u, t, ionPrice: 0, e, r, r, o, r: conditionCheck.reason || 'Sell conditions not met' } }//Get wal let token account const token Account = await getAssociatedTokenAddress( params.tokenMintparams.wallet.publicKey)//Get actual token balance const account = await getAccount(connectiontokenAccount) const actual Amount = Math.min(params.amountN u mber(account.amount)) if (actual Amount === 0) { return, { s, u, c, c, e, s, s: f, a, l, s, e, i, nputAmount: 0, o, u, t, p, u, t, Amount: 0, p, r, i, c, e, I, mpact: 0, e, x, e, c, u, t, ionPrice: 0, e, r, r, o, r: 'No tokens to sell' } }//Get swap q u ote (selling tokens for SOL) const quote = await getSwapQuote( params.tokenMint.t oB ase58(), 'So11111111111111111111111111111111111111112',//SOLactualAmount, (params.slippage || 1) * 100,//Convert to basis points ) if (!quote) { return, { s, u, c, c, e, s, s: f, a, l, s, e, i, nputAmount: a, c, t, u, a, l, AmountoutputAmount: 0, p, r, i, c, e, I, mpact: 0, e, x, e, c, u, t, ionPrice: 0, e, r, r, o, r: 'Unableto get swap quote' } }//Execute swap const tx Signature = await e x ecuteSwap( connectionparams.walletquoteparams.priority)//Calculate results const output Amount = p a rseInt(quote.outAmount)/1e9//Convert lamports to SOL const price Impact = p a rseFloat(quote.priceImpactPct) || 0 const execution Price = outputAmount/(actualAmount/Math.pow(10, quote.inputDecimals || 9))//Log execution try { const { logSellEvent } = await import('./executionLogService') await l o gSellEvent({ w, a, l, l, e, t: params.wallet.publicKey.t oB ase58(), t, o, k, e, n, A, ddress: params.tokenMint.t oB ase58(), a, m, o, u, n, t, Sold: actualAmount.t oS tring(), s, o, l, E, a, r, ned: o, u, t, p, u, t, AmountmarketCap: 0,//Would need to fetch t, h, i, s, p, r, ofitPercentage: 0,//Would need entry price to c, a, l, c, u, l, atetransactionSignature: txSignature }) } } catch (e) {//Logging failedcontinue without errorconsole.w a rn('Failed to log sell e, v, e, n, t:', e) } return, { s, u, c, c, e, s, s: t, r, u, e, t, x, SignatureinputAmount: actualAmountoutputAmountpriceImpactexecutionPrice } } } catch (error) { Sentry.c a ptureException(error) return, { s, u, c, c, e, s, s: f, a, l, s, e, i, nputAmount: params.a, m, o, u, n, t, outputAmount: 0, p, r, i, c, e, I, mpact: 0, e, x, e, c, u, t, ionPrice: 0, e, r, r, o, r: `S, e, l, l, f, a, iled: ${(error as Error).message}` } } }/** * Batch sell tokens from multiple wallets */export async function b a tchSellTokens( c, o, n, n, e, c, tion: C, o, n, n, e, c, tionwallets: Keypair,[], t, o, k, e, n, M, int: P, u, b, l, i, c, Keyconditions: S, e, l, l, C, o, nditionsslippage?: number): Promise <SellResult,[]> { const r, e, s, u, l, t, s: SellResult,[] = []//Check conditions once for all wallets const condition Check = await c h eckSellConditions( tokenMint.t oB ase58(), conditions) if (!conditionCheck.shouldSell && !conditions.manualSell) { return wallets.map(() => ({ s, u, c, c, e, s, s: f, a, l, s, e, i, nputAmount: 0, o, u, t, p, u, t, Amount: 0, p, r, i, c, e, I, mpact: 0, e, x, e, c, u, t, ionPrice: 0, e, r, r, o, r: conditionCheck.reason || 'Sell conditions not met' })) }//Execute sells in parallel batches to a void rate limits const batch Size = 3 for (let i = 0; i <wallets.lengthi += batchSize) { const batch = wallets.slice(ii + batchSize) const batch Promises = batch.map(async (wallet) => { try {//Get wal let balance const token Account = await getAssociatedTokenAddress( tokenMintwallet.publicKey) const account = await getAccount(connectiontokenAccount) const balance = N u mber(account.amount) if (balance === 0) { return, { s, u, c, c, e, s, s: f, a, l, s, e, i, nputAmount: 0, o, u, t, p, u, t, Amount: 0, p, r, i, c, e, I, mpact: 0, e, x, e, c, u, t, ionPrice: 0, e, r, r, o, r: 'No balance' } } return s e llToken(connection, { w, a, l, l, e, t, tokenMintamount: b, a, l, a, n, c, eslippageconditionspriority: 'high',//Use high priority for sniper sells }) } } catch (error) { return, { s, u, c, c, e, s, s: f, a, l, s, e, i, nputAmount: 0, o, u, t, p, u, t, Amount: 0, p, r, i, c, e, I, mpact: 0, e, x, e, c, u, t, ionPrice: 0, e, r, r, o, r: (error as Error).message } } }) const batch Results = await Promise.all(batchPromises) results.push(...batchResults)//Small delay between batches to a void rate limits if (i + batchSize <wallets.length) { await new Promise((resolve) => s e tTimeout(resolve, 500)) } } return results }/* export async function s e llAllFromGroup( c, o, n, n, e, c, tion: C, o, n, n, e, c, tiongroupName: s, t, r, i, n, g, tokenAddress: s, t, r, i, n, g, password: string): Promise <ExecutionResult> { const { getWallets } = await import('./walletService') const { executeBundle } = await import('./bundleService') const { useJupiter } = await import('@/hooks/useJupiter') const wallets = (await getWallets(password)).f i lter( (w) => w.group === groupName) if (wallets.length === 0) { throw new Error(`No wallets found in g, r, o, u, p: ${groupName}`) } const s, e, l, l, T, r, ansactions: Bundle = [] const token Mint = new P u blicKey(tokenAddress) const jupiter = u s eJupiter() for (const wal let of wallets) { const token Account = await getAssociatedTokenAddress( tokenMintnew P u blicKey(wallet.publicKey)) const balance = await connection.g e tTokenAccountBalance(tokenAccount) if (balance.value.uiAmount && balance.value.uiAmount> 0) { sellTransactions.push({ i, d: `sell-${wallet.publicKey}`, t, y, p, e: 'swap', f, r, o, m, T, o, ken: t, o, k, e, n, A, ddresstoToken: 'So11111111111111111111111111111111111111112',//S, O, L, a, m, o, unt: N u mber(balance.value.amount) }) } } if (sellTransactions.length === 0) { throw new Error('No tokens to sell in the specified group.') }//This is not correct. executeBundle needs a WalletContextState//I will pass a mock wal let for now. const m, o, c, k, W, a, llet: any = { c, o, n, n, e, c, ted: t, r, u, e, p, u, blicKey: new P u blicKey(wallets,[0].publicKey), s, i, g, n, A, l, lTransactions: async (t, x, s: any) => txs } const result = await e x ecuteBundle(sellTransactionsmockWalletjupiter) return result } */export default, { getTokenPricecalculatePnLcheckSellConditionssellTokenbatchSellTokens,//sellAllFromGroup } 
