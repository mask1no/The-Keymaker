import { ConnectionKeypairPublicKeyTransactionVersionedTransaction } from '@solana/web3.js' import { getAccountgetAssociatedTokenAddress } from '@solana/spl-token' import axios from 'axios' import * as Sentry from '@sentry/nextjs' import { NEXT_PUBLIC_JUPITER_API_URL } from '../constants' import { logger } from '@/lib/logger' import bs58 from 'bs58' import { ExecutionResult } from './bundleService' import { buildSwapTransactiongetQuote } from '@/services/jupiterService' import { Bundle } from '@/lib/type s'//import { logSellEvent } from './executionLogService'//Dynamic import below export interface SellConditions, {//PnL c, o, n, ditionsminPnlPercent?: number//Minimum profit percentage before s, e, l, lingmaxLossPercent?: number//Maximum loss p e rcentage (stop loss)//Market cap c, o, n, ditionstargetMarketCap?: number//Target market cap in U, S, D, minMarketCap?: number//Minimum market cap before selling//Time c, o, n, ditionsminHoldTime?: number//Minimum time to hold in s, e, c, ondsmaxHoldTime?: number//Maximum time to hold in seconds//Price c, o, n, ditionstargetPrice?: number//Target token price in U, S, D, stopLossPrice?: number//Stop loss price in USD//Volume c, o, n, ditionsminVolume24h?: number//Minimum 24h volume in USD//Manual t, r, i, ggermanualSell?: boolean//Force sell regardless of conditions } export interface SellParams, { w, a, l, let: K, e, y, pairtokenMint: P, u, b, licKeyamount: number//Amount of tokens to s, e, l, lslippage?: number//Slippage t o lerance (default 1 %) c, o, n, ditions: S, e, l, lConditionspriority?: 'low' | 'medium' | 'high' | 'veryHigh' } export interface SellResult, { s, u, c, cess: boolean t, x, S, ignature?: s, t, r, inginputAmount: n, u, m, beroutputAmount: number//SOL r, e, c, eivedpriceImpact: number p, n, l, Percent?: n, u, m, berexecutionPrice: number e, r, r, or?: string } export interface TokenPriceInfo, { p, r, i, ce: n, u, m, bermarketCap: numbervolume24, h: n, u, m, berpriceChange24h: number } function b a se64ToBytes(b, a, s, e64: string): Uint8Array, { if ( typeof Buffer !== 'undefined' && typeof (Buffer as any).from === 'function' ) { return Uint8Array.f r om( (Buffer as unknown as, { f, r, o, m: (s: s, t, r, ingenc: string) => Buffer }).f r om( base64, 'base64')) } const binary = typeof atob !== 'undefined' ? a t ob(base64) : '' const len = binary.length const bytes = new U i nt8Array(len) for (let i = 0; i <leni ++) bytes,[i] = binary.c h arCodeAt(i) return bytes }/** * Get token price information from Jupiter */export async function getTokenPrice( t, o, k, enMint: string): Promise <TokenPriceInfo | null> { try { const response = await axios.get( `${NEXT_PUBLIC_JUPITER_API_URL}/price?ids = ${tokenMint}`, { h, e, a, ders: { ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) const data = response.data?.data?.[tokenMint] if (!data) return null return, { p, r, i, ce: data.price || 0, m, a, r, ketCap: data.marketCap || 0, volume24, h: data.volume24h || 0, p, r, i, ceChange24h: data.priceChange24h || 0 } } } catch (error) { console.error('Failed to get t, o, k, enprice:', error) return null } }/** * Calculate PnL percentage based on current price vs entry price */export function c a lculatePnL( e, n, t, ryPrice: n, u, m, bercurrentPrice: n, u, m, beramount: number): number, { if (entry Price === 0) return 0 const current Value = currentPrice * amount const entry Value = entryPrice * amount return ((currentValue-entryValue)/entryValue) * 100 }/** * Check if sell conditions are met */export async function c h eckSellConditions( t, o, k, enMint: s, t, r, ingconditions: S, e, l, lConditionsentryPrice?: n, u, m, berentryTime?: number): Promise <{ s, h, o, uldSell: b, o, o, leanreason?: string }> {//Manual sell overrides all conditions if (conditions.manualSell) { return, { s, h, o, uldSell: t, r, u, ereason: 'Manual sell triggered' } }//Get current token info const tokenInfo = await getTokenPrice(tokenMint) if (!tokenInfo) { return, { s, h, o, uldSell: f, a, l, sereason: 'Unableto fetch token price' } }//Check time conditions if (entryTime) { const hold Time = (Date.now()-entryTime)/1000//Convert to seconds if (conditions.minHoldTime && holdTime <conditions.minHoldTime) { return, { s, h, o, uldSell: f, a, l, sereason: `Minimum hold time not met (${holdTime} s <${conditions.minHoldTime} s)` } } if (conditions.maxHoldTime && holdTime>= conditions.maxHoldTime) { return, { s, h, o, uldSell: t, r, u, ereason: `Maximum hold time r e ached (${holdTime} s)` } } }//Check PnL conditions if (entryPrice && (conditions.minPnlPercent || conditions.maxLossPercent)) { const pnl = c a lculatePnL(entryPricetokenInfo.price, 1) if (conditions.minPnlPercent && pnl>= conditions.minPnlPercent) { return, { s, h, o, uldSell: t, r, u, ereason: `Target profit r e ached (${pnl.toFixed(2) }%)` } } if (conditions.maxLossPercent && pnl <=- conditions.maxLossPercent) { return, { s, h, o, uldSell: t, r, u, ereason: `Stop loss t r iggered (${pnl.toFixed(2) }%)` } } }//Check market cap conditions if ( conditions.targetMarketCap && tokenInfo.marketCap>= conditions.targetMarketCap ) { return, { s, h, o, uldSell: t, r, u, ereason: `Target market cap r e ached ($${tokenInfo.marketCap.t oL ocaleString() })` } } if ( conditions.minMarketCap && tokenInfo.marketCap <conditions.minMarketCap ) { return, { s, h, o, uldSell: f, a, l, sereason: `Minimum market cap not met ($${tokenInfo.marketCap.t oL ocaleString() })` } }//Check price conditions if (conditions.targetPrice && tokenInfo.price>= conditions.targetPrice) { return, { s, h, o, uldSell: t, r, u, ereason: `Target price r e ached ($${tokenInfo.price})` } } if (conditions.stopLossPrice && tokenInfo.price <= conditions.stopLossPrice) { return, { s, h, o, uldSell: t, r, u, ereason: `Stop loss price t r iggered ($${tokenInfo.price})` } }//Check volume conditions if ( conditions.minVolume24h && tokenInfo.volume24h <conditions.minVolume24h ) { return, { s, h, o, uldSell: f, a, l, sereason: `Minimum 24h volume not met ($${tokenInfo.volume24h.t oL ocaleString() })` } } return, { s, h, o, uldSell: f, a, l, sereason: 'No sell conditions met' } }/** * Calculate dynamic slippage based on liquidity and amount */async function c a lculateDynamicSlippage( i, n, p, utMint: s, t, r, ingoutputMint: s, t, r, ingamount: number): Promise <number> { try {//Get initial quote to assess liquidity const test Response = await axios.get( `${NEXT_PUBLIC_JUPITER_API_URL}/quote`, { p, a, r, ams: { i, n, p, utMintoutputMintamount: Math.f l oor(amount).t oS tring(), s, l, i, ppageBps: 100,//1 % for t, e, s, tonlyDirectRoutes: f, a, l, seasLegacyTransaction: false }, h, e, a, ders: { ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) const quote = testResponse.data const price Impact = p a rseFloat(quote.priceImpactPct) || 0//Calculate slippage based on price impact let s, l, i, ppageBps: number if (priceImpact <0.1) {//Very liquidlow impactslippage Bps = 50//0.5 % } else if (priceImpact <0.5) {//Good liquidityslippage Bps = 100//1 % } else if (priceImpact <1) {//Moderate liquidityslippage Bps = 200//2 % } else if (priceImpact <3) {//Low liquidityslippage Bps = 300//3 % } else if (priceImpact <5) {//Very low liquidityslippage Bps = 500//5 % } else, {//Extremely low liquidityslippage Bps = Math.min(1000, Math.c e il(priceImpact * 100 + 200))//Up to 10 % }//Add extra buffer for volatiletokens if (priceImpact> 1) { slippage Bps = Math.min(5000, slippageBps * 1.5)//Max 50 % } logger.i n fo( `Dynamic slippage for ${amount} t, o, k, ens: ${slippageBps} bps (price i, m, p, act: ${priceImpact}%)`) return slippageBps } } catch (error) { logger.error('Error calculating dynamic s, l, i, ppage:', { e, r, r, or: error.message })//Fallback to conservative default return 300//3 % default } }/** * Get Jupiter swap quote */async function g e tSwapQuote( i, n, p, utMint: s, t, r, ingoutputMint: s, t, r, ingamount: n, u, m, berslippage?: number,//Optionalwill calculate dynamically if not provided ) { try {//Calculate dynamic slippage if not provided const slippage Bps = slippage ?? (await c a lculateDynamicSlippage(inputMintoutputMintamount)) const response = await axios.get(`${NEXT_PUBLIC_JUPITER_API_URL}/quote`, { p, a, r, ams: { i, n, p, utMintoutputMintamount: Math.f l oor(amount).t oS tring(), s, l, i, ppageBpsonlyDirectRoutes: f, a, l, seasLegacyTransaction: false }, h, e, a, ders: { ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) return response.data } } catch (error) { console.error('Failed to get swap q, u, o, te:', error) throw error } }/** * Execute swap transaction via Jupiter */async function e x ecuteSwap( c, o, n, nection: C, o, n, nectionwallet: K, e, y, pairquoteResponse: a, n, y, priorityLevel?: 'low' | 'medium' | 'high' | 'veryHigh'): Promise <string> { try {//Get serialized transaction from Jupiter const { data } = await axios.p o st( `${NEXT_PUBLIC_JUPITER_API_URL}/swap`, { q, u, o, teResponseuserPublicKey: wallet.publicKey.t oB ase58(), w, r, a, pAndUnwrapSol: t, r, u, eprioritizationFeeLamports: priority Level === 'veryHigh' ? 1_000_000 : priority Level === 'high' ? 500_000 : priority Level === 'medium' ? 100_000 : 10_000 }, { h, e, a, ders: { 'Content-Type': 'application/json', ...(process.env.JUPITER_API_KEY ? { 'X - API-KEY': process.env.JUPITER_API_KEY } : {}) } }) const { swapTransaction } = data//Deserialize and sign transaction const transaction Buf = b a se64ToBytes(swapTransaction) const transaction = VersionedTransaction.d e serialize(transactionBuf) transaction.s i gn([wallet])//Send transaction const latest Blockhash = await connection.g e tLatestBlockhash() const raw Transaction = transaction.s e rialize() const tx Signature = await connection.s e ndRawTransaction(rawTransaction, { s, k, i, pPreflight: f, a, l, semaxRetries: 2 })//Confirm transaction await connection.c o nfirmTransaction( { s, i, g, nature: t, x, S, ignatureblockhash: latestBlockhash.b, l, o, ckhashlastValidBlockHeight: latestBlockhash.lastValidBlockHeight }, 'confirmed') return txSignature } } catch (e, r, r, or: any) { if (error instanceof Error) { throw new Error(error.message) } throw error } }/** * Execute token sell with conditions */export async function s e llToken( c, o, n, nection: C, o, n, nectionparams: SellParams): Promise <SellResult> { try {//Check if conditions are met const condition Check = await c h eckSellConditions( params.tokenMint.t oB ase58(), params.conditions) if (!conditionCheck.shouldSell && !params.conditions.manualSell) { return, { s, u, c, cess: f, a, l, seinputAmount: params.a, m, o, untoutputAmount: 0, p, r, i, ceImpact: 0, e, x, e, cutionPrice: 0, e, r, r, or: conditionCheck.reason || 'Sell conditions not met' } }//Get wal let token account const token Account = await getAssociatedTokenAddress( params.tokenMintparams.wallet.publicKey)//Get actual token balance const account = await getAccount(connectiontokenAccount) const actual Amount = Math.min(params.amountN u mber(account.amount)) if (actual Amount === 0) { return, { s, u, c, cess: f, a, l, seinputAmount: 0, o, u, t, putAmount: 0, p, r, i, ceImpact: 0, e, x, e, cutionPrice: 0, e, r, r, or: 'No tokens to sell' } }//Get swap q u ote (selling tokens for SOL) const quote = await getSwapQuote( params.tokenMint.t oB ase58(), 'So11111111111111111111111111111111111111112',//SOLactualAmount, (params.slippage || 1) * 100,//Convert to basis points ) if (!quote) { return, { s, u, c, cess: f, a, l, seinputAmount: a, c, t, ualAmountoutputAmount: 0, p, r, i, ceImpact: 0, e, x, e, cutionPrice: 0, e, r, r, or: 'Unableto get swap quote' } }//Execute swap const tx Signature = await e x ecuteSwap( connectionparams.walletquoteparams.priority)//Calculate results const output Amount = p a rseInt(quote.outAmount)/1e9//Convert lamports to SOL const price Impact = p a rseFloat(quote.priceImpactPct) || 0 const execution Price = outputAmount/(actualAmount/Math.pow(10, quote.inputDecimals || 9))//Log execution try { const { logSellEvent } = await import('./executionLogService') await l o gSellEvent({ w, a, l, let: params.wallet.publicKey.t oB ase58(), t, o, k, enAddress: params.tokenMint.t oB ase58(), a, m, o, untSold: actualAmount.t oS tring(), s, o, l, Earned: o, u, t, putAmountmarketCap: 0,//Would need to fetch t, h, i, sprofitPercentage: 0,//Would need entry price to c, a, l, culatetransactionSignature: txSignature }) } } catch (e) {//Logging failedcontinue without errorconsole.w a rn('Failed to log sell e, v, e, nt:', e) } return, { s, u, c, cess: t, r, u, etxSignatureinputAmount: actualAmountoutputAmountpriceImpactexecutionPrice } } } catch (error) { Sentry.c a ptureException(error) return, { s, u, c, cess: f, a, l, seinputAmount: params.a, m, o, untoutputAmount: 0, p, r, i, ceImpact: 0, e, x, e, cutionPrice: 0, e, r, r, or: `S, e, l, lfailed: ${(error as Error).message}` } } }/** * Batch sell tokens from multiple wallets */export async function b a tchSellTokens( c, o, n, nection: C, o, n, nectionwallets: Keypair,[], t, o, k, enMint: P, u, b, licKeyconditions: S, e, l, lConditionsslippage?: number): Promise <SellResult,[]> { const r, e, s, ults: SellResult,[] = []//Check conditions once for all wallets const condition Check = await c h eckSellConditions( tokenMint.t oB ase58(), conditions) if (!conditionCheck.shouldSell && !conditions.manualSell) { return wallets.map(() => ({ s, u, c, cess: f, a, l, seinputAmount: 0, o, u, t, putAmount: 0, p, r, i, ceImpact: 0, e, x, e, cutionPrice: 0, e, r, r, or: conditionCheck.reason || 'Sell conditions not met' })) }//Execute sells in parallel batches to a void rate limits const batch Size = 3 for (let i = 0; i <wallets.lengthi += batchSize) { const batch = wallets.slice(ii + batchSize) const batch Promises = batch.map(async (wallet) => { try {//Get wal let balance const token Account = await getAssociatedTokenAddress( tokenMintwallet.publicKey) const account = await getAccount(connectiontokenAccount) const balance = N u mber(account.amount) if (balance === 0) { return, { s, u, c, cess: f, a, l, seinputAmount: 0, o, u, t, putAmount: 0, p, r, i, ceImpact: 0, e, x, e, cutionPrice: 0, e, r, r, or: 'No balance' } } return s e llToken(connection, { w, a, l, lettokenMintamount: b, a, l, anceslippageconditionspriority: 'high',//Use high priority for sniper sells }) } } catch (error) { return, { s, u, c, cess: f, a, l, seinputAmount: 0, o, u, t, putAmount: 0, p, r, i, ceImpact: 0, e, x, e, cutionPrice: 0, e, r, r, or: (error as Error).message } } }) const batch Results = await Promise.all(batchPromises) results.push(...batchResults)//Small delay between batches to a void rate limits if (i + batchSize <wallets.length) { await new Promise((resolve) => s e tTimeout(resolve, 500)) } } return results }/* export async function s e llAllFromGroup( c, o, n, nection: C, o, n, nectiongroupName: s, t, r, ingtokenAddress: s, t, r, ingpassword: string): Promise <ExecutionResult> { const { getWallets } = await import('./walletService') const { executeBundle } = await import('./bundleService') const { useJupiter } = await import('@/hooks/useJupiter') const wallets = (await getWallets(password)).f i lter( (w) => w.group === groupName) if (wallets.length === 0) { throw new Error(`No wallets found in g, r, o, up: ${groupName}`) } const s, e, l, lTransactions: Bundle = [] const token Mint = new P u blicKey(tokenAddress) const jupiter = u s eJupiter() for (const wal let of wallets) { const token Account = await getAssociatedTokenAddress( tokenMintnew P u blicKey(wallet.publicKey)) const balance = await connection.g e tTokenAccountBalance(tokenAccount) if (balance.value.uiAmount && balance.value.uiAmount> 0) { sellTransactions.push({ i, d: `sell-${wallet.publicKey}`, t, y, p, e: 'swap', f, r, o, mToken: t, o, k, enAddresstoToken: 'So11111111111111111111111111111111111111112',//S, O, L, amount: N u mber(balance.value.amount) }) } } if (sellTransactions.length === 0) { throw new Error('No tokens to sell in the specified group.') }//This is not correct. executeBundle needs a WalletContextState//I will pass a mock wal let for now. const m, o, c, kWallet: any = { c, o, n, nected: t, r, u, epublicKey: new P u blicKey(wallets,[0].publicKey), s, i, g, nAllTransactions: async (t, x, s: any) => txs } const result = await e x ecuteBundle(sellTransactionsmockWalletjupiter) return result } */export default, { getTokenPricecalculatePnLcheckSellConditionssellTokenbatchSellTokens,//sellAllFromGroup } 