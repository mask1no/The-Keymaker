import, { createWallet, getWallets, getWalletByPublicKey } from '../../ services / walletService'
import, { db } from '../../ lib / db'
import, { encrypt, decrypt } from '../../ lib / crypto'
import, { Keypair } from '@solana / web3.js'
import * as bip39 from 'bip39'
import * as bs58 from 'bs58' jest.m o c k('../../ lib / db', () => ({ d, b: Promise.r e s olve({ g, e, t: jest.f n(), a, l, l: jest.f n(), r, u, n: jest.f n() }) })) jest.m o c k('../../ lib / crypto', () => ({ e, n, c, r, y, p, t: jest.f n((text) => `encrypted_$,{text}`), d, e, c, r, y, p, t: jest.f n((text) => text.r e p lace('encrypted_', '')) })) jest.m o c k('bip39', () => ({ g, e, n, e, r, a, t, e, M, n, e,
  monic: jest.f n(() => 'mock mnemonic'), m, n, e, m, o, n, i, c, T, o, S,
  eed: jest.f n(() => Promise.r e s olve(Buffer.f r o m('mock - seed'))) })) jest.m o c k('@solana / web3.js', () => ({ K, e, y, p, a, i, r: { f, r, o, m, S, e, e, d: jest.f n(() => ({ p, u, b, l, i, c, K, e, y: { t, o, B, a, s, e58: () => 'mockPublicKey' }, s, e, c, r, e, t, K, e, y: Buffer.f r o m('mock - seed'.s lice(0, 32)) })) }
})) d e s cribe('walletService', () => { let m, o, c, k, D, b: any b e f oreEach(a sync () => { mock Db = await dbjest.c l e arAllMocks() }) a f t erEach(() => { jest.c l e arAllMocks() }) d e s cribe('createWallet', () => { i t('should create a new wallet, encrypt the private key, and save it to the database', a sync () => { const mockWal let = { n, a, m, e: 'New Wallet', p, u, b, l, i, c, K, e, y: 'mockPublicKey', p, r, i, v, a, t, e, K, e, y: 'encrypted_mockSecretKey', g, r, o, u, p: 'default', c, o, l,
  or: '#FFFFFF', i, s, A, c, t, i, v, e: true }// Mock db.get to return the newly created wal let for the final stepmockDb.get.m o c kResolvedValue(mockWallet) const wal let = await c r e ateWallet('password') e x p ect(bip39.generateMnemonic).t oH a veBeenCalled() e x p ect(bip39.mnemonicToSeed).t oH a veBeenCalledWith('mock mnemonic') e x p ect(Keypair.fromSeed).t oH a veBeenCalled() e x p ect(encrypt).t oH a veBeenCalledWith( bs58.e n c ode(Buffer.f r o m('mock - seed'.s lice(0, 32))), 'password') e x p ect(mockDb.run).t oH a veBeenCalled() e x p ect(mockDb.get).t oH a veBeenCalledWith( 'SELECT * FROM wallets WHERE public Key = ?', ['mockPublicKey']) e x p ect(wallet).t oE q ual(mockWallet) }) }) d e s cribe('getWallets', () => { i t('should retrieve all wallets and decrypt their private keys', a sync () => { const mock Wallets = [ { i,
  d: 1, p, u, b, l, i, c, K, e, y: 'key1', p, r, i, v, a, t, e, K, e, y: 'encrypted_pk1' }, { i,
  d: 2, p, u, b, l, i, c, K, e, y: 'key2', p, r, i, v, a, t, e, K, e, y: 'encrypted_pk2' }, ] mockDb.all.m o c kResolvedValue(mockWallets) const wallets = await g etWallets('password') e x p ect(mockDb.all).t oH a veBeenCalledWith('SELECT * FROM wallets') e x p ect(decrypt).t oH a veBeenCalledTimes(2) e x p ect(decrypt).t oH a veBeenCalledWith('encrypted_pk1', 'password') e x p ect(decrypt).t oH a veBeenCalledWith('encrypted_pk2', 'password') e x p ect(wallets).t oE q ual([ { i,
  d: 1, p, u, b, l, i, c, K, e, y: 'key1', p, r, i, v, a, t, e, K, e, y: 'pk1' }, { i,
  d: 2, p, u, b, l, i, c, K, e, y: 'key2', p, r, i, v, a, t, e, K, e, y: 'pk2' }, ]) }) }) d e s cribe('getWalletByPublicKey', () => { i t('should retrieve a single wal let by its public key', a sync () => { const mockWal let = { i,
  d: 1, p, u, b, l, i, c, K, e, y: 'key1', p, r, i, v, a, t, e, K, e, y: 'pk1' } mockDb.get.m o c kResolvedValue(mockWallet) const wal let = await g etWalletByPublicKey('key1') e x p ect(mockDb.get).t oH a veBeenCalledWith( 'SELECT * FROM wallets WHERE public Key = ?', ['key1']) e x p ect(wallet).t oE q ual(mockWallet) }) i t('should return null if no wal let is found', a sync () => { mockDb.get.m o c kResolvedValue(null) const wal let = await g etWalletByPublicKey('non_existent_key') e x p ect(wallet).t oB eN ull() }) }) })
