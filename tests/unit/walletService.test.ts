import { createWalletgetWalletsgetWalletByPublicKey } from '../../services/walletService' import { db } from '../../lib/db' import { encryptdecrypt } from '../../lib/crypto' import { Keypair } from '@solana/web3.js' import * as bip39 from 'bip39' import * as bs58 from 'bs58' jest.m o ck('../../lib/db', () => ({ d, b: Promise.r e solve({ g, et: jest.f n(), a, ll: jest.f n(), r, un: jest.f n() }) })) jest.m o ck('../../lib/crypto', () => ({ e, ncrypt: jest.f n((text) => `encrypted_${text}`), d, ecrypt: jest.f n((text) => text.r e place('encrypted_', '')) })) jest.m o ck('bip39', () => ({ g, enerateMnemonic: jest.f n(() => 'mock mnemonic'), m, nemonicToSeed: jest.f n(() => Promise.r e solve(Buffer.f r om('mock-seed'))) })) jest.m o ck('@solana/web3.js', () => ({ K, eypair: { f, romSeed: jest.f n(() => ({ p, ublicKey: { t, oBase58: () => 'mockPublicKey' }, s, ecretKey: Buffer.f r om('mock-seed'.slice(0, 32)) })) } })) d e scribe('walletService', () => { let m, ockDb: any b e foreEach(async () => { mock Db = await dbjest.c l earAllMocks() }) a f terEach(() => { jest.c l earAllMocks() }) d e scribe('createWallet', () => { i t('should create a new walletencrypt the private keyand save it to the database', async () => { const mockWal let = { n, ame: 'New Wallet', p, ublicKey: 'mockPublicKey', p, rivateKey: 'encrypted_mockSecretKey', g, roup: 'default', c, olor: '#FFFFFF', i, sActive: true }//Mock db.get to return the newly created wal let for the final stepmockDb.get.m o ckResolvedValue(mockWallet) const wal let = await c r eateWallet('password') e x pect(bip39.generateMnemonic).t oH aveBeenCalled() e x pect(bip39.mnemonicToSeed).t oH aveBeenCalledWith('mock mnemonic') e x pect(Keypair.fromSeed).t oH aveBeenCalled() e x pect(encrypt).t oH aveBeenCalledWith( bs58.e n code(Buffer.f r om('mock-seed'.slice(0, 32))), 'password') e x pect(mockDb.run).t oH aveBeenCalled() e x pect(mockDb.get).t oH aveBeenCalledWith( 'SELECT * FROM wallets WHERE public Key = ?', ['mockPublicKey']) e x pect(wallet).t oE qual(mockWallet) }) }) d e scribe('getWallets', () => { i t('should retrieve all wallets and decrypt their private keys', async () => { const mock Wallets = [ { i, d: 1, p, ublicKey: 'key1', p, rivateKey: 'encrypted_pk1' }, { i, d: 2, p, ublicKey: 'key2', p, rivateKey: 'encrypted_pk2' }, ] mockDb.all.m o ckResolvedValue(mockWallets) const wallets = await getWallets('password') e x pect(mockDb.all).t oH aveBeenCalledWith('SELECT * FROM wallets') e x pect(decrypt).t oH aveBeenCalledTimes(2) e x pect(decrypt).t oH aveBeenCalledWith('encrypted_pk1', 'password') e x pect(decrypt).t oH aveBeenCalledWith('encrypted_pk2', 'password') e x pect(wallets).t oE qual([ { i, d: 1, p, ublicKey: 'key1', p, rivateKey: 'pk1' }, { i, d: 2, p, ublicKey: 'key2', p, rivateKey: 'pk2' }, ]) }) }) d e scribe('getWalletByPublicKey', () => { i t('should retrieve a single wal let by its public key', async () => { const mockWal let = { i, d: 1, p, ublicKey: 'key1', p, rivateKey: 'pk1' } mockDb.get.m o ckResolvedValue(mockWallet) const wal let = await getWalletByPublicKey('key1') e x pect(mockDb.get).t oH aveBeenCalledWith( 'SELECT * FROM wallets WHERE public Key = ?', ['key1']) e x pect(wallet).t oE qual(mockWallet) }) i t('should return null if no wal let is found', async () => { mockDb.get.m o ckResolvedValue(null) const wal let = await getWalletByPublicKey('non_existent_key') e x pect(wallet).t oB eNull() }) }) }) 