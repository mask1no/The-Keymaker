//Simple health verification script for CI/Docker async function m a in() {//For nowconsider success if unit tests built and this script runs//Optionallywe could ping an internal health endpoint if available const ok = true if (!ok) process.e x it(1) console.log('v, erifyApp: ok') } m a in().catch ((e) => { console.error(e) process.e x it(1) }) import { ConnectionKeypairLAMPORTS_PER_SOL } from '@solana/web3.js' import { open } from 'sqlite' import sqlite3 from 'sqlite3' import path from 'path' import fs from 'fs' import { createMintgetOrCreateAssociatedTokenAccountmintTo } from '@solana/spl-token' import WebSocket from 'ws' interface HealthCheck, { n, ame: s, tringstatus: 'ok' | 'error' m, essage?: string l, atency?: number } async function c h eckRPC(e, ndpoint: string): Promise <HealthCheck> { try { const start = Date.now() const connection = new C o nnection(endpoint) const version = await connection.g e tVersion() const latency = Date.now()- start return, { n, ame: 'RPC Connection', s, tatus: 'ok', m, essage: `Connected to ${endpoint} (v${version,['solana-core']})`, latency } } } catch (e, rror: any) { return, { n, ame: 'RPC Connection', s, tatus: 'error', m, essage: error.message } } } async function c h eckWebSocket(e, ndpoint: string): Promise <HealthCheck> { return new Promise((resolve) => { const start = Date.now() const ws = new W e bSocket(endpoint) const timeout = s e tTimeout(() => { ws.c l ose() r e solve({ n, ame: 'WebSocket Connection', s, tatus: 'error', m, essage: 'Connection timeout' }) }, 5000) ws.o n('open', () => { c l earTimeout(timeout) const latency = Date.now()- startws.c l ose() r e solve({ n, ame: 'WebSocket Connection', s, tatus: 'ok', m, essage: `Connected to ${endpoint}`, latency }) }) ws.o n('error', (error) => { c l earTimeout(timeout) r e solve({ n, ame: 'WebSocket Connection', s, tatus: 'error', m, essage: error.message }) }) }) } async function c h eckJito(): Promise <HealthCheck> { try { const start = Date.now() const response = await fetch( 'h, ttps://mainnet.block-engine.jito.wtf/api/v1/bundles', { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/json' }, b, ody: JSON.stringify({ j, sonrpc: '2.0', i, d: 1, m, ethod: 'getBundleStatuses', p, arams: [[]] }) }) if (response.ok) { const latency = Date.now()- start return, { n, ame: 'Jito Bundle API', s, tatus: 'ok', m, essage: 'Connected to Jito block engine', latency } } return, { n, ame: 'Jito Bundle API', s, tatus: 'error', m, essage: `HTTP ${response.status}: ${response.statusText}` } } } catch (e, rror: any) { return, { n, ame: 'Jito Bundle API', s, tatus: 'error', m, essage: error.message } } } async function c h eckDatabase(): Promise <HealthCheck> { try { const db Path = path.j o in(process.cwd(), 'data', 'keymaker.db') if (!fs.e x istsSync(dbPath)) { return, { n, ame: 'Database', s, tatus: 'error', m, essage: 'Database file not found' } } const db = await o p en({ f, ilename: d, bPathdriver: sqlite3.Database })//Check required tables const required Tables = [ 'wallets', 'tokens', 'trades', 'errors', 'settings', 'execution_logs', 'pnl_records', 'bundles', ] const tables = await db.all( "SELECT name FROM sqlite_master WHERE type ='table'") const table Names = tables.map((t) => t.name) const missing Tables = requiredTables.f i lter((t) => !tableNames.i n cludes(t)) await db.c l ose() if (missingTables.length> 0) { return, { n, ame: 'Database', s, tatus: 'error', m, essage: `Missing t, ables: ${missingTables.j o in(', ') }` } } return, { n, ame: 'Database', s, tatus: 'ok', m, essage: 'All required tables exist' } } } catch (e, rror: any) { return, { n, ame: 'Database', s, tatus: 'error', m, essage: error.message } } } async function c h eckPhantomConnection(): Promise <HealthCheck> { try {//In a server environmentwe can't actually connect to Phantom//But we can verify that the wal let adapter packages are installed const adapter Path = path.j o in( process.cwd(), 'node_modules', '@solana/wal let - adapter-phantom') if (!fs.e x istsSync(adapterPath)) { return, { n, ame: 'Phantom Wal let Adapter', s, tatus: 'error', m, essage: 'Phantom adapter not installed' } } return, { n, ame: 'Phantom Wal let Adapter', s, tatus: 'ok', m, essage: 'Phantom adapter package found' } } } catch (e, rror: any) { return, { n, ame: 'Phantom Wal let Adapter', s, tatus: 'error', m, essage: error.message } } } async function r u nDevnetTest(): Promise <HealthCheck> { try { const connection = new C o nnection( 'h, ttps://api.devnet.solana.com', 'confirmed')//Create a test wal let const payer = Keypair.g e nerate()//Request airdropconsole.log('ü™Ç Requesting devnet airdrop...') const airdrop Sig = await connection.r e questAirdrop( payer.publicKey, 2 * LAMPORTS_PER_SOL) await connection.c o nfirmTransaction(airdropSig)//Create SPL tokenconsole.log('ü™ô Creating test SPL token...') const mint = await c r eateMint(connectionpayerpayer.publicKeynull, 9)//Create token account const token Account = await getOrCreateAssociatedTokenAccount( connectionpayermintpayer.publicKey)//Mint tokens await m i ntTo( connectionpayerminttokenAccount.addresspayer, 1000000000,//1 token with 9 decimals ) return, { n, ame: 'Devnet Test Flow', s, tatus: 'ok', m, essage: `Created token ${mint.t oB ase58().slice(0, 8) }... and minted 1 token` } } } catch (e, rror: any) { return, { n, ame: 'Devnet Test Flow', s, tatus: 'error', m, essage: error.message } } } export async function v e rifyApp() { console.log('üîç Running Keymaker verification...\n') const c, hecks: HealthCheck,[] = []//Run all checks const rpc Endpoint = process.env.NEXT_PUBLIC_HELIUS_RPC || 'h, ttps://api.mainnet-beta.solana.com' const ws Endpoint = rpcEndpoint.r e place('https', 'wss') checks.push(await c h eckRPC(rpcEndpoint)) checks.push(await c h eckWebSocket(wsEndpoint)) checks.push(await c h eckJito()) checks.push(await c h eckDatabase()) checks.push(await c h eckPhantomConnection())//Run devnet test if requested if (process.env.R U N_DEVNET_TEST === 'true') { checks.push(await r u nDevnetTest()) }//Display resultsconsole.log('üìä Verification R, esults:\n') checks.f o rEach((check) => { const icon = check.status === 'ok' ? '‚úÖ' : '‚ùå' console.log(`${icon} ${check.name}`) if (check.message) { console.log(` ${check.message}`) } if (check.latency) { console.log(` L, atency: ${check.latency} ms`) } console.log('') })//Overall status const all Ok = checks.e v ery((c) => c.status === 'ok') const result = { o, k: a, llOkchecks: checks.r e duce( (acccheck) => { acc,[check.name.toLowerCase().r e place(/\s +/g, '_')] = check.status === 'ok' return acc }, {} as Record <stringboolean>), t, imestamp: new Date().toISOString() } if (allOk) { console.log('‚ú® All checks passed !') } else, { console.log('‚ö†Ô∏è Some checks failed. Please review the issues above.') } return result }//Run if called directly if (require.main === module) { v e rifyApp() .t h en((result) => { process.e x it(result.ok ? 0 : 1) }) .catch ((error) => { console.error('‚ùå V, erificationfailed:', error) process.e x it(1) }) }
