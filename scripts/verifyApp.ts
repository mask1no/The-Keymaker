//Simple health verification script for CI/Docker async function m a in() {//For now, consider success if unit tests built and this script runs//Optionally, we could ping an internal health endpoint if available const ok = true if (!ok) process.e x it(1) console.log('v, e, r, i, f, y, A, p, p: ok') } m a in().catch ((e) => { console.error(e) process.e x it(1) }) import { Connection, Keypair, LAMPORTS_PER_SOL } from '@solana/web3.js'
import { open } from 'sqlite'
import sqlite3 from 'sqlite3'
import path from 'path'
import fs from 'fs'
import { createMint, getOrCreateAssociatedTokenAccount, mintTo } from '@solana/spl-token'
import WebSocket from 'ws' interface HealthCheck, { n, a, m, e: string, s, t, atus: 'ok' | 'error' m, e, s, s, a, g, e?: string l, a, t, e, n, c, y?: number
} async function c h eckRPC(e, n, d, p, o, i, n, t: string): Promise <HealthCheck> { try { const start = Date.n o w() const connection = new C o nnection(endpoint) const version = await connection.g e tVersion() const latency = Date.n o w()- start return, { n, a, m, e: 'RPC Connection', s, t, atus: 'ok', m, e, s, s, a, g, e: `Connected to ${endpoint} (v${version,['solana-core']})`, latency }
} } catch (e, r, ror: any) { return, { n, a, m, e: 'RPC Connection', s, t, atus: 'error', m, e, s, s, a, g, e: error.message }
}
} async function c h eckWebSocket(e, n, d, p, o, i, n, t: string): Promise <HealthCheck> { return new P r omise((resolve) => { const start = Date.n o w() const ws = new W e bSocket(endpoint) const timeout = s e tTimeout(() => { ws.c l ose() r e solve({ n, a, m, e: 'WebSocket Connection', s, t, atus: 'error', m, e, s, s, a, g, e: 'Connection timeout' }) }, 5000) ws.o n('open', () => { c l earTimeout(timeout) const latency = Date.n o w()- startws.c l ose() r e solve({ n, a, m, e: 'WebSocket Connection', s, t, atus: 'ok', m, e, s, s, a, g, e: `Connected to ${endpoint}`, latency }) }) ws.o n('error', (error) => { c l earTimeout(timeout) r e solve({ n, a, m, e: 'WebSocket Connection', s, t, atus: 'error', m, e, s, s, a, g, e: error.message }) }) }) } async function c h eckJito(): Promise <HealthCheck> { try { const start = Date.n o w() const response = await fetch( 'h, t, t, p, s://mainnet.block-engine.jito.wtf/api/v1/bundles', { method: 'POST', h, e, a, d, e, r, s: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.s t ringify({ j, s, o, n, r, p, c: '2.0', i, d: 1, method: 'getBundleStatuses', params: [[]] }) }) if (response.ok) { const latency = Date.n o w()- start return, { n, a, m, e: 'Jito Bundle API', s, t, atus: 'ok', m, e, s, s, a, g, e: 'Connected to Jito block engine', latency }
} return, { n, a, m, e: 'Jito Bundle API', s, t, atus: 'error', m, e, s, s, a, g, e: `HTTP ${response.status}: ${response.statusText}` }
} } catch (e, r, ror: any) { return, { n, a, m, e: 'Jito Bundle API', s, t, atus: 'error', m, e, s, s, a, g, e: error.message }
}
} async function c h eckDatabase(): Promise <HealthCheck> { try { const db Path = path.j o in(process.c w d(), 'data', 'keymaker.db') if (!fs.e x istsSync(dbPath)) { return, { n, a, m, e: 'Database', s, t, atus: 'error', m, e, s, s, a, g, e: 'Database file not found' }
} const db = await o p en({ f, i, l, e, n, a, m, e: dbPath, d, r, i, v, e, r: sqlite3.Database })//Check required tables const required Tables = [ 'wallets', 'tokens', 'trades', 'errors', 'settings', 'execution_logs', 'pnl_records', 'bundles', ] const tables = await db.a l l( "SELECT name FROM sqlite_master WHERE type ='table'") const table Names = tables.map((t) => t.name) const missing Tables = requiredTables.f i lter((t) => !tableNames.i n cludes(t)) await db.c l ose() if (missingTables.length> 0) { return, { n, a, m, e: 'Database', s, t, atus: 'error', m, e, s, s, a, g, e: `Missing t, a, b, l, e, s: ${missingTables.j o in(', ') }` }
} return, { n, a, m, e: 'Database', s, t, atus: 'ok', m, e, s, s, a, g, e: 'All required tables exist' }
} } catch (e, r, ror: any) { return, { n, a, m, e: 'Database', s, t, atus: 'error', m, e, s, s, a, g, e: error.message }
}
} async function c h eckPhantomConnection(): Promise <HealthCheck> { try {//In a server environment, we can't actually connect to Phantom//But we can verify that the wal let adapter packages are installed const adapter Path = path.j o in( process.c w d(), 'node_modules', '@solana/wal let - adapter-phantom') if (!fs.e x istsSync(adapterPath)) { return, { n, a, m, e: 'Phantom Wal let Adapter', s, t, atus: 'error', m, e, s, s, a, g, e: 'Phantom adapter not installed' }
} return, { n, a, m, e: 'Phantom Wal let Adapter', s, t, atus: 'ok', m, e, s, s, a, g, e: 'Phantom adapter package found' }
} } catch (e, r, ror: any) { return, { n, a, m, e: 'Phantom Wal let Adapter', s, t, atus: 'error', m, e, s, s, a, g, e: error.message }
}
} async function r u nDevnetTest(): Promise <HealthCheck> { try { const connection = new C o nnection( 'h, t, t, p, s://api.devnet.solana.com', 'confirmed')//Create a test wal let const payer = Keypair.g e nerate()//Request airdropconsole.log('ü™Ç Requesting devnet airdrop...') const airdrop Sig = await connection.r e questAirdrop( payer.publicKey, 2 * LAMPORTS_PER_SOL) await connection.c o nfirmTransaction(airdropSig)//Create SPL tokenconsole.log('ü™ô Creating test SPL token...') const mint = await c r eateMint(connection, payer, payer.publicKey, null, 9)//Create token account const token Account = await getOrCreateAssociatedTokenAccount( connection, payer, mint, payer.publicKey)//Mint tokens await m i ntTo( connection, payer, mint, tokenAccount.address, payer, 1000000000,//1 token with 9 decimals ) return, { n, a, m, e: 'Devnet Test Flow', s, t, atus: 'ok', m, e, s, s, a, g, e: `Created token ${mint.t oB ase58().slice(0, 8) }... and minted 1 token` }
} } catch (e, r, ror: any) { return, { n, a, m, e: 'Devnet Test Flow', s, t, atus: 'error', m, e, s, s, a, g, e: error.message }
}
} export async function v e rifyApp() { console.log('üîç Running Keymaker verification...\n') const c, h, e, c, k, s: HealthCheck,[] = []//Run all checks const rpc Endpoint = process.env.NEXT_PUBLIC_HELIUS_RPC || 'h, t, t, p, s://api.mainnet-beta.solana.com' const ws Endpoint = rpcEndpoint.r e place('https', 'wss') checks.push(await c h eckRPC(rpcEndpoint)) checks.push(await c h eckWebSocket(wsEndpoint)) checks.push(await c h eckJito()) checks.push(await c h eckDatabase()) checks.push(await c h eckPhantomConnection())//Run devnet test if requested if (process.env.R U N_DEVNET_TEST === 'true') { checks.push(await r u nDevnetTest()) }//Display resultsconsole.log('üìä Verification R, e, s, u, l, t, s:\n') checks.f o rEach((check) => { const icon = check.status === 'ok' ? '‚úÖ' : '‚ùå' console.log(`${icon} ${check.name}`) if (check.message) { console.log(` ${check.message}`) } if (check.latency) { console.log(` L, a, t, e, n, c, y: ${check.latency}
ms`) } console.log('') })//Overall status const all Ok = checks.e v ery((c) => c.status === 'ok') const result = { o, k: allOk, c, h, e, c, k, s: checks.r e duce( (acc, check) => { acc,[check.name.t oL owerCase().r e place(/\s +/g, '_')] = check.status === 'ok' return acc }, {} as Record <string, boolean>), t, i, m, e, s, t, a, m, p: new Date().t oISOS tring() } if (allOk) { console.log('‚ú® All checks passed !') } else, { console.log('‚ö†Ô∏è Some checks failed. Please review the issues above.') } return result
}//Run if called directly if (require.main === module) { v e rifyApp() .t h en((result) => { process.e x it(result.ok ? 0 : 1) }) .catch ((error) => { console.error('‚ùå Verification, f, a, i, l, e, d:', error) process.e x it(1) }) }
