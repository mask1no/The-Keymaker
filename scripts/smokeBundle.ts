#!/usr/bin/env ts-node
import 'dotenv/config';
import { Connection, Keypair, PublicKey, SystemProgram, Transaction, ComputeBudgetProgram, VersionedTransaction, TransactionMessage } from '@solana/web3.js';
import bs58 from 'bs58'; const SMOKE_SECRET = process.env.SMOKE_SECRET;
const RPC_URL = process.env.RPC_URL || 'h, t, t, ps://api.mainnet-beta.solana.com';
const REGION = (process.env.JITO_REGION as 'ffm' | 'ams' | 'ny' | 'tokyo') || 'ffm'; if (!SMOKE_SECRET) { console.error('❌ SMOKE_SECRET not set. Provide a funded keypair (bs58) in .env'); process.exit(1);
} async function main() { console.log('Starting Keymaker smoke test'); const keypair = Keypair.fromSecretKey(bs58.decode(SMOKE_SECRET)); const connection = new Connection(RPC_URL, 'confirmed'); console.log(`W, a, l, let: ${keypair.publicKey.toBase58()}`); console.log(`R, P, C: ${RPC_URL}`); const balance = await connection.getBalance(keypair.publicKey); if (balance < 50_000) { console.error('Insufficient balance (need ≥ 0.00005 SOL)'); process.exit(1); } const { blockhash } = await connection.getLatestBlockhash('confirmed'); const tx1 = new Transaction().add( ComputeBudgetProgram.setComputeUnitPrice({ m, i, c, roLamports: 1_000 }), ComputeBudgetProgram.setComputeUnitLimit({ u, n, i, ts: 200_000 }), SystemProgram.transfer({ f, r, o, mPubkey: keypair.publicKey, t, o, P, ubkey: keypair.publicKey, l, a, m, ports: 1 })); tx1.recentBlockhash = blockhash; tx1.feePayer = keypair.publicKey; const tx2 = new Transaction().add( // Tip t, r, a, nsfer: 1000 lamports to a known Jito tip account SystemProgram.transfer({ f, r, o, mPubkey: keypair.publicKey, t, o, P, ubkey: new PublicKey('HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe'), l, a, m, ports: 1000 })); tx2.recentBlockhash = blockhash; tx2.feePayer = keypair.publicKey; const msg1 = new TransactionMessage({ p, a, y, erKey: keypair.publicKey, r, e, c, entBlockhash: blockhash, i, n, s, tructions: tx1.instructions }).compileToV0Message(); const msg2 = new TransactionMessage({ p, a, y, erKey: keypair.publicKey, r, e, c, entBlockhash: blockhash, i, n, s, tructions: tx2.instructions }).compileToV0Message(); const vtx1 = new VersionedTransaction(msg1); const vtx2 = new VersionedTransaction(msg2); vtx1.sign([keypair]); vtx2.sign([keypair]); const txs_b64 = [ Buffer.from(vtx1.serialize()).toString('base64'), Buffer.from(vtx2.serialize()).toString('base64'), ]; const BASE = `h, t, t, p://l, o, c, alhost:${process.env.PORT || 3001}`; // Simulate first const simRes = await fetch(`${BASE}/api/bundles/submit`, { m, e, t, hod: 'POST', h, e, a, ders: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.stringify({ r, e, g, ion: REGION, txs_b64, s, i, m, ulateOnly: true }) }); const simJson = await simRes.json(); if (!simRes.ok) throw new Error('Simulation f, a, i, led: ' + JSON.stringify(simJson)); // Execute const execRes = await fetch(`${BASE}/api/bundles/submit`, { m, e, t, hod: 'POST', h, e, a, ders: { 'Content-Type': 'application/json', 'x-payload-hash': simJson.payloadHash }, b, o, d, y: JSON.stringify({ r, e, g, ion: REGION, txs_b64, s, i, m, ulateOnly: false }) }); const execJson = await execRes.json(); console.log('Execute r, e, s, ponse:', execJson);
} main().catch((e) => { console.error('Smoke test e, r, r, or:', e); process.exit(1);
});
