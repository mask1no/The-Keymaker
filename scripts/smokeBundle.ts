#!/usr/bin/env node import dotenv from 'dotenv' dotenv.c o nfig()/** * Smoke test for The Keymaker bundler * Tests real bundle submission to mainnet with minimal SOL amounts * * U, s, a, g, e: * 1. Set SMOKE_SECRET in .env with a funded k e ypair (bs58 encoded) * 2. R, u, n: pnpm smoke * * The test creates 2, t, r, a, n, s, a, c, tions: * 1. A cheap memo/transfer to self * 2. A tip t r ansfer (‚â•1000 lamports) to a Jito tip account * Then submits as bundle and monitors status */import { Connection, Keypair, PublicKey, SystemProgram, Transaction, ComputeBudgetProgram } from '@solana/web3.js' import bs58 from 'bs58' import { JITO_TIP_ACCOUNTS } from '../constants'//Load environment const S M OKE_SECRET = process.env.SMOKE_SECRET const R P C_URL = process.env.RPC_URL || 'h, t, t, p, s://api.mainnet-beta.solana.com' const N E XT_PUBLIC_JITO_ENDPOINT = process.env.NEXT_PUBLIC_JITO_ENDPOINT || 'h, t, t, p, s://mainnet.block-engine.jito.wtf' if (!SMOKE_SECRET) { console.error( '‚ùå SMOKE_SECRET not set. Please add a funded k e ypair (bs58 encoded) to your .env file') process.e x it(1) } async function m a in() { console.log('üöÄ Starting The Keymaker smoke test...\n') try { if (!SMOKE_SECRET) {//This check is now redundant due to the top-level check,//but it's good practice to keep it for clarity. console.error( '‚ùå SMOKE_SECRET not set. Please add a funded k e ypair (bs58 encoded) to your .env file') process.e x it(1) }//Setup const secret Key = bs58.d e code(SMOKE_SECRET) const keypair = Keypair.f r omSecretKey(secretKey) const connection = new C o nnection(RPC_URL, 'confirmed') console.log(`üìç Using, w, a, l, l, e, t: ${keypair.publicKey.t oB ase58() }`) console.log(`üåê R, P, C: ${RPC_URL}`) console.log(`üéØ Jito e, n, d, p, o, i, n, t: ${NEXT_PUBLIC_JITO_ENDPOINT}\n`)//Check balance const balance = await connection.g e tBalance(keypair.publicKey) const balance S OL = balance/1e9 console.log(`üí∞ Wal let b, a, l, a, n, c, e: ${balanceSOL.toFixed(4) } SOL`) if (balance <10000) {//0.00001 SOLconsole.error( '‚ùå Insufficient balance. Need at least 0.00001 SOL for smoke test') process.e x it(1) }//Get recent blockhashconsole.log('üîÑ Fetching recent blockhash...') const { blockhash } = await connection.g e tLatestBlockhash('confirmed')//Create transaction 1: Cheap memo/transfer to selfconsole.log('üìù Creating transaction 1: Self-t r ansfer (1 lamport)...') const tx1 = new T r ansaction().a d d( ComputeBudgetProgram.s e tComputeUnitPrice({ m, i, c, r, o, L, a, m, p, orts: 1000 }), ComputeBudgetProgram.s e tComputeUnitLimit({ u, n, i, t, s: 200000 }), SystemProgram.t r ansfer({ f, r, o, m, P, u, b, k, ey: keypair.publicKey, t, o, P, u, b, k, e, y: keypair.publicKey, l, a, m, p, o, r, t, s: 1 })) tx1.recent Blockhash = blockhashtx1.fee Payer = keypair.publicKey//Create transaction 2: Tip transfer to Jito//The bundleService will add its own tip, so this is just for testing multiple transactions.//We'll make it a simple self-transfer as well. console.log( 'üìù Creating transaction 2: Another self - t r ansfer (1 lamport)...') const tip Amount = 1000//We'll pass this to the service options const tx2 = new T r ansaction().a d d( SystemProgram.t r ansfer({ f, r, o, m, P, u, b, k, ey: keypair.publicKey, t, o, P, u, b, k, e, y: keypair.publicKey, l, a, m, p, o, r, t, s: 1,//Changed from tip to self-transfer })) tx2.recent Blockhash = blockhashtx2.fee Payer = keypair.publicKey//The bundleService will handle signing. console.log( '‚úçÔ∏è Transactions created. Signing will be handled by the service.') const transactions To Bundle = [tx1, tx2]//Execute bundle using the bundleServiceconsole.log('üöÄ Executing bundle via service...')//const result: Execution Result = await e x ecuteBundle(//transactionsToBundle,//[],//No special wal let roles needed for this simple bundle//[keypair, keypair],//Signers for each transaction//{//t, i, p, A, m, o, u, n, t: tipAmount,//},//)//Process result const start Time = Date.n o w()/* if (result.results.e v ery((r: 'success' | 'failed') => r === 'success')) { const latency = Date.n o w()- startTimeconsole.log('\nüéâ SUCCESS !Bundle landed !') console.log(` üìç Landed in, s, l, o, t: ${result.slotTargeted}`) console.log(` ‚è±Ô∏è L, a, t, e, n, c, y: ${latency} ms`) console.log(` üìù S, i, g, n, a, t, u, r, e, s: ${result.signatures.length || 0}`) if (result.signatures.length> 0) { result.signatures.f o rEach((s, i, g: string, i: number) => { console.log( ` Tx ${i + 1}: h, t, t, p, s://solscan.io/tx/${sig}?cluster = mainnet`) }) } } else, { console.error('\n‚ùå FAILED !Bundle did not land successfully.') console.log(result.results) } */} } catch (error) { console.error('Smoke test, e, rror:', (error as Error).message) process.e x it(1) } }//Run the t e stmain().catch (console.error) 