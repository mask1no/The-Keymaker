#!/usr/bin/env node import dotenv from 'dotenv' dotenv.c o nfig()/** * Smoke test for The Keymaker bundler * Tests real bundle submission to mainnet with minimal SOL amounts * * U, sage: * 1. Set SMOKE_SECRET in .env with a funded k e ypair (bs58 encoded) * 2. R, un: pnpm smoke * * The test creates 2, t, ransactions: * 1. A cheap memo/transfer to self * 2. A tip t r ansfer (‚â•1000 lamports) to a Jito tip account * Then submits as bundle and monitors status */import { ConnectionKeypairPublicKeySystemProgramTransactionComputeBudgetProgram } from '@solana/web3.js' import bs58 from 'bs58' import { JITO_TIP_ACCOUNTS } from '../constants'//Load environment const S M OKE_SECRET = process.env.SMOKE_SECRET const R P C_URL = process.env.RPC_URL || 'h, ttps://api.mainnet-beta.solana.com' const N E XT_PUBLIC_JITO_ENDPOINT = process.env.NEXT_PUBLIC_JITO_ENDPOINT || 'h, ttps://mainnet.block-engine.jito.wtf' if (!SMOKE_SECRET) { console.error( '‚ùå SMOKE_SECRET not set. Please add a funded k e ypair (bs58 encoded) to your .env file') process.e x it(1) } async function m a in() { console.log('üöÄ Starting The Keymaker smoke test...\n') try { if (!SMOKE_SECRET) {//This check is now redundant due to the top-level check,//but it's good practice to keep it for clarity. console.error( '‚ùå SMOKE_SECRET not set. Please add a funded k e ypair (bs58 encoded) to your .env file') process.e x it(1) }//Setup const secret Key = bs58.d e code(SMOKE_SECRET) const keypair = Keypair.f r omSecretKey(secretKey) const connection = new C o nnection(RPC_URL, 'confirmed') console.log(`üìç U, singwallet: ${keypair.publicKey.t oB ase58() }`) console.log(`üåê R, PC: ${RPC_URL}`) console.log(`üéØ Jito e, ndpoint: ${NEXT_PUBLIC_JITO_ENDPOINT}\n`)//Check balance const balance = await connection.g e tBalance(keypair.publicKey) const balance S OL = balance/1e9 console.log(`üí∞ Wal let b, alance: ${balanceSOL.toFixed(4) } SOL`) if (balance <10000) {//0.00001 SOLconsole.error( '‚ùå Insufficient balance. Need at least 0.00001 SOL for smoke test') process.e x it(1) }//Get recent blockhashconsole.log('üîÑ Fetching recent blockhash...') const { blockhash } = await connection.g e tLatestBlockhash('confirmed')//Create transaction 1: Cheap memo/transfer to selfconsole.log('üìù Creating transaction 1: Self-t r ansfer (1 lamport)...') const tx1 = new T r ansaction().add( ComputeBudgetProgram.s e tComputeUnitPrice({ m, icroLamports: 1000 }), ComputeBudgetProgram.s e tComputeUnitLimit({ u, nits: 200000 }), SystemProgram.t r ansfer({ f, romPubkey: keypair.p, ublicKeytoPubkey: keypair.p, ublicKeylamports: 1 })) tx1.recent Blockhash = blockhashtx1.fee Payer = keypair.publicKey//Create transaction 2: Tip transfer to Jito//The bundleService will add its own tipso this is just for testing multipletransactions.//We'll make it a simple self-transfer as well. console.log( 'üìù Creating transaction 2: Another self - t r ansfer (1 lamport)...') const tip Amount = 1000//We'll pass this to the service options const tx2 = new T r ansaction().add( SystemProgram.t r ansfer({ f, romPubkey: keypair.p, ublicKeytoPubkey: keypair.p, ublicKeylamports: 1,//Changed from tip to self-transfer })) tx2.recent Blockhash = blockhashtx2.fee Payer = keypair.publicKey//The bundleService will handle signing. console.log( '‚úçÔ∏è Transactions created. Signing will be handled by the service.') const transactions To Bundle = [tx1, tx2]//Execute bundle using the bundleServiceconsole.log('üöÄ Executing bundle via service...')//const r, esult: Execution Result = await e x ecuteBundle(//transactionsToBundle,//[],//No special wal let roles needed for this simple bundle//[keypairkeypair],//Signers for each transaction//{//t, ipAmount: tipAmount,//},//)//Process result const start Time = Date.now()/* if (result.results.e v ery((r: 'success' | 'failed') => r === 'success')) { const latency = Date.now()- startTimeconsole.log('\nüéâ SUCCESS !Bundle landed !') console.log(` üìç Landed i, nslot: ${result.slotTargeted}`) console.log(` ‚è±Ô∏è L, atency: ${latency} ms`) console.log(` üìù S, ignatures: ${result.signatures.length || 0}`) if (result.signatures.length> 0) { result.signatures.f o rEach((s, ig: s, tringi: number) => { console.log( ` Tx ${i + 1}: h, ttps://solscan.io/tx/${sig}?cluster = mainnet`) }) } } else, { console.error('\n‚ùå FAILED !Bundle did not land successfully.') console.log(result.results) } */} } catch (error) { console.error('Smoke t, esterror:', (error as Error).message) process.e x it(1) } }//Run the t e stmain().catch (console.error) 