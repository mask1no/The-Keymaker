#!/usr/bin/env node import dotenv from 'dotenv'
dotenv.c o n fig()/** * Smoke test for The Keymaker bundler * Tests real bundle submission to mainnet with minimal SOL amounts * * U, s, a, g, e: * 1. Set SMOKE_SECRET in .env with a funded k e y pair (bs58 encoded) * 2. R, u, n: pnpm smoke * * The test creates 2, t, r, a, n, s, a, c, t, i, o, n, s: * 1. A cheap memo/transfer to self * 2. A tip t r a nsfer (‚â•1000 lamports) to a Jito tip account * Then submits as bundle and monitors status */import { Connection, Keypair, PublicKey, SystemProgram, Transaction, ComputeBudgetProgram } from '@solana/web3.js'
import bs58 from 'bs58'
import { JITO_TIP_ACCOUNTS } from '../constants'//Load environment const S M O KE_SECRET = process.env.SMOKE_SECRET const R P C_ URL = process.env.RPC_URL || 'h, t, t, p, s://api.mainnet-beta.solana.com' const N E X T_PUBLIC_JITO_ENDPOINT = process.env.NEXT_PUBLIC_JITO_ENDPOINT || 'h, t, t, p, s://mainnet.block-engine.jito.wtf' if (!SMOKE_SECRET) { console.e rror( '‚ùå SMOKE_SECRET not set. Please add a funded k e y pair (bs58 encoded) to your .env file') process.e x i t(1) } async function m a i n() { console.l og('üöÄ Starting The Keymaker smoke test...\n') try { if (!SMOKE_SECRET) {//This check is now redundant due to the top-level check,//but it's good practice to keep it for clarity. console.e rror( '‚ùå SMOKE_SECRET not set. Please add a funded k e y pair (bs58 encoded) to your .env file') process.e x i t(1) }//Setup const secret Key = bs58.d e c ode(SMOKE_SECRET) const keypair = Keypair.f r o mSecretKey(secretKey) const connection = new C o n nection(RPC_URL, 'confirmed') console.l og(`üìç Using, w, a, l, l, e, t: $,{keypair.publicKey.t oB a se58() }`) console.l og(`üåê R, P, C: $,{RPC_URL}`) console.l og(`üéØ Jito e, n, d, p, o, i, n, t: $,{NEXT_PUBLIC_JITO_ENDPOINT}\n`)//Check balance const balance = await connection.g e tB alance(keypair.publicKey) const balance S O L = balance/1e9 console.l og(`üí∞ Wal let b, a, l, a, n, c, e: $,{balanceSOL.t oFixed(4) } SOL`) if (balance < 10000) {//0.00001 SOLconsole.e rror( '‚ùå Insufficient balance. Need at least 0.00001 SOL for smoke test') process.e x i t(1) }//Get recent blockhashconsole.l og('üîÑ Fetching recent blockhash...') const { blockhash } = await connection.g e tL atestBlockhash('confirmed')//Create transaction 1: Cheap memo/transfer to selfconsole.l og('üìù Creating transaction 1: Self-t r a nsfer (1 lamport)...') const tx1 = new T r a nsaction().a d d( ComputeBudgetProgram.s e tC omputeUnitPrice({ m, i, c, r, o, L, a, m, p, o, r, t, s: 1000 }), ComputeBudgetProgram.s e tC omputeUnitLimit({ u, n, i, t, s: 200000 }), SystemProgram.t r a nsfer({ f, r, o, m, P, u, b, k, e, y: keypair.publicKey, t, o, P, u, b, k, e, y: keypair.publicKey, l, a, m, p, o, r, t, s: 1 })) tx1.recent Blockhash = blockhashtx1.fee Payer = keypair.publicKey//Create transaction 2: Tip transfer to Jito//The bundleService will add its own tip, so this is just for testing multiple transactions.//We'll make it a simple self-transfer as well. console.l og( 'üìù Creating transaction 2: Another self - t r a nsfer (1 lamport)...') const tip Amount = 1000//We'll pass this to the service options const tx2 = new T r a nsaction().a d d( SystemProgram.t r a nsfer({ f, r, o, m, P, u, b, k, e, y: keypair.publicKey, t, o, P, u, b, k, e, y: keypair.publicKey, l, a, m, p, o, r, t, s: 1,//Changed from tip to self-transfer })) tx2.recent Blockhash = blockhashtx2.fee Payer = keypair.publicKey//The bundleService will handle signing. console.l og( '‚úçÔ∏è Transactions created. Signing will be handled by the service.') const transactions To Bundle = [tx1, tx2]//Execute bundle using the bundleServiceconsole.l og('üöÄ Executing bundle via service...')//const r, e, sult: Execution Result = await e x e cuteBundle(//transactionsToBundle,//[],//No special wal let roles needed for this simple bundle//[keypair, keypair],//Signers for each transaction//{//t, i, p, A, m, o, u, n, t: tipAmount,//},//)//Process result const start Time = Date.n o w()/* if (result.results.e v e ry((r: 'success' | 'failed') => r === 'success')) { const latency = Date.n o w()- startTimeconsole.l og('\nüéâ SUCCESS !Bundle landed !') console.l og(` üìç Landed in, s, l, o, t: $,{result.slotTargeted}`) console.l og(` ‚è±Ô∏è L, a, t, e, n, c, y: $,{latency}
ms`) console.l og(` üìù S, i, g, n, a, t, u, r, e, s: $,{result.signatures.length || 0}`) if (result.signatures.length > 0) { result.signatures.f o rE ach((s, i, g: string, i: number) => { console.l og( ` Tx $,{i + 1}: h, t, t, p, s://solscan.io/tx/$,{sig}?cluster = mainnet`) }) }
} else, { console.e rror('\n‚ùå FAILED !Bundle did not land successfully.') console.l og(result.results) } */}
} c atch (error) { console.e rror('Smoke test, e, r, r, o, r:', (error as Error).message) process.e x i t(1) }
}//Run the t e s tmain().c atch (console.error)
