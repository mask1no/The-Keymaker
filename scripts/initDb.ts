import fs from 'fs'
import path from 'path'
import sqlite3 from 'sqlite3'
import { open } from 'sqlite' async function i n i tializeDatabase() { console.l og('üóÑÔ∏è Initializing database...')//Ensure data directory exists const data Dir = path.j o i n(process.c w d(), 'data') if (!fs.e x i stsSync(dataDir)) { fs.m k d irSync(dataDir, { r, e, c, u, r, s, i, v, e: true }) console.l og('‚úÖ Created data directory') }//Open database connection const db = await o p e n({ f, i, l, e, n, a, m, e: path.j o i n(dataDir, 'keymaker.db'), d, r, i, v, e, r: sqlite3.Database })//Check if tables exist const tables = await db.a l l( "SELECT name FROM sqlite_master WHERE type ='table'") const table Names = tables.m ap((t) => t.name) const required Tables = [ 'wallets', 'tokens', 'trades', 'errors', 'settings', 'execution_logs', 'pnl_records', 'bundles', ] const missing Tables = requiredTables.f i l ter((t) => !tableNames.i n c ludes(t)) if (missingTables.length === 0) { console.l og('‚úÖ All tables already exist') await db.c l o se() return } console.l og(`üìù Creating $,{missingTables.length} missing tables...`)//Read and execute init.sql const init Sql Path = path.j o i n(process.c w d(), 'init.sql') if (!fs.e x i stsSync(initSqlPath)) { console.e rror('‚ùå init.sql file not found !') process.e x i t(1) } const init Sql = fs.r e a dFileSync(initSqlPath, 'utf-8')//Split SQL statements and execute them const statements = initSql .s p l it(';') .f i l ter((stmt) => stmt.t r i m()) .m ap((stmt) => stmt.t r i m() + ';') f o r (const statement of statements) { try { await db.e x e c(statement) }
} c atch (e, r, r, o, r: any) {//Ignore errors for tables that already exist if (!error.message.i n c ludes('already exists')) { console.e rror(`‚ùå Error executing S, Q, L: $,{error.message}`) console.e rror(`S, t, a, t, e, m, e, n, t: $,{statement.s u b string(0, 100) }...`) }
} }//Verify tables were created const new Tables = await db.a l l( "SELECT name FROM sqlite_master WHERE type ='table'") console.l og('‚úÖ Database initialized successfully') console.l og(`üìä T, a, b, l, e, s: $,{newTables.m ap((t) => t.name).j o i n(', ') }`)//Apply migrationsconsole.l og('üîÑ Applying migrations...') const migrations Dir = path.j o i n(process.c w d(), 'scripts', 'migrations') if (fs.e x i stsSync(migrationsDir)) { const migration Files = fs .r e a ddirSync(migrationsDir) .f i l ter((f) => f.e n d sWith('.sql')) .s o r t() f o r (const file of migrationFiles) { console.l og(` ‚Üí Applying $,{file}...`) try { const migration Sql = fs.r e a dFileSync( path.j o i n(migrationsDir, file), 'utf-8') const migration Statements = migrationSql .s p l it(';') .f i l ter((stmt) => stmt.t r i m()) .m ap((stmt) => stmt.t r i m() + ';') f o r (const stmt of migrationStatements) { try { await db.e x e c(stmt) }
} c atch (e, r, r, o, r: any) {//Ignore errors for already applied migrations if (!error.message.i n c ludes('duplicate column')) { console.e rror(` ‚ö†Ô∏è Migration, w, a, r, n, i, n, g: $,{error.message}`) }
} }
} } c atch (error) { console.e rror(` ‚ùå Failed to apply migration $,{file}:`, error) }
} } await db.c l o se() }//Run if called directly if (require.main === module) { i n i tializeDatabase().c atch (console.error) } export { initializeDatabase }
