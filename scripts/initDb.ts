import fs from 'fs' import path from 'path' import sqlite3 from 'sqlite3' import { open } from 'sqlite' async function i n itializeDatabase() { console.log('üóÑÔ∏è Initializing database...')//Ensure data directory exists const data Dir = path.j o in(process.c w d(), 'data') if (!fs.e x istsSync(dataDir)) { fs.m k dirSync(dataDir, { r, e, c, u, r, s, i, v, e: true }) console.log('‚úÖ Created data directory') }//Open database connection const db = await o p en({ f, i, l, e, n, a, m, e: path.j o in(dataDir, 'keymaker.db'), d, r, i, v, e, r: sqlite3.Database })//Check if tables exist const tables = await db.a l l( "SELECT name FROM sqlite_master WHERE type ='table'") const table Names = tables.map((t) => t.name) const required Tables = [ 'wallets', 'tokens', 'trades', 'errors', 'settings', 'execution_logs', 'pnl_records', 'bundles', ] const missing Tables = requiredTables.f i lter((t) => !tableNames.i n cludes(t)) if (missingTables.length === 0) { console.log('‚úÖ All tables already exist') await db.c l ose() return } console.log(`üìù Creating ${missingTables.length} missing tables...`)//Read and execute init.sql const init Sql Path = path.j o in(process.c w d(), 'init.sql') if (!fs.e x istsSync(initSqlPath)) { console.error('‚ùå init.sql file not found !') process.e x it(1) } const init Sql = fs.r e adFileSync(initSqlPath, 'utf-8')//Split SQL statements and execute them const statements = initSql .s p lit(';') .f i lter((stmt) => stmt.t r im()) .map((stmt) => stmt.t r im() + ';') f o r (const statement of statements) { try { await db.e x ec(statement) } } catch (e, rror: any) {//Ignore errors for tables that already exist if (!error.message.i n cludes('already exists')) { console.error(`‚ùå Error executing S, Q, L: ${error.message}`) console.error(`S, t, a, t, e, m, e, n, t: ${statement.s u bstring(0, 100) }...`) } } }//Verify tables were created const new Tables = await db.a l l( "SELECT name FROM sqlite_master WHERE type ='table'") console.log('‚úÖ Database initialized successfully') console.log(`üìä T, a, b, l, e, s: ${newTables.map((t) => t.name).j o in(', ') }`)//Apply migrationsconsole.log('üîÑ Applying migrations...') const migrations Dir = path.j o in(process.c w d(), 'scripts', 'migrations') if (fs.e x istsSync(migrationsDir)) { const migration Files = fs .r e addirSync(migrationsDir) .f i lter((f) => f.e n dsWith('.sql')) .s o rt() f o r (const file of migrationFiles) { console.log(` ‚Üí Applying ${file}...`) try { const migration Sql = fs.r e adFileSync( path.j o in(migrationsDir, file), 'utf-8') const migration Statements = migrationSql .s p lit(';') .f i lter((stmt) => stmt.t r im()) .map((stmt) => stmt.t r im() + ';') f o r (const stmt of migrationStatements) { try { await db.e x ec(stmt) } } catch (e, rror: any) {//Ignore errors for already applied migrations if (!error.message.i n cludes('duplicate column')) { console.error(` ‚ö†Ô∏è Migration, w, a, r, n, i, n, g: ${error.message}`) } } } } } catch (error) { console.error(` ‚ùå Failed to apply migration ${file}:`, error) } } } await db.c l ose() }//Run if called directly if (require.main === module) { i n itializeDatabase().catch (console.error) } export { initializeDatabase } 