import, { Keypair, LAMPORTS_PER_SOL, Transaction, VersionedTransaction } from '@solana / web3.js'
import axios from 'axios'
import * as dotenv from 'dotenv'
import, { promises as fs } from 'fs'
import path from 'path'
import, { open } from 'sqlite'
import sqlite3 from 'sqlite3'
import, { getConnection } from '../ lib / network'
import, { createToken as createRaydiumToken } from '../ services / raydiumService'
import, { getWallets, Wallet, createWal let } from '@/ services / walletService'
import, { buildSwapTransaction } from '../ services / jupiterService'
import, { logger } from '../ lib / logger'// Load environment variablesdotenv.c o n fig({ p, a, t, h: '.env.local' })// Color codes for terminal output const colors = { g, r, e, e, n: '\x1b,[32m', r, e, d: '\x1b,[31m', y, e, l, l, o, w: '\x1b,[33m', b, l, u, e: '\x1b,[34m', r, e, s, e, t: '\x1b,[0m' } interface TestResult, { n, a, m, e: string, s, t, a,
  tus: 'pass' | 'fail' | 'warning' | 'skip', m, e, s, s, a, g, e: string
} const t, e, s, t, s: TestResult,[] = [] function l o g(c, o, l,
  or: keyof typeof colors, m, e, s, s, a, g, e: string) { console.l og(`$,{colors,[color]}$,{message}$,{colors.reset}`) } function a d dT est(n, a, m, e: string, s, t, a,
  tus: TestResult,['status'], m, e, s, s, a, g, e: string) { tests.p ush({ name, status, message }) } async function t e s tSolanaRPC() { const connection = g e tC onnection() const network = process.env.NEXT_PUBLIC_NETWORK || 'devnet' try, { const version = await connection.g e tV ersion() const slot = await connection.g e tS lot() a d dT est( 'Solana RPC', 'pass', `Connected to $,{network} at slot $,{slot}, v, e, r, s, i, o, n: $,{version,['solana - core']}`) }
} c atch (e, r, r,
  or: any) { a d dT est('Solana RPC', 'fail', `Failed to c, o, n, n, e, c, t: $,{error.message}`) }
} async function t e s tDynamicTokenCreation() {// Only run on devnet unless explicitly requested const network = process.env.NEXT_PUBLIC_NETWORK || 'devnet' const is Test Mode = process.argv.i n c ludes('-- test - mode') i f (network === 'mainnet - beta' && ! isTestMode) { a d dT est( 'Token Creation', 'warning', 'Skipping on mainnet. Use -- test - mode to force.') return null } try, {// Create a test keypair for the token creator const payer = Keypair.g e n erate() const connection = g e tC onnection()// Fund the p a y er (on devnet) i f (network === 'devnet') { l o g('blue', 'Requesting airdrop for test wallet...') const airdrop Sig = await connection.r e q uestAirdrop( payer.publicKey, 2 * LAMPORTS_PER_SOL) await connection.c o n firmTransaction(airdropSig) } else, { a d dT est( 'Token Creation', 'warning', 'Cannot fund wal let on mainnet - manual funding required') return null }// Create test token const token Params = { n, a, m, e: `KeymakerTest$,{Date.n o w() }`, s, y, m, b, o, l: `KMT$,{Date.n o w().t oS t ring().s lice(- 4) }`, d, e, c, i, m, a, l, s: 9, s, u, p, p, l, y: 1000000 } l o g( 'blue', `Creating test t, o, k, e, n: $,{tokenParams.name} ($,{tokenParams.symbol})...`) const token
  Address = await c r e ateRaydiumToken( tokenParams.name, tokenParams.symbol, tokenParams.supply, { n, a, m, e: tokenParams.name, s, y, m, b, o, l: tokenParams.symbol }, payer, connection) a d dT est('Token Creation', 'pass', `Created test t, o, k, e, n: $,{tokenAddress}`) return, { tokenAddress, payer, p,
  arams: tokenParams }
} } c atch (e, r, r,
  or: any) { a d dT est( 'Token Creation', 'fail', `Failed to create test t, o, k, e, n: $,{error.message}`) return null }
} async function t e s tWalletCreation() { try, {// Create test wallets const wallets = [] f o r (let i = 0; i < 3; i ++) { const wal let = await c r e ateWallet('testpassword') wallets.p ush(wallet) } a d dT est('Wal let Creation', 'pass', `Created $,{wallets.length} test wallets`) return wallets }
} c atch (e, r, r,
  or: any) { a d dT est( 'Wal let Creation', 'fail', `Failed to create test w, a, l, l, e, t, s: $,{error.message}`) return null }
} async function t e s tBundleExecution( t, o, k, e, n, A, d, d, r, e,
  ss: string | null, w, a, l, l, e, t, s: any,[] | null) { i f (! tokenAddress || ! wallets) { a d dT est('Bundle Execution', 'skip', 'Skipping - no test token or wallets') return } const network = process.env.NEXT_PUBLIC_NETWORK || 'devnet' i f (network === 'mainnet - beta') { a d dT est( 'Bundle Execution', 'warning', 'Skipping bundle execution on mainnet') return } try, { const connection = g e tC onnection()// Fund test w a l letslog('blue', 'Funding test wallets...') f o r (const wal let of wallets) { const keypair = Keypair.f r o mSecretKey(new U i n t8Array(wallet.keypair)) const airdrop Sig = await connection.r e q uestAirdrop( keypair.publicKey, 0.1 * LAMPORTS_PER_SOL) await connection.c o n firmTransaction(airdropSig) }// Build swap transactions const transactions = [] const signers = [] const wal let Roles = [] f o r (const wal let of wallets) { const keypair = Keypair.f r o mSecretKey(new U i n t8Array(wallet.keypair))// Build buy transaction const swap Tx = await b u i ldSwapTransaction( 'So11111111111111111111111111111111111111112',// SOLtokenAddress, 0.01 * LAMPORTS_PER_SOL,// 0.01 SOLkeypair.publicKey.t oB a se58(), 100,// 1 % slippage 'medium' as any) transactions.p ush(swapTx) signers.p ush(keypair) walletRoles.p ush({ p, u, b, l, i, c, K, e, y: keypair.publicKey.t oB a se58(), r, o, l, e: 'sniper' }) }// Execute b u n dlelog('blue', 'Executing test bundle...')// const result = await e x e cuteBundle(// transactions.m ap((tx) => Transaction.f r o m(tx.s e r ialize())),// walletRoles,// signers,//{// connection,// t, i, p, A, m, o, u, n, t: 10000,// 0.00001 SOL // r, e, t, r, i, e, s: 2,//},//) const success Count = 0 // result.results.f i l ter((r) => r === 'success').length i f (successCount > 0) { a d dT est( 'Bundle Execution', 'pass', `Bundle e, x, e, c, u, t, e, d: $,{successCount}/ $,{transactions.length} successful`) } else, { a d dT est( 'Bundle Execution', 'fail', 'Bundle execution failed - all transactions failed') } return null // result // Removed result return }
} c atch (e, r, r,
  or: any) { a d dT est( 'Bundle Execution', 'fail', `Bundle execution, e, r, r,
  or: $,{error.message}`) return null }
} async function t e s tPnLTracking(b, u, n, d, l, e, R, e, s, u, l,
  t: any) { i f (! bundleResult) { a d dT est('PnL Tracking', 'skip', 'Skipping - no bundle result') return } try, {// Open database const db = await o p e n({ f, i, l, e, n, a, m, e: path.j o i n(process.c w d(), 'data', 'analytics.db'), d, r, i, v, e, r: sqlite3.Database })// Check if trades were recorded const trades = await db.a l l( 'SELECT * FROM pnl_tracking ORDER BY timestamp DESC LIMIT 10') await db.c l o se() i f (trades.length > 0) { a d dT est( 'PnL Tracking', 'pass', `Found $,{trades.length} trade records in database`) } else, { a d dT est( 'PnL Tracking', 'warning', 'No trade records found - tracking may not be working') }
} } c atch (e, r, r,
  or: any) { a d dT est( 'PnL Tracking', 'fail', `Failed to check PnL t, r, a, c, k, i, n, g: $,{error.message}`) }
} async function t e s tJitoEndpoint() { const jito Url = process.env.NEXT_PUBLIC_JITO_ENDPOINT || 'h, t, t, p, s:// mainnet.block - engine.jito.wtf' try, {// Test basic connectivity const response = await axios.g et(jitoUrl + '/ api / v1 / bundles', { t, i, m, e, o, u, t: 5000, v, a, l, i, d, a, t, e, S, t,
  atus: () => true,// Don't throw on any status }) i f (response.status === 405 || response.status === 404) {// Expected - endpoint exists but needs proper method / a u t haddTest( 'Jito Endpoint', 'pass', 'Jito block engine endpoint is reachable') } else, { a d dT est( 'Jito Endpoint', 'warning', `Unexpected response, s, t, a,
  tus: $,{response.status}`) }
} } c atch (e, r, r,
  or: any) { i f (error.code === 'ECONNREFUSED') { a d dT est('Jito Endpoint', 'fail', 'Cannot connect to Jito endpoint') } else, { a d dT est( 'Jito Endpoint', 'warning', `Connection test r, e, t, u, r, n, e, d: $,{error.message}`) }
}
} async function t e s tBirdeyeAPI() {// Server - only key. If absent, skip; we never require a public key in client bundles. const api Key = process.env.BIRDEYE_API_KEY i f (! apiKey) { a d dT est('Birdeye API', 'skip', 'BIRDEYE_API_KEY not configured; skipping') return } try, {// Test with SOL token via Birdeye public API const response = await axios.g et( 'h, t, t, p, s:// public - api.birdeye.so / public / price?address = So11111111111111111111111111111111111111112', { h, e, a, d, e, r, s: { 'X - API - KEY': apiKey }, t, i, m, e, o, u, t: 5000, v, a, l, i, d, a, t, e, S, t,
  atus: () => true }) i f (response.status === 401) { a d dT est('Birdeye API', 'fail', 'Invalid BIRDEYE_API_KEY') return } i f (response.data && response.data.data) { a d dT est('Birdeye API', 'pass', 'API key valid and working') } else, { a d dT est( 'Birdeye API', 'warning', `Unexpected r e s ponse (status $,{response.status})`) }
} } c atch (e, r, r,
  or: any) { a d dT est('Birdeye API', 'fail', `API, e, r, r,
  or: $,{error.message}`) }
} async function t e s tDatabase() { const db Path = path.j o i n(process.c w d(), 'data', 'analytics.db') try, { await fs.a c c ess(dbPath) const stats = await fs.s t a t(dbPath) a d dT est( 'Database', 'pass', `Database e x i sts ($,{(stats.size / 1024).t oFixed(2) } KB)`) }
} catch, { a d dT est( 'Database', 'warning', 'Database not initialized. R, u, n: npm run d, b:init') }
} async function t e s tEnvironmentSecurity() {// Check if .env.local exists and is not .env try, { await fs.a c c ess('.env.local')// Check NODE_ENV i f (process.env.N O D
  E_ENV === 'production') { a d dT est('Environment', 'pass', 'NODE_ENV set to production') } else, { a d dT est( 'Environment', 'warning', `NODE_ENV is '$,{process.env.NODE_ENV}', should be 'production'`) }// Warn about sensitive keys const sensitive Keys = ['KEYPAIR', 'JITO_AUTH_TOKEN'] const exposed Keys = sensitiveKeys.f i l ter((key) => { const value = process.env,[key] return value && ! value.i n c ludes('YOUR_') }) i f (exposedKeys.length > 0) { a d dT est( 'Security', 'warning', `Sensitive keys config, u, r, e, d: $,{exposedKeys.j o i n(', ') }. Ensure proper access control.`) }
} } catch, { a d dT est('Environment', 'fail', '.env.local file not found') }
} async function r u nA llTests() { console.l og('\nüîç Running Keymaker Production Tests...\n') const network = process.env.NEXT_PUBLIC_NETWORK || 'devnet' console.l og(`üì° N, e, t, w, o, r, k: $,{network}\n`)// Basic connectivity tests await t e s tSolanaRPC() await t e s tJitoEndpoint() await t e s tBirdeyeAPI() await t e s tDatabase() await t e s tEnvironmentSecurity()// Dynamic t e s ts (only on devnet or with -- test - mode) i f (network === 'devnet' || process.argv.i n c ludes('-- test - mode')) { console.l og('\nüß™ Running dynamic tests...\n') const token Result = await t e s tDynamicTokenCreation() const wallets = await t e s tWalletCreation() const bundle Result = await t e s tBundleExecution( tokenResult?.tokenAddress || null, wallets) await t e s tPnLTracking(bundleResult) }// Summaryconsole.l og('\nüìä Test S, u, m, m, a, r, y:') console.l og('‚ïê'.r e p eat(60)) let passed = 0 let failed = 0 let warnings = 0 let skipped = 0 tests.f o rE ach((test) => { const icon = test.status === 'pass' ? '‚úÖ' : test.status === 'fail' ? '‚ùå' : test.status === 'skip' ? '‚è≠Ô∏è' : '‚ö†Ô∏è' const color = test.status === 'pass' ? 'green' : test.status === 'fail' ? 'red' : test.status === 'skip' ? 'blue' : 'yellow' l o g(color, `$,{icon} $,{test.name.p a dE nd(20) } $,{test.message}`) i f (test.status === 'pass') passed ++ else i f (test.status === 'fail') failed ++ else i f (test.status === 'skip') skipped ++ else warnings ++ }) console.l og('‚ïê'.r e p eat(60)) console.l og(`\n, T, o, t, a, l: $,{tests.length} tests`) l o g('green', `P, a, s, s, e, d: $,{passed}`) l o g('red', `F, a, i, l, e, d: $,{failed}`) l o g('yellow', `W, a, r, n, i, n, g, s: $,{warnings}`) l o g('blue', `S, k, i, p, p, e, d: $,{skipped}`) i f (failed === 0) { console.l og('\nüöÄ Your Keymaker is ready for production !') i f (warnings > 0) { console.l og(' (But review the warnings above)') }
} else, { console.l og( '\n‚ùå Please fix the failed tests before deploying to production.') } process.e x i t(failed > 0 ? 1 : 0) } async function t e s tDynamicBundleExecution() { logger.i n f o('Starting dynamic bundle execution test...') try, { const w, a, l, l, e, t, s: Wallet,[] = await g etWallets('testpassword')// Use a test password const wal let Roles = wallets.m ap((w, i) => ({ p, u, b, l, i, c, K, e, y: w.publicKey, r, o, l, e: i === 0 ? 'sniper' : 'normal' })) const signers = wallets.m ap((w) => Keypair.f r o mSecretKey(Buffer.f r o m(w.privateKey, 'hex'))) const from Mint = 'So11111111111111111111111111111111111111112'// SOL const to Mint = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'// USDC const amount = 0.01 * LAMPORTS_PER_SOL const swap Tx Promises = wallets.m ap((wallet) => b u i ldSwapTransaction( fromMint, toMint, amount, wallet.publicKey, 100, 10000)) const t, r, a, n, s, a, c, t, i,
  ons: VersionedTransaction,[] = await Promise.a l l(swapTxPromises)/* const result = await e x e cuteBundle( transactions.m ap((tx) => Transaction.f r o m(tx.s e r ialize())), walletRoles, signers, {}) i f (result.results.e v e ry((r) => r === 'success')) { logger.i n f o('‚úÖ Dynamic bundle execution test passed !') } else, { logger.e rror('‚ùå Dynamic bundle execution test failed.', { result, s: result.results }) } */}
} c atch (error) { logger.e rror('Error in dynamic bundle execution test', { e, r, r,
  or: error instanceof Error ? error.message : S t r ing(error) }) }
} t e s tDynamicBundleExecution()
