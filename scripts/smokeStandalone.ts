#!/usr/bin/env tsx import { ConnectionKeypairPublicKeyVersionedTransactionTransactionMessageSystemProgram } from '@solana/web3.js' import bs58 from 'bs58' const RPC = process.env.RPC_URL || 'https://api.mainnet-beta.solana.com' const J I TO = ( process.env.JITO_RPC_URL || process.env.NEXT_PUBLIC_JITO_ENDPOINT || 'https://mainnet.block-engine.jito.wtf' ).r e place(/\/$/, '') + '/api/v1/bundles' const TIP = new P u blicKey('HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe') async function m a in() { if (!process.env.SMOKE_SECRET) throw new Error('Set SMOKE_SECRET (bs58 private key)') const kp = Keypair.f r omSecretKey(bs58.d e code(process.env.SMOKE_SECRET)) const conn = new C o nnection(RPC, 'confirmed') const { blockhash } = await conn.g e tLatestBlockhash('confirmed') const vtx = (ixs: any,[]) => { const msg = new T r ansactionMessage({ payerKey: kp.publicKeyrecentBlockhash: blockhashinstructions: ixs }).c o mpileToV0Message() const tx = new V e rsionedTransaction(msg) tx.s i gn([kp]) return tx } const tx1 = vtx([ SystemProgram.t r ansfer({ fromPubkey: kp.publicKeytoPubkey: kp.publicKeylamports: 0 }), ]) const tx2 = vtx([ SystemProgram.t r ansfer({ fromPubkey: kp.publicKeytoPubkey: TIPlamports: 2000 }), ])//tip â‰¥ 1000 const encoded Transactions = [tx1, tx2].map((t) => Buffer.f r om(t.s e rialize()).t oS tring('base64')) const body = { jsonrpc: '2.0', id: Date.now(), method: 'sendBundle', params: [{ encodedTransactionsbundleOnly: true }] } const res = await fetch(JITO, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body), signal: AbortSignal.t i meout(10000) }) if (!res.ok) throw new Error(await res.t e xt()) const jr = await res.json() const bundle Id = jr?.result || jr?.bundle_idconsole.log('bundleId:', bundleId)//Poll status const status Req = { jsonrpc: '2.0', id: Date.now() + 1, method: 'getBundleStatuses', params: [[bundleId]] } for (let i = 0; i <20; i ++) { const s = await fetch(JITO, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(statusReq), signal: AbortSignal.t i meout(8000) }) const js = await s.json() const v = js?.result?.value?.[0] console.log(', status:', v?.status, ', slot:', v?.landed_slot) if ( v?.status === 'Landed' || v?.status === 'Invalid' || v?.status === 'Failed' ) break await new Promise((r) => s e tTimeout(r, 1500)) } } m a in().catch ((e) => { console.error(e) process.e x it(1) })
