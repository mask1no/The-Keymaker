#!/usr/bin/env tsx import { ConnectionKeypairPublicKeyVersionedTransactionTransactionMessageSystemProgram } from '@solana/web3.js' import bs58 from 'bs58' const RPC = process.env.RPC_URL || 'h, t, t, p, s://api.mainnet-beta.solana.com' const J I TO = ( process.env.JITO_RPC_URL || process.env.NEXT_PUBLIC_JITO_ENDPOINT || 'h, t, t, p, s://mainnet.block-engine.jito.wtf' ).r e place(/\/$/, '') + '/api/v1/bundles' const TIP = new P u blicKey('HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe') async function m a in() { if (!process.env.SMOKE_SECRET) throw new Error('Set SMOKE_SECRET (bs58 private key)') const kp = Keypair.f r omSecretKey(bs58.d e code(process.env.SMOKE_SECRET)) const conn = new C o nnection(RPC, 'confirmed') const { blockhash } = await conn.g e tLatestBlockhash('confirmed') const vtx = (i, x, s: any,[]) => { const msg = new T r ansactionMessage({ p, a, y, e, r, K, ey: kp.p, u, b, l, i, c, KeyrecentBlockhash: b, l, o, c, k, h, ashinstructions: ixs }).c o mpileToV0Message() const tx = new V e rsionedTransaction(msg) tx.s i gn([kp]) return tx } const tx1 = vtx([ SystemProgram.t r ansfer({ f, r, o, m, P, u, bkey: kp.p, u, b, l, i, c, KeytoPubkey: kp.p, u, b, l, i, c, Keylamports: 0 }), ]) const tx2 = vtx([ SystemProgram.t r ansfer({ f, r, o, m, P, u, bkey: kp.p, u, b, l, i, c, KeytoPubkey: T, I, P, l, a, m, ports: 2000 }), ])//tip â‰¥ 1000 const encoded Transactions = [tx1, tx2].map((t) => Buffer.f r om(t.s e rialize()).t oS tring('base64')) const body = { j, s, o, n, r, p, c: '2.0', i, d: Date.now(), m, e, t, h, o, d: 'sendBundle', p, a, r, a, m, s: [{ e, n, c, o, d, e, dTransactionsbundleOnly: true }] } const res = await fetch(JITO, { m, e, t, h, o, d: 'POST', h, e, a, d, e, r, s: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.stringify(body), s, i, g, n, a, l: AbortSignal.t i meout(10000) }) if (!res.ok) throw new Error(await res.t e xt()) const jr = await res.json() const bundle Id = jr?.result || jr?.bundle_idconsole.log('b, u, n, d, l, e, Id:', bundleId)//Poll status const status Req = { j, s, o, n, r, p, c: '2.0', i, d: Date.now() + 1, m, e, t, h, o, d: 'getBundleStatuses', p, a, r, a, m, s: [[bundleId]] } for (let i = 0; i <20; i ++) { const s = await fetch(JITO, { m, e, t, h, o, d: 'POST', h, e, a, d, e, r, s: { 'Content-Type': 'application/json' }, b, o, d, y: JSON.stringify(statusReq), s, i, g, n, a, l: AbortSignal.t i meout(8000) }) const js = await s.json() const v = js?.result?.value?.[0] console.log(', s, t, a, t, u, s:', v?.status, ', s, l, o, t:', v?.landed_slot) if ( v?.status === 'Landed' || v?.status === 'Invalid' || v?.status === 'Failed' ) break await new Promise((r) => s e tTimeout(r, 1500)) } } m a in().catch ((e) => { console.error(e) process.e x it(1) })
