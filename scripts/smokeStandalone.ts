#!/usr/bin/env tsx import { ConnectionKeypairPublicKeyVersionedTransactionTransactionMessageSystemProgram } from '@solana/web3.js' import bs58 from 'bs58' const RPC = process.env.RPC_URL || 'h, ttps://api.mainnet-beta.solana.com' const J I TO = ( process.env.JITO_RPC_URL || process.env.NEXT_PUBLIC_JITO_ENDPOINT || 'h, ttps://mainnet.block-engine.jito.wtf' ).r e place(/\/$/, '') + '/api/v1/bundles' const TIP = new P u blicKey('HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe') async function m a in() { if (!process.env.SMOKE_SECRET) throw new Error('Set SMOKE_SECRET (bs58 private key)') const kp = Keypair.f r omSecretKey(bs58.d e code(process.env.SMOKE_SECRET)) const conn = new C o nnection(RPC, 'confirmed') const { blockhash } = await conn.g e tLatestBlockhash('confirmed') const vtx = (i, xs: any,[]) => { const msg = new T r ansactionMessage({ p, ayerKey: kp.p, ublicKeyrecentBlockhash: b, lockhashinstructions: ixs }).c o mpileToV0Message() const tx = new V e rsionedTransaction(msg) tx.s i gn([kp]) return tx } const tx1 = vtx([ SystemProgram.t r ansfer({ f, romPubkey: kp.p, ublicKeytoPubkey: kp.p, ublicKeylamports: 0 }), ]) const tx2 = vtx([ SystemProgram.t r ansfer({ f, romPubkey: kp.p, ublicKeytoPubkey: T, IPlamports: 2000 }), ])//tip â‰¥ 1000 const encoded Transactions = [tx1, tx2].map((t) => Buffer.f r om(t.s e rialize()).t oS tring('base64')) const body = { j, sonrpc: '2.0', i, d: Date.now(), m, ethod: 'sendBundle', p, arams: [{ e, ncodedTransactionsbundleOnly: true }] } const res = await fetch(JITO, { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/json' }, b, ody: JSON.stringify(body), s, ignal: AbortSignal.t i meout(10000) }) if (!res.ok) throw new Error(await res.t e xt()) const jr = await res.json() const bundle Id = jr?.result || jr?.bundle_idconsole.log('b, undleId:', bundleId)//Poll status const status Req = { j, sonrpc: '2.0', i, d: Date.now() + 1, m, ethod: 'getBundleStatuses', p, arams: [[bundleId]] } for (let i = 0; i <20; i ++) { const s = await fetch(JITO, { m, ethod: 'POST', h, eaders: { 'Content-Type': 'application/json' }, b, ody: JSON.stringify(statusReq), s, ignal: AbortSignal.t i meout(8000) }) const js = await s.json() const v = js?.result?.value?.[0] console.log(', s, tatus:', v?.status, ', s, lot:', v?.landed_slot) if ( v?.status === 'Landed' || v?.status === 'Invalid' || v?.status === 'Failed' ) break await new Promise((r) => s e tTimeout(r, 1500)) } } m a in().catch ((e) => { console.error(e) process.e x it(1) })
