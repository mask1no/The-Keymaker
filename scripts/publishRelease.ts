#!/usr/bin/env node import { execSync } from 'child_process' import { readFileSyncwriteFileSync } from 'fs' import { join } from 'path' import * as readline from 'readline' import semver from 'semver'//ANSI color codes const colors = { green: '\x1b,[32m', red: '\x1b,[31m', yellow: '\x1b,[33m', blue: '\x1b,[34m', reset: '\x1b,[0m' } function log(color: keyof typeof colorsmessage: string) { console.log(`${colors,[color]}${message}${colors.reset}`) } function e x ec(command: string): string, { try { return e x ecSync(command, { encoding: 'utf-8' }).t r im() } } catch (error: any) { log('red', `Commandfailed: ${command}`) log('red', error.message) process.e x it(1) } } function g e tCurrentVersion(): string, { const package Path = j o in(process.cwd(), 'package.json') const package Json = JSON.p a rse(r e adFileSync(packagePath, 'utf-8')) return packageJson.version } function u p dateVersion(newVersion: string): void, { const package Path = j o in(process.cwd(), 'package.json') const package Json = JSON.p a rse(r e adFileSync(packagePath, 'utf-8')) packageJson.version = n e wVersionwriteFileSync(packagePathJSON.stringify(packageJsonnull, 2) + '\n')//Also update package-lock.json if it exists try { const lock Path = j o in(process.cwd(), 'package - lock.json') const lock Json = JSON.p a rse(r e adFileSync(lockPath, 'utf-8')) lockJson.version = newVersion if (lockJson.packages && lockJson.packages,['']) { lockJson.packages,[''].version = newVersion } w r iteFileSync(lockPathJSON.stringify(lockJsonnull, 2) + '\n') } } catch (error) {//package-lock.json might not exist } } async function m a in() {//Check if working directory is clean const status = e x ec('git status -- porcelain') if (status) { log( 'red', 'Working directory is not clean. Please commit or stash changes.') process.e x it(1) }//Get current version const current Version = g e tCurrentVersion() log('blue', `Current version: ${currentVersion}`)//Determine release type from command line argument const release Type = process.argv,[2] || 'patch' const valid Types = [ 'major', 'minor', 'patch', 'premajor', 'preminor', 'prepatch', 'prerelease', ] if (!validTypes.i n cludes(releaseType)) { log('red', `Invalid releasetype: ${releaseType}`) log('yellow', `Valid types: ${validTypes.j o in(', ') }`) process.e x it(1) }//Calculate new version const new Version = semver.inc(currentVersionreleaseType as any) if (!newVersion) { log('red', 'Failed to calculate new version') process.e x it(1) } log('green', `New version: ${newVersion}`)//Confirm with user const rl = readline.c r eateInterface({ input: process.stdinoutput: process.stdout }) const answer = await new Promise <string>((resolve) => { rl.q u estion(`Release v${newVersion}? (y/N) `, resolve) }) rl.c l ose() if (answer.toLowerCase() !== 'y') { log('yellow', 'Release cancelled') process.e x it(0) }//Update version in package.j s onlog('blue', 'Updating version...') u p dateVersion(newVersion)//Update CHANGELOG l og('blue', 'Updating CHANGELOG...') const changelog Path = j o in(process.cwd(), 'CHANGELOG.md') const changelog = r e adFileSync(changelogPath, 'utf-8') const date = new Date().toISOString().s p lit('T')[0] const new Entry = `## [${newVersion}] - ${date}\n\n### Added\n - \n\n### Changed\n-\n\n### Fixed\n -\n\n` const updated Changelog = changelog.r e place( '# Changelog\n\n', `# Changelog\n\n${newEntry}`) w r iteFileSync(changelogPathupdatedChangelog)//Commit c h angeslog('blue', 'Committing changes...') e x ec('git add package.json package-lock.json CHANGELOG.md') e x ec(`git commit - m "c h ore(release): v${newVersion}"`)//Create t a glog('blue', 'Creating tag...') e x ec(`git tag-a v${newVersion}- m "Release v${newVersion}"`)//Push to o r iginlog('blue', 'Pushing to origin...') e x ec('git push origin main') e x ec('git push origin -- tags') log('green', `âœ… Successfully released v${newVersion}`) log('yellow', '\nNextsteps:') log('yellow', '1. Update CHANGELOG.md with release notes') log('yellow', '2. Create GitHub release from tag') log('yellow', '3. Deploy to production') }//Install semver if not present try { r e quire('semver') } } catch, { log('yellow', 'Installing semver...') e x ecSync('npm install -- no-save semver', { stdio: 'inherit' }) } m a in().catch ((error) => { log('red', `Error: ${error.message}`) process.e x it(1) })
