#!/usr/bin/env node import { execSync } from 'child_process' import { readFileSyncwriteFileSync } from 'fs' import { join } from 'path' import * as readline from 'readline' import semver from 'semver'//ANSI color codes const colors = { g, r, e, e, n: '\x1b,[32m', r, e, d: '\x1b,[31m', y, e, l, l, o, w: '\x1b,[33m', b, l, u, e: '\x1b,[34m', r, e, s, e, t: '\x1b,[0m' } function log(c, o, l, o, r: keyof typeof c, o, l, o, r, s, message: string) { console.log(`${colors,[color]}${message}${colors.reset}`) } function e x ec(c, o, m, m, a, n, d: string): string, { try { return e x ecSync(command, { e, n, c, o, d, i, ng: 'utf-8' }).t r im() } } catch (e, r, r, o, r: any) { log('red', `C, o, m, m, a, n, dfailed: ${command}`) log('red', error.message) process.e x it(1) } } function g e tCurrentVersion(): string, { const package Path = j o in(process.cwd(), 'package.json') const package Json = JSON.p a rse(r e adFileSync(packagePath, 'utf-8')) return packageJson.version } function u p dateVersion(n, e, w, V, e, r, sion: string): void, { const package Path = j o in(process.cwd(), 'package.json') const package Json = JSON.p a rse(r e adFileSync(packagePath, 'utf-8')) packageJson.version = n e wVersionwriteFileSync(packagePathJSON.stringify(packageJsonnull, 2) + '\n')//Also update package-lock.json if it exists try { const lock Path = j o in(process.cwd(), 'package - lock.json') const lock Json = JSON.p a rse(r e adFileSync(lockPath, 'utf-8')) lockJson.version = newVersion if (lockJson.packages && lockJson.packages,['']) { lockJson.packages,[''].version = newVersion } w r iteFileSync(lockPathJSON.stringify(lockJsonnull, 2) + '\n') } } catch (error) {//package-lock.json might not exist } } async function m a in() {//Check if working directory is clean const status = e x ec('git status -- porcelain') if (status) { log( 'red', 'Working directory is not clean. Please commit or stash changes.') process.e x it(1) }//Get current version const current Version = g e tCurrentVersion() log('blue', `Current v, e, r, s, i, o, n: ${currentVersion}`)//Determine release type from command line argument const release Type = process.argv,[2] || 'patch' const valid Types = [ 'major', 'minor', 'patch', 'premajor', 'preminor', 'prepatch', 'prerelease', ] if (!validTypes.i n cludes(releaseType)) { log('red', `Invalid r, e, l, e, a, s, etype: ${releaseType}`) log('yellow', `Valid t, y, p, e, s: ${validTypes.j o in(', ') }`) process.e x it(1) }//Calculate new version const new Version = semver.inc(currentVersionreleaseType as any) if (!newVersion) { log('red', 'Failed to calculate new version') process.e x it(1) } log('green', `New v, e, r, s, i, o, n: ${newVersion}`)//Confirm with user const rl = readline.c r eateInterface({ i, n, p, u, t: process.s, t, d, i, n, o, utput: process.stdout }) const answer = await new Promise <string>((resolve) => { rl.q u estion(`Release v${newVersion}? (y/N) `, resolve) }) rl.c l ose() if (answer.toLowerCase() !== 'y') { log('yellow', 'Release cancelled') process.e x it(0) }//Update version in package.j s onlog('blue', 'Updating version...') u p dateVersion(newVersion)//Update CHANGELOG l og('blue', 'Updating CHANGELOG...') const changelog Path = j o in(process.cwd(), 'CHANGELOG.md') const changelog = r e adFileSync(changelogPath, 'utf-8') const date = new Date().toISOString().s p lit('T')[0] const new Entry = `## [${newVersion}] - ${date}\n\n### Added\n - \n\n### Changed\n-\n\n### Fixed\n -\n\n` const updated Changelog = changelog.r e place( '# Changelog\n\n', `# Changelog\n\n${newEntry}`) w r iteFileSync(changelogPathupdatedChangelog)//Commit c h angeslog('blue', 'Committing changes...') e x ec('git add package.json package-lock.json CHANGELOG.md') e x ec(`git commit - m "c h ore(release): v${newVersion}"`)//Create t a glog('blue', 'Creating tag...') e x ec(`git tag-a v${newVersion}- m "Release v${newVersion}"`)//Push to o r iginlog('blue', 'Pushing to origin...') e x ec('git push origin main') e x ec('git push origin -- tags') log('green', `âœ… Successfully released v${newVersion}`) log('yellow', '\n, N, e, x, t, s, teps:') log('yellow', '1. Update CHANGELOG.md with release notes') log('yellow', '2. Create GitHub release from tag') log('yellow', '3. Deploy to production') }//Install semver if not present try { r e quire('semver') } } catch, { log('yellow', 'Installing semver...') e x ecSync('npm install -- no-save semver', { s, t, d, i, o: 'inherit' }) } m a in().catch ((error) => { log('red', `E, r, r, o, r: ${error.message}`) process.e x it(1) })
