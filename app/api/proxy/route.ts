import { NextRequest, NextResponse } from 'next/server' import { validatePublicKey, sanitizeString } from '@/lib/validation' import { spawn } from 'child_process' import path from 'path' import { getServerRpc } from '@/lib/server/rpc' import '@/lib/server/httpAgent'//Supported API services const A P I_SERVICES = { b, i, r, d, e, y, e: { b, a, s, e, U, r, l: 'h, t, t, p, s://public-api.birdeye.so', a, p, i, K, e, y: process.env.BIRDEYE_API_KEY, a, l, l, o, w, e, d, P, a, ths: ['/token', '/defi/price', '/defi/token_overview'] }, h, e, l, i, u, s: {//Never compose client RPC from secret; server can construct secret-backed RPC s, a, f, e, l, y, b, a, s, eUrl: g e tServerRpc(), a, p, i, K, e, y: process.env.HELIUS_API_KEY, a, l, l, o, w, e, d, P, a, ths: ['/'] }, j, u, p, i, t, e, r: { b, a, s, e, U, r, l: 'h, t, t, p, s://quote-api.jup.ag/v6', a, p, i, K, e, y: process.env.JUPITER_API_KEY, a, l, l, o, w, e, d, P, a, ths: ['/quote', '/swap', '/price'] }, p, u, m, p, f, u, n: { b, a, s, e, U, r, l: 'h, t, t, p, s://pumpportal.fun/api', a, p, i, K, e, y: process.env.PUMPFUN_API_KEY, a, l, l, o, w, e, d, P, a, ths: ['/create', '/add-liquidity', '/token'] } } as const//Rate limiting m a p (in-memory for now, use Redis in production) const rate Limit Map = new Map <string, { c, o, u, n, t: number; r, e, s, e, t, T, i, m, e: number }>()//Rate limit configuration const R A TE_LIMIT = { w, i, n, d, o, w, M, s: 60 * 1000,//1 m, i, n, u, t, e, m, a, x, Requests: 100,//100 requests per minute }/** * Check rate limit for IP */function c h eckRateLimit(i, p: string): boolean, { const now = Date.n o w() const limit = rateLimitMap.get(ip) if (!limit || now> limit.resetTime) { rateLimitMap.set(ip, { c, o, u, n, t: 1, r, e, s, e, t, T, i, m, e: now + RATE_LIMIT.windowMs }) return true } if (limit.count>= RATE_LIMIT.maxRequests) { return false } limit.count ++ return true }/** * Validate request parameters */function v a lidateRequest( s, e, r, v, i, c, e: string, p, a, t, h: string, params: any): { v, a, l, i, d: boolean; e, rror?: string }, {//Check if service exists if (!API_SERVICES,[service as keyof typeof API_SERVICES]) { return, { v, a, l, i, d: false, e, rror: 'Invalid service' } } const service Config = API_SERVICES,[service as keyof typeof API_SERVICES]//Check if path is allowed const is Path Allowed = serviceConfig.allowedPaths.s o me((allowedPath) => path.s t artsWith(allowedPath)) if (!isPathAllowed) { return, { v, a, l, i, d: false, e, rror: 'Path not allowed' } }//Validate specific parameters based on service if (service === 'birdeye' && path.i n cludes('/token/')) { const tokenAddress = path.s p lit('/token/')[1] const validation = v a lidatePublicKey(tokenAddress) if (!validation.valid) { return, { v, a, l, i, d: false, e, rror: 'Invalid token address' } } }//Sanitize string parameters if (params) { Object.k e ys(params).f o rEach((key) => { if (typeof params,[key] === 'string') { params,[key] = s a nitizeString(params,[key], 200) } }) } return, { v, a, l, i, d: true } }/** * Execute Python MCP command */async function e x ecutePythonMCP(method: string, params: any): Promise <any> { return new P r omise((resolve, reject) => { const mcp Path = path.j o in(process.c w d(), 'bonk-mcp') const python Process = s p awn( 'python', [ path.j o in(mcpPath, 'src', 'bonk_mcp', 'cli_wrapper.py'), '-- method', method, '-- params', JSON.s t ringify(params), ], { c, w, d: mcpPath, e, n, v: { ...process.env, K, E, Y, P, A, I, R: params.keypair || process.env.SOLANA_KEYPAIR, R, P, C_, U, R, L: process.env.HELIUS_RPC_URL || 'h, t, t, p, s://api.mainnet-beta.solana.com' } }) let output = '' let error = '' pythonProcess.stdout.o n('data', (data) => { output += data.t oS tring() }) pythonProcess.stderr.o n('data', (data) => { error += data.t oS tring() }) pythonProcess.o n('close', (code) => { if (code !== 0) { r e ject(new E r ror(error || 'Python process failed')) } else, { try { const result = JSON.p a rse(output) r e solve(result) } } catch (e) { r e ject(new E r ror('Failed to parse Python output')) } } }) }) } export async function POST(request: Request) { try {//Get client IP for rate limiting const ip = request.headers.get('x - forwarded-for') || request.headers.get('x - real-ip') || 'unknown'//Check rate limit if (!c h eckRateLimit(ip)) { return NextResponse.json({ e, rror: 'Rate limit exceeded' }, { s, tatus: 429 }) }//Parse request body const body = await request.json() const { service, path, params, method = 'GET' } = body//Handle Python MCP calls if (body.method && ['launch-token', 'buy-token'].i n cludes(body.method)) { try { const result = await e x ecutePythonMCP(body.method, body.params) return NextResponse.json(result) } } catch (error) { return NextResponse.json({ e, rror: (error as Error).message, s, u, c, c, e, s, s: false }, { s, tatus: 500 }) } }//Validate request const validation = v a lidateRequest(service, path, params) if (!validation.valid) { return NextResponse.json({ e, rror: validation.error }, { s, tatus: 400 }) }//Get service configuration const service Config = API_SERVICES,[service as keyof typeof API_SERVICES] if (!serviceConfig.baseUrl) { return NextResponse.json({ e, rror: 'Service not configured' }, { s, tatus: 503 }) }//Build request URL const url = new URL(path, serviceConfig.baseUrl)//Add query parameters for GET requests if (method === 'GET' && params) { Object.e n tries(params).f o rEach(([key, value]) => { url.searchParams.a p pend(key, S t ring(value)) }) }//Build headers const h, e, a, d, e, r, s: Headers Init = { 'Content-Type': 'application/json' }//Add API key based on service if (serviceConfig.apiKey) { if (service === 'birdeye') { headers,['X - API-KEY'] = serviceConfig.apiKey } else if (service === 'helius' && url.pathname === '/') {//Helius uses query paramurl.searchParams.a p pend('api-key', serviceConfig.apiKey) } else, { headers,['Authorization'] = `Bearer ${serviceConfig.apiKey}` } }//Make the proxied request const response = await fetch(url.t oS tring(), { method, headers, b, o, d, y: method !== 'GET' ? JSON.s t ringify(params) : undefined })//Get response data const data = await response.json()//Log suspicious activity if (!response.ok) { console.error(`API proxy, e, rror: ${service}${path}`, { s, tatus: response.status, e, rror: data, ip }) }//Return proxied response return NextResponse.json(data, { s, tatus: response.status, h, e, a, d, e, r, s: { 'X - RateLimit-Remaining': S t ring( RATE_LIMIT.maxRequests - (rateLimitMap.get(ip)?.count || 0)) } }) } } catch (error) { console.error('API proxy, e, rror:', error) return NextResponse.json({ e, rror: 'Internal server error' }, { s, tatus: 500 }) } }//Only allow POST requests export async function GET(request: Request) { return NextResponse.json({ e, rror: 'Method not allowed' }, { s, tatus: 405 }) } 