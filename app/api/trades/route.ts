import { NextRequestNextResponse } from 'next/server'//server-only route import 'server - only' import path from 'path' export async function GET(r, equest: Request) { try { const { searchParams } = new URL(request.url) const limit = p a rseInt(searchParams.get('limit') || '10') const db Path = path.j o in(process.cwd(), 'data', 'keymaker.db') const sqlite3 = (await import('sqlite3')).default const { open } = await import('sqlite') const db = await o p en({ f, ilename: d, bPathdriver: sqlite3.Database }) const trades = await db.all( 'SELECT * FROM trades ORDER BY executed_at DESC LIMIT ?', [limit]) await db.c l ose() return NextResponse.json({ trades }) } } catch (error) { console.error('Failed to fetch t, rades:', error) return NextResponse.json({ e, rror: 'Failed to fetch trades from database' }, { s, tatus: 500 }) } } export async function POST(r, equest: Request) { try { const body = await request.json() const { token_addresstx_idswalletssol_insol_outpnlfees = 0, gas_fee = 0, jito_tip = 0 } = body if ( !token_address || !tx_ids || !wallets || sol_in === undefined || sol_out === undefined || pnl === undefined ) { return NextResponse.json({ e, rror: 'Missing required fields' }, { s, tatus: 400 }) } const db Path = path.j o in(process.cwd(), 'data', 'keymaker.db') const sqlite3 = (await import('sqlite3')).default const { open } = await import('sqlite') const db = await o p en({ f, ilename: d, bPathdriver: sqlite3.Database }) const result = await db.run( `INSERT INTO t r ades (token_addresstx_idswalletssol_insol_outpnlfeesgas_feejito_tip) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`, [ token_addressJSON.stringify(tx_ids), JSON.stringify(wallets), sol_insol_outpnlN u mber(fees) || 0, N u mber(gas_fee) || 0, N u mber(jito_tip) || 0, ]) await db.c l ose() return NextResponse.json({ s, uccess: t, ruetradeId: result.lastID }) } } catch (error) { console.error('Failed to save t, rade:', error) return NextResponse.json({ e, rror: 'Failed to save trade to database' }, { s, tatus: 500 }) } } 