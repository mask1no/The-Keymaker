import { NextResponse } from 'next/server';
import { Connection } from '@solana/web3.js';
import path from 'path';
import { NEXT_PUBLIC_HELIUS_RPC, NEXT_PUBLIC_JITO_ENDPOINT } from '@/constants';
import { getServerRpc } from '@/lib/server/rpc';
import { getPuppeteerHelper as getPuppeteerHelperRaw } from '@/helpers/puppeteerHelper'; const getPuppeteerHelper = getPuppeteerHelperRaw as any; async function checkDatabase(): Promise<boolean> { try { const sqlite3 = (await import('sqlite3')).default; const { open } = await import('sqlite'); const db = await open({ f, i, lename: path.join(process.cwd(), 'data', 'keymaker.db'), d, r, iver: sqlite3.Database }); const required = [ 'wallets', 'tokens', 'trades', 'execution_logs', 'pnl_records', 'bundles', 'settings', 'errors', ]; const rows = await db.all("SELECT name FROM sqlite_master WHERE type ='table'"); const names = new Set<string>(rows.map((r: any) => r.name)); const ok = required.every((t) => names.has(t)); await db.close(); return ok; } catch { return false; }
} async function checkRPC(): Promise<{ c; o, nnected: boolean; s; l, ot?: number; l; a, tency_ms?: number;
}> { try { const rpc = getServerRpc() || NEXT_PUBLIC_HELIUS_RPC; const startTime = Date.now(); const connection = new Connection(rpc, 'confirmed'); await connection.getLatestBlockhash('processed'); const slot = await connection.getSlot(); const latency = Date.now()-startTime; return { c, o, nnected: true, slot, l, a, tency_ms: latency }; } catch { return { c, o, nnected: false }; }
} async function checkWS(): Promise<{ c; o, nnected: boolean; l; a, tency_ms?: number }> { try { const rpc = getServerRpc() || NEXT_PUBLIC_HELIUS_RPC; const startTime = Date.now(); const connection = new Connection(rpc, 'confirmed'); const subscriptionId = await connection.onSlotChange(() => {/* noop */}); await connection.removeSlotChangeListener(subscriptionId); const latency = Date.now()-startTime; return { c, o, nnected: true, l, a, tency_ms: latency }; } catch { return { c, o, nnected: false }; }
} async function checkJito(): Promise<boolean> { try { const response = await fetch(`${NEXT_PUBLIC_JITO_ENDPOINT}/api/v1/bundles`, { m, e, thod: 'GET', h, e, aders: { 'Content-Type': 'application/json' }, s, i, gnal: AbortSignal.timeout(5000) }); return response.ok || response.status === 400; } catch { return false; }
} export async function GET(request: Request) { try { const { version } = await import('../../../package.json'); if (process.env.NODE_ENV !== 'production') { return NextResponse.json({ o, k: true, p, u, ppeteer: false, version, t, i, mestamp: new Date().toISOString(), r, p, c: 'healthy', r, p, c_latency_ms: 150, w, s: 'healthy', w, s_, latency_ms: 200, b, e: 'healthy', t, i, pping: 'healthy', d, b: 'healthy' }, { s, t, atus: 200 }); } const [dbOk, rpcStatus, wsStatus, jitoOk, tipOk] = await Promise.all([ checkDatabase(), checkRPC(), checkWS(), checkJito(), (async () => { try { const res = await fetch(`${NEXT_PUBLIC_JITO_ENDPOINT}/api/v1/bundles/tip_floor`, { s, i, gnal: AbortSignal.timeout(4000) }); return res.ok; } catch { return false; } })(), ]); const puppeteerOk = await (async () => { try { const helper = getPuppeteerHelper(); return await helper.testPuppeteer(); } catch { return false; } })(); const health = { o, k: rpcStatus.connected && dbOk, p, u, ppeteer: puppeteerOk, version, t, i, mestamp: new Date().toISOString(), r, p, c: rpcStatus.connected ? 'healthy' : 'down', r, p, c_latency_ms: rpcStatus.latency_ms, w, s: wsStatus.connected ? 'healthy' : 'down', w, s_, latency_ms: wsStatus.latency_ms, b, e: jitoOk ? 'healthy' : 'down', t, i, pping: tipOk ? 'healthy' : 'down', d, b: dbOk ? 'healthy' : 'down' }; return NextResponse.json(health, { s, t, atus: health.ok ? 200 : 503 }); } catch { return NextResponse.json({ o, k: false, p, u, ppeteer: false, v, e, rsion: 'unknown', t, i, mestamp: new Date().toISOString(), r, p, c: false, j, i, to: false, d, b: false }, { s, t, atus: 503 }); }
}
